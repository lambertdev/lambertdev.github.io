<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L&amp;H SITE</title>
  
  <subtitle>两个背包旅行者的网络自留地。分享旅行日记，Linux技术，机器学习，建站技巧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://l2h.site/"/>
  <updated>2019-10-06T00:32:38.386Z</updated>
  <id>http://l2h.site/</id>
  
  <author>
    <name>Lambert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://l2h.site/2019/09/15/linux-process-manage-1/"/>
    <id>http://l2h.site/2019/09/15/linux-process-manage-1/</id>
    <published>2019-09-15T01:01:02.000Z</published>
    <updated>2019-10-06T00:32:38.386Z</updated>
    
    <content type="html"><![CDATA[<p>回顾下操作系统概念：现代计算机往往都是“同时”运行多个任务。系统若只有一个处理器，那么给定时刻只可能有一个任务在执行。而操作系统通过进程管理和调度，切换正在执行的任务，是用户在感官上认为计算机是并行执行多个任务。当然，若是多处理器系统，真正同时执行的任务可以达到处理器的数目。</p><p>内核进行进程管理的主要解决的问题：</p><ul><li>任务有轻重缓急之分，需要可以根据任务的紧急程度给予任务不同的执行优先级和时间。同时尽可能保证任务执行的公平性。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在Linux系统中，我们所讲的任务即进程。进程调度，就是根据当前系统的运行状况，对进程状态的切换。</p><p>Linux中进程主要有如下状态：</p><ul><li><strong>运行</strong>：该进程此刻正在执行。</li><li><strong>等待</strong>：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。</li><li><strong>睡眠</strong>：进程正在睡眠无法运行，因为它在等待一个外部事件（或某种资源）。调度器无法在下一次任务切换时选择该进程。</li></ul><a id="more"></a><p>以上状态可以相互转换（等待–&gt;睡眠转换除外），转换的条件主要有：</p><ul><li>进程时间片用完或轮转到该进程</li><li>进程阻塞等待某种资源/某种资源准备好了</li></ul><h3 id="进程表示"><a href="#进程表示" class="headerlink" title="进程表示"></a>进程表示</h3><p>进程用task_struct结构体来表示，定义在include/linux/sched.h如下（省略部分成员）。重点结构体成员意义注释在代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*进程当前状态，由sched.h中的宏定义TASK_RUNNING~TASK_STATE_MAX表示。</span></span><br><span class="line"><span class="comment"> TASK_RUNNING意味着进程处于可运行状态。这并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件。</span></span><br><span class="line"><span class="comment"> TASK_INTERRUPTIBLE是针对等待某事件或其他资源的睡眠进程设置的。在内核发送信号给该进程表明事件已经发生时，进程状态变为TASK_RUNNING，它只要调度器选中该进程即可恢复执行。</span></span><br><span class="line"><span class="comment"> TASK_UNINTERRUPTIBLE用于因内核指示而停用的睡眠进程。它们不能由外部信号唤醒，只能由内核亲自唤醒。</span></span><br><span class="line"><span class="comment"> TASK_STOPPED表示进程特意停止运行，例如，由调试器暂停。</span></span><br><span class="line"><span class="comment"> TASK_TRACED本来不是进程状态，用于从停止的进程中，将当前被调试的那些（使用ptrace机制）与常规的进程区分开来。</span></span><br><span class="line"><span class="comment"> EXIT_ZOMBIE为僵尸状态，表示进程结束时父进程未调用wait调用的进程</span></span><br><span class="line"><span class="comment"> EXIT_DEAD状态则是指wait系统调用已经发出，而进程完全从系统移除之前的状态。只有多个线程对同一个进程发出wait调用时，该状态才有意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">//进程栈指针</span></span><br><span class="line"><span class="keyword">atomic_t</span> usage; <span class="comment">//进程描述符使用计数，被置为2时，表示进程描述符正在被使用而且其相应的进程处于活动状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags; <span class="comment">//进程标志</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;<span class="comment">//进程调试跟踪相关标记</span></span><br><span class="line"><span class="keyword">int</span> on_rq; <span class="comment">//CPU可能有多个运行队列，可能会在运行队列中移动。标记表示进程目前在运行队列位置状态。</span></span><br><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;<span class="comment">//静态优先级动态优先级和一般优先级，调度器使用</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority; <span class="comment">//实时进程运行优先级</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">//指向进程的调度器(完全公平调度器？实时调度器等)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">//调度实体，每个进程就是一个调度实体。调度实体也可以是用户进程组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span> <span class="comment">//实时进程调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span> <span class="comment">//Deadline调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">preempt_notifiers</span>;</span><span class="comment">//存放进程被抢占的通知函数链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy; <span class="comment">//调度策略</span></span><br><span class="line"><span class="keyword">int</span> nr_cpus_allowed; <span class="comment">//允许调度的CPU数量</span></span><br><span class="line"><span class="keyword">cpumask_t</span> cpus_allowed;<span class="comment">//掩码图表示允许调度的CPU</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span><span class="comment">//进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span><span class="comment">//进程内存管理结构体</span></span><br><span class="line">u64 vmacache_seqnum;<span class="comment">//虚拟地址区间缓存序列号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vmacache</span>\[<span class="title">VMACACHE_SIZE</span>\];</span><span class="comment">//虚拟地址区间缓存</span></span><br><span class="line"><span class="keyword">int</span> exit_state; <span class="comment">//以下记录进程的退出状态信息</span></span><br><span class="line"><span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"><span class="comment">/* 调度器相关标记 */</span></span><br><span class="line"><span class="keyword">unsigned</span> sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_migrated:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> :<span class="number">0</span>; <span class="comment">/* force alignment to the next boundary */</span></span><br><span class="line"><span class="keyword">unsigned</span> in_execve:<span class="number">1</span>; <span class="comment">/* bit to tell LSMs we're in execve */</span></span><br><span class="line"><span class="keyword">unsigned</span> in_iowait:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(TIF_RESTORE_SIGMASK)</span></span><br><span class="line"><span class="keyword">unsigned</span> restore_sigmask:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> memcg_may_oom:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="keyword">unsigned</span> memcg_kmem_skip_account:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line"><span class="keyword">unsigned</span> brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid; <span class="comment">//进程全局PID</span></span><br><span class="line"><span class="keyword">pid_t</span> tgid; <span class="comment">//进程组内PID</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">//真正父进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">//父进程（为什么会有real_parent和parent，因为线程的存在，其父进程应为创建它的进程的父进程）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span><span class="comment">//子进程列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span><span class="comment">//兄弟进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">//对多线程程序有用，指向线程组组长</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptraced</span>;</span> <span class="comment">//ptrace跟踪的进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_entry</span>;</span> <span class="comment">//所在父进程的ptrace链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>\[<span class="title">PIDTYPE_MAX</span>\];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span> <span class="comment">//线程组链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_node</span>;</span> <span class="comment">//线程节点链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span><span class="comment">/* for vfork() */</span></span><br><span class="line"><span class="keyword">int</span> __user *set_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line"><span class="keyword">int</span> __user *clear_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line"><span class="comment">//进程运行时间相关参数</span></span><br><span class="line"><span class="keyword">cputime_t</span> utime, stime, utimescaled, stimescaled;</span><br><span class="line"><span class="keyword">cputime_t</span> gtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span> <span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line"><span class="keyword">seqcount_t</span> vtime_seqcount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtime_snap;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">VTIME_INACTIVE = <span class="number">0</span>,</span><br><span class="line">VTIME_USER,</span><br><span class="line">VTIME_SYS,</span><br><span class="line">&#125; vtime_snap_whence;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"><span class="keyword">atomic_t</span> tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">u64 start_time;</span><br><span class="line">u64 real_start_time;<span class="comment">//启动时间</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_cputime</span> <span class="title">cputime_expires</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>\[3\];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程身份相关参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer's credentials at attach */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task credentials (COW) */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="keyword">char</span> comm\[TASK_COMM_LEN\]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">     \- access with \[gs\]et_task_comm (which lockit with task_lock())</span></span><br><span class="line"><span class="comment">     \- initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span> <span class="comment">//路径相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">//IPC参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span><span class="comment">//信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span><span class="comment">//共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count; <span class="comment">//切换次数，用于检验进程挂起</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">// 进程文件系统信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 打开文件的信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span> <span class="comment">// 命名空间 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> <span class="comment">//信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span> <span class="comment">//信号处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line"><span class="keyword">sigset_t</span> saved_sigmask;<span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line"><span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line"><span class="keyword">unsigned</span> sas_ss_flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">task_works</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line"><span class="keyword">kuid_t</span> loginuid;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sessionid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span> <span class="title">seccomp</span>;</span></span><br><span class="line"><span class="comment">//线程组信息</span></span><br><span class="line">   u32 parent_exec_id;</span><br><span class="line">   u32 self_exec_id;</span><br><span class="line"><span class="comment">//进程资源锁</span></span><br><span class="line"><span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"><span class="keyword">raw_spinlock_t</span> pi_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> <span class="title">wake_q</span>;</span></span><br><span class="line"><span class="comment">//虚拟内存状态信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span> *<span class="title">reclaim_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line"><span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span> <span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">u64 acct_rss_mem1;<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">u64 acct_vm_mem1;<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line"><span class="keyword">cputime_t</span> acct_timexpd;<span class="comment">/* stime + utime since last update */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line"><span class="keyword">nodemask_t</span> mems_allowed;<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line"><span class="keyword">seqcount_t</span> mems_allowed_seq;<span class="comment">/* Seqence no to catch updates */</span></span><br><span class="line"><span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line"><span class="keyword">int</span> cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line"><span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line"><span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span> *<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pi_state_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span> *<span class="title">pi_state_cache</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">perf_event_ctxp</span>\[<span class="title">perf_nr_task_contexts</span>\];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">perf_event_mutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为要支持各种各样的功能，task_struct已经变得非常大。不过总体上，结构体可以被划分为如下部分：</p><ul><li>状态和执行信息，如待决信号、使用的二进制格式（和其他系统二进制格式的任何仿真信息）、进程ID号（ pid）、到父进程及其他有关进程的指针、优先级和程序执行有关的时间信息（例如CPU时间）。</li><li>有关已经分配的虚拟内存的信息。</li><li>进程身份凭据，如用户ID、组ID以及权限①等。可使用系统调用查询（或修改）这些数据。</li><li>使用的文件包含程序代码的二进制文件，以及进程所处理的所有文件的文件系统信息，这些都必须保存下来。</li><li>进程信息记录该进程特定于CPU的运行时间数据（该结构的其余字段与所使用的硬件无关）。</li><li>在与其他应用程序协作时所需的进程间通信有关的信息。</li><li>该进程所用的信号处理程序，用于响应到来的信号。</li></ul><h3 id="进程ID号"><a href="#进程ID号" class="headerlink" title="进程ID号"></a>进程ID号</h3><p>在task_struct结构体里，我们看到了很多进程ID相关字段，初看会很容易混淆。本节介绍Linux进程ID管理相关思想，帮助理解这些字段的含义。</p><p>乍一看进程ID管理应该比较简单：内核只需要保证分配的id不唯一，释放掉的id可以被其他新创建的进程id使用即可。但是事实并非如此，内核需要做如下考量：</p><ul><li>内核有<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">命名空间</a>的概念，一个进程可以出现在多个命名空间，它在不同的命名空间的id是不同的。</li><li>同一个进程可以有多个线程，这些线程（其实也是task_struct）共享同一个线程组id (TGID)</li><li>进程可以合并为进程组，而进程组又可以合并为会话（Session）。组或者会话里的进程共享相同的组id或会话id。</li></ul><p>PID分配需要在特定的命名空间内保证id的唯一性。用来表示PID的命名空间定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pid_allocated;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span> <span class="comment">//对应命名空间0号进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//该命名空间的层级</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span> <span class="comment">//命名空间上级的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">proc_mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_self</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_thread_self</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_pin</span> *<span class="title">bacct</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">proc_work</span>;</span></span><br><span class="line"><span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line"><span class="keyword">int</span> hide_pid;</span><br><span class="line"><span class="keyword">int</span> reboot;<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125; __randomize_layout</span><br></pre></td></tr></table></figure><p>而内核管理命名空间内的pid也主要围绕两个数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nr; <span class="comment">//id</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span> <span class="comment">//指向所在命名空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;  <span class="comment">//pid使用数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//层级数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>\[<span class="title">PIDTYPE_MAX</span>\];</span> <span class="comment">//对应每种类别命名空间进程的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>\[1\];</span> <span class="comment">//每级的pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中PIDTYPE_MAX为pid类别的枚举类型最大值，具体该枚举类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">PIDTYPE_PID,</span><br><span class="line">PIDTYPE_TGID,</span><br><span class="line">PIDTYPE_PGID,</span><br><span class="line">PIDTYPE_SID,</span><br><span class="line">PIDTYPE_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，task_struct还保留了两个pid，分别为：</p><ul><li>pid: 初使命名空间（即init进程所在空间）中该进程的全局ID号</li><li>tgid：初使命名空间中该进程的线程组ID号，若该进程非多线程进程，则值与pid相同。</li></ul><p>一张图表示task_struct中进程id的相互关联：</p><p><img alt data-src="https://i0.wp.com/l2h.site/wp-content/uploads/2019/09/1.png?fit=810%2C467&ssl=1"></p><p>pid数据结构关系图（引用自《深入理解linux内核架构》）</p><p>注意，上图结构为2.6版内核中数据结构。新版内核（截至目前应该是5.）对结构会有部分调整，但总体管理方式和数据结构间关联未变。</p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>进程可以有子进程，其子进程链表用task_struct的children元素表示。一个子进程和父进程的其他子进程互为兄弟进程，通过task_struct的sibling元素相互关联。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了linux内核管理的基本概念，以及相应的数据结构。后续介绍会包含进程调度基本架构和思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾下操作系统概念：现代计算机往往都是“同时”运行多个任务。系统若只有一个处理器，那么给定时刻只可能有一个任务在执行。而操作系统通过进程管理和调度，切换正在执行的任务，是用户在感官上认为计算机是并行执行多个任务。当然，若是多处理器系统，真正同时执行的任务可以达到处理器的数目。&lt;/p&gt;&lt;p&gt;内核进行进程管理的主要解决的问题：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;任务有轻重缓急之分，需要可以根据任务的紧急程度给予任务不同的执行优先级和时间。同时尽可能保证任务执行的公平性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;进程状态&quot;&gt;&lt;a href=&quot;#进程状态&quot; class=&quot;headerlink&quot; title=&quot;进程状态&quot;&gt;&lt;/a&gt;进程状态&lt;/h3&gt;&lt;p&gt;在Linux系统中，我们所讲的任务即进程。进程调度，就是根据当前系统的运行状况，对进程状态的切换。&lt;/p&gt;&lt;p&gt;Linux中进程主要有如下状态：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运行&lt;/strong&gt;：该进程此刻正在执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待&lt;/strong&gt;：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;睡眠&lt;/strong&gt;：进程正在睡眠无法运行，因为它在等待一个外部事件（或某种资源）。调度器无法在下一次任务切换时选择该进程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux进程管理" scheme="http://l2h.site/categories/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac Mojave修改屏幕主题色</title>
    <link href="http://l2h.site/2019/08/13/mac-mojave-e4-bf-ae-e6-94-b9-e5-b1-8f-e5-b9-95-e4-b8-bb-e9-a2-98-e8-89-b2/"/>
    <id>http://l2h.site/2019/08/13/mac-mojave-e4-bf-ae-e6-94-b9-e5-b1-8f-e5-b9-95-e4-b8-bb-e9-a2-98-e8-89-b2/</id>
    <published>2019-08-13T09:18:39.000Z</published>
    <updated>2019-10-05T11:04:33.171Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚给Mac更新了系统，发现多了一项功能，即修改屏幕主题色。有浅色和深色两种选择。深色的还蛮酷的。修改方法：</p><blockquote><p>系统偏好设置-&gt;通用-&gt;外观</p></blockquote><p>选择你喜欢的主题色即可</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/08/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8B%E5%8D%884.57.03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚给Mac更新了系统，发现多了一项功能，即修改屏幕主题色。有浅色和深色两种选择。深色的还蛮酷的。修改方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统偏好设置-&amp;gt;通用-&amp;gt;外观&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择你喜欢的主题色即可&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="L&amp;amp;H Site" scheme="http://l2h.site/categories/L-amp-H-Site/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux内核内存管理简析(1)</title>
    <link href="http://l2h.site/2019/08/13/linux-mm-1/"/>
    <id>http://l2h.site/2019/08/13/linux-mm-1/</id>
    <published>2019-08-13T00:49:07.000Z</published>
    <updated>2019-10-06T00:33:00.770Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是Linux内核最为复杂且最为重要的部分，本文从原理及代码角度对Linux内存管理机制进行分析。</p><h2 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h2><p>Linux将内存从大到小依次划分为Node（节点）-&gt;Zone（内存域）-&gt;Page（页）：</p><ul><li>节点：在大型结算及系统中，内存有不同的簇，依据对处理器距离的不同，访问这些簇有不同的代价。而这些簇就可以成为节点。例：在PC系统中可以理解为实际挂载的物理内存；在嵌入式系统中，有两块内存芯片A和B，分别代表一个节点。</li><li>内存域：内存域并不是物理存在的概念，是Linux系统对每个内存节点进行管理的单位，每个节点的内存域表示的是对该节点不同地址范围的划分。一般内存域有三种，分别为Normal、DMA和HighMem。</li><li>页：在每个内存域中，内存被划分为大小固定的块（32位系统一般为4K大小），为内核进行内存分配的基本单位（当然内核内存管理机制其实更为复杂，“基本单位”不代表每次分配内存最小就要分到4K。后边可以看到，当需要获取小于4K大小的内存时，内核有Slab分配器来满足要求）</li></ul><a id="more"></a><p>一张图说明Node、Zone和Page的关系如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                  Node 1            Node 2           Node 3</span><br><span class="line">                       +----------+     +----------+     +----------+</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">Zone_High </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       +----------+     |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">Zone_Norm </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       +----------+     |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">                       |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">     page  page        |<span class="string">Zone_DMA  </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">+-+--+--+--+--+        |<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">  &lt;--------+       </span>|<span class="string">     </span>|<span class="string">          </span>|<span class="string">     </span>|<span class="string">          </span>|</span><br><span class="line">+-+--+--+--+--+        +----------+     +----------+     +----------+</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>构成上述三个内存划分的数据结构如下：</p><h3 id="内存节点"><a href="#内存节点" class="headerlink" title="内存节点"></a>内存节点</h3><p>Node对应的结构为pglist_data_t，定义如下（为方便理解，省略部分结构体成员）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones_MAX_NR_ZONES</span>\];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists_MAX_ZONELISTS</span>\];</span></span><br><span class="line">    <span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page  range, including holes */</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span> <span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="keyword">int</span> kswapd_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line">    <span class="keyword">int</span> kswapd_failures;        <span class="comment">/* Number of 'reclaimed == 0' runs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kcompactd_classzone_idx;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_next_window;</span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       totalreserve_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line">    <span class="comment">/* Number of non-deferred pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> static_init_pgcnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/* Per-node vmstats */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_NODE_STAT_ITEMS\];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>node_zones</strong>: 内存节点上的内存域，分别为 ZONE_HIGHMEM, ZONE_NORMAL, ZONE_DMA。新版Linux还增加了ZONE_MOVABLE和ZONE_DEVICE。</li><li><strong>node_zonelists:</strong> 对内存域进行类别指定的优先级顺序。例，当ZONE_HIGHMEM分配失败时，会u退到ZONE_DMA类型后ZONE_NORMAL类型</li><li><strong>nr_zones:</strong> 该节点上的内存域数量</li><li><strong>node_mem_map:</strong> 节点中页面的映射图</li><li><strong>bdata:</strong> 与内核初始化内存分配器相关数据</li><li><strong>node_size_lock</strong>： 与内存热拔插相关</li><li><strong>node_start_pfn:</strong> 内存节点的起始页。</li><li><strong>node_present_pages:</strong> 物理页面数量<strong>.</strong></li><li><strong>node_spanned_pages:</strong> 内存节点物理页面的大小</li><li><strong>node_id:</strong> 节点编号</li><li><strong>kswapd_wait</strong>/<strong>pfmemalloc_wait</strong>/<strong>kswapd</strong>/<strong>kswapd_order</strong>/<strong>kswapd_classzone_idx/kswapd_failures:</strong> kswapd内核线程相关参数</li><li><strong>……..</strong></li></ul><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域对应的结构体为struct zone，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_NR_WMARK\];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line">    <span class="keyword">long</span> lowmem_reserve_MAX_NR_ZONES\];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>  *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       zone_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       managed_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       spanned_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       present_pages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">seqlock_t</span>       span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> initialized;</span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area_MAX_ORDER</span>\];</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_ZONE_STAT_ITEMS\];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><ul><li><strong>watermark</strong>: 内存域的水位</li><li><strong>nr_reserved_highatomic:</strong> 紧急内存大小，</li><li><strong>lowmem_reserve</strong>:内存域最少保留内存</li><li><strong>zone_pgdat</strong>: 所在内存节点指针</li><li><strong>pageset</strong>: 每个CPU维护的页面列表</li><li><strong>zone_start_pfn</strong>:内存域第一个页的索引</li><li><strong>managed_pages</strong>: 伙伴系统管理的所有页面数量</li><li><strong>spanned_pages</strong>: 内存域所跨越所有内存页数量</li><li><strong>present_pages</strong>: 内存域物理内存所有页数量(除去内存空洞后的部分)present_pages=spanned_pages-absent_pages</li><li><strong>name</strong>: 区域名</li><li><strong>free_area</strong>:所有空闲页面的数组</li><li><strong>flags</strong>:内存域标识</li><li><strong>lock</strong>:保护free_area的锁</li><li><strong>vm_stat</strong>:虚拟内存统计信息</li></ul><p>特别说明一下内存域的水位（Watermark），它表示几个阈值，用来管理内核线程kswapd唤起与休眠的。当域内可用内存水位较高时，kswapd不用起来工作，而水位较低时，kswapd需要唤起来回收内存。如下图（来自深入理解Linux虚拟内存管理）：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/08/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.40.53.png"></p><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>系统中每个物理页面都有数据结构struct page与其关联，用于管理页面的使用。结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">truct page &#123;</span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;       </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span> </span><br><span class="line">        <span class="keyword">void</span> *s_mem;            <span class="comment">/* slab first object */</span></span><br><span class="line">        <span class="keyword">atomic_t</span> compound_mapcount; <span class="comment">/* first tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;     <span class="comment">/* sl_aou\]b first free object */</span></span><br><span class="line">        <span class="comment">/* page_deferred_list().prev    -- second tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">        <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> active;        <span class="comment">/* SLAB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">int</span> units;          <span class="comment">/* SLOB */</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">atomic_t</span> _refcount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Third double word block */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>  <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">int</span> pages;  <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="keyword">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">            <span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> __pad;    </span><br><span class="line">            <span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SL_AU\]B: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;          <span class="comment">/* Kernel virtual address (NULL if  not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面结构体使用双字块来划分：</p><ul><li><p>第一个双字</p><ul><li><p>flags: 页面状态，脏页、上锁等院子标记</p></li><li><p>联合体</p><ul><li><p>mapping：指向inode address_space</p></li><li><p>s_mem：slab首对象</p></li><li><p>compound_mapcount：</p></li></ul></li></ul></li><li><p>第二个双字：</p><ul><li><p>联合体</p><ul><li><p>index：页面偏移</p></li><li><p>freelist：slab/slob的首个可用对象</p></li></ul></li><li><p>联合体：slab/slub/slob相关的记数（取决于编译内核时选择的管理方式）</p></li></ul></li><li><p>第三个双字：</p><ul><li><p>lru：换出页列表</p></li><li><p>pgmap:</p></li><li><p>rcu_head</p></li><li><p>结构体，用于slub管理</p></li><li><p>结构体，用于复合页管理</p></li></ul></li><li><p>联合体(ptl/slab_cache): slab指针，或者PTE自旋锁</p></li><li><p>virtual: 内核虚拟地址。用于高端内存中的页，即无法直接映射到内核内存中的页</p></li></ul><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux进行内存寻址时，往往不会直接内存物理地址，需要经过虚拟地址到物理地址的转化。使用虚拟地址的好处是可以避免进程与进程间互踩内存（除非特别指定共享内存），同时虚拟内存的换出换入使得进程使用超过物理内存大小的内存范围。</p><p>CPU中内存管理单元（MMU）作用就是根据内存中特定的转化表格（不错，页表本身也是需要内存存储的），将虚拟地址转化为真正的物理地址。而这个表格就是我们所讲的页表。</p><p>取决于体系结构，Linux采用三级或者四级页表机制：</p><ul><li>PGD：Page Global Directory，全局页表目录</li><li>PUD：Page Upper Directory，上级页表目录</li><li>PMD：Page Middle Directory，中级页表目录</li><li>PTE：Page Table Entry，页表表项</li></ul><p>每级表项所占位数，取决于我们编译内核时的选择。一般情况下，取决于寻址宽度，以及CPU体系结构每级页表所占位数是有约定俗成的。</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/08/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.56.58.png"></p><p>内核在arch/xxx/include/asm/page.h（其中xxx表示CPU体系结构）定义了一系列的类型、函数和宏来方便对每级页表进行操作。</p><p>如上图我们看到的几个SHIFT宏定义，是为了方便通过位移操作来快速获取对应等级页表。</p><p>在IA64中用来表示以上各级页表目录的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pud; &#125; <span class="keyword">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br></pre></td></tr></table></figure><p>与页表相关的宏或者函数定义有<a href="https://elixir.bootlin.com/linux/latest/ident/pmd_alloc" target="_blank" rel="noopener">pmd/pte/pgd_alloc</a>/free()等等，具体可以参考include/linux/mm.h。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了Linux内核内存管理的基本单位划分Node、Zone和Page及对应的数据结构，同时对页表的基本概念进行了介绍。将在下一文分析Linux初始化流程中对内存的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理是Linux内核最为复杂且最为重要的部分，本文从原理及代码角度对Linux内存管理机制进行分析。&lt;/p&gt;&lt;h2 id=&quot;内存的划分&quot;&gt;&lt;a href=&quot;#内存的划分&quot; class=&quot;headerlink&quot; title=&quot;内存的划分&quot;&gt;&lt;/a&gt;内存的划分&lt;/h2&gt;&lt;p&gt;Linux将内存从大到小依次划分为Node（节点）-&amp;gt;Zone（内存域）-&amp;gt;Page（页）：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;节点：在大型结算及系统中，内存有不同的簇，依据对处理器距离的不同，访问这些簇有不同的代价。而这些簇就可以成为节点。例：在PC系统中可以理解为实际挂载的物理内存；在嵌入式系统中，有两块内存芯片A和B，分别代表一个节点。&lt;/li&gt;
&lt;li&gt;内存域：内存域并不是物理存在的概念，是Linux系统对每个内存节点进行管理的单位，每个节点的内存域表示的是对该节点不同地址范围的划分。一般内存域有三种，分别为Normal、DMA和HighMem。&lt;/li&gt;
&lt;li&gt;页：在每个内存域中，内存被划分为大小固定的块（32位系统一般为4K大小），为内核进行内存分配的基本单位（当然内核内存管理机制其实更为复杂，“基本单位”不代表每次分配内存最小就要分到4K。后边可以看到，当需要获取小于4K大小的内存时，内核有Slab分配器来满足要求）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux内存管理" scheme="http://l2h.site/categories/Linux/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="内存管理" scheme="http://l2h.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux MTD子系统</title>
    <link href="http://l2h.site/2019/08/02/linux-mtd-e5-ad-90-e7-b3-bb-e7-bb-9f/"/>
    <id>http://l2h.site/2019/08/02/linux-mtd-e5-ad-90-e7-b3-bb-e7-bb-9f/</id>
    <published>2019-08-02T11:27:46.000Z</published>
    <updated>2019-10-06T00:31:25.344Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要MTD子系统"><a href="#为什么需要MTD子系统" class="headerlink" title="为什么需要MTD子系统"></a>为什么需要MTD子系统</h3><p>嵌入式系统使用Flash作为存储设备，Flash类别有Nand、Nor等。Flash的上层是文件系统。直觉上，系统中使用这些Flash时，我们需要为每种Flash编写驱动。同时在调用Flash的文件系统做接口对接。这样，每使用一种新的Flash类型甚至型号，都得修改文件系统的编码来做适配。显然，这会造成代码的爆炸，同时也不方便大家各司其职（例如：厂商A做Flash，添加一个新的Flash需要厂商A的驱动开发人员去改写所有文件系统的接口，这显然不现实）。</p><p>几乎所有的现代操作系统都不会允许以上事情的发生。通用的做法是，抽象出上下层对接的方式，厂商驱动开发人员只需要按照接口进行匹配节课。</p><a id="more"></a><p>MTD（Memory Technology Devices）便是Linux系统下处理以上问题的方式。</p><h3 id="架构与代码目录"><a href="#架构与代码目录" class="headerlink" title="架构与代码目录"></a>架构与代码目录</h3><p>MTD在系统中的结构如下图。</p><ul><li>构成MTD的部分有MTD核心、MTD字符设备和MTD块设备层。成为文件系统和底层硬件驱动的沟通桥梁</li><li>MTD核心建立在Flash驱动（位于drivers/mtd/）之上，为Flash驱动提供一系列的API抽象</li><li>MTD为上层提供统一的操作抽象接口如<code>dev/mtd0</code>, <code>/dev/mtd1</code>（例如擦除、读写等），同时提供 <code>/proc/mtd</code>供上层读取MTD系统相关信息</li><li>MTD提供一系列的API，为基于Flash的文件系统提供控制操作<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">   +-----------------+</span></span><br><span class="line"><span class="code">  | 使用文件系统的应用 |</span></span><br><span class="line"><span class="code">   +-----------------+</span></span><br><span class="line"><span class="code">   +------------+ +------------+</span></span><br><span class="line"><span class="code">   |Char Dev节点 | |Block Dev节点| 用户空间层</span></span><br><span class="line"><span class="code">   +------------+ +------------+</span></span><br><span class="line"><span class="code">+---------------------------------+</span></span><br><span class="line"><span class="code">   +---------------+-----------+</span></span><br><span class="line"><span class="code">   |  MTD字 符 设 备| MTD块 设 备|</span></span><br><span class="line"><span class="code">   +---------------+-----------+</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br><span class="line"><span class="code">   |      MTD Core             | 内核层</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br><span class="line"><span class="code">   |       Flash驱 动           |</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br><span class="line"><span class="code">+---------------------------------+</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br><span class="line"><span class="code">   |       各 种 Flash          | 硬件层</span></span><br><span class="line"><span class="code">   +---------------------------+</span></span><br></pre></td></tr></table></figure></li></ul><p>MTD代码在Linux内核源码树的位置：</p><ul><li>_include/linux/mtd/_：定义所有MTD相关头文件</li><li><em>drivers/mtd</em>: 定义MTD核心，以及Flash驱动</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>MTD的核心结构定义在内核源码树的_include/linux/mtd/mtd.h_。先看核心数据结构mtd_info：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> &#123;</span></span><br><span class="line">u_char type;</span><br><span class="line"><span class="keyword">uint32_t</span> flags;</span><br><span class="line"><span class="keyword">uint64_t</span> size; <span class="comment">// MTD总大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> erasesize; <span class="comment">//擦除大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> writesize; <span class="comment">//最小写单位</span></span><br><span class="line"><span class="keyword">uint32_t</span> writebufsize; <span class="comment">//写缓冲大小，提升写效率</span></span><br><span class="line"><span class="keyword">uint32_t</span> oobsize;   <span class="comment">// 每个Flash 块的OOB数量</span></span><br><span class="line"><span class="keyword">uint32_t</span> oobavail;  <span class="comment">// 每个Flash块的OOB大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_shift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_shift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_mask;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_mask; <span class="comment">//shift和mask在Linux源码中常见，主要用于MTD大小相关的位运算</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bitflip_threshold; <span class="comment">//位翻转阈值，即最大允许位翻转个数，超出后，读写返回“-EUCLEAN”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//MTD名称</span></span><br><span class="line"><span class="keyword">int</span> index;  <span class="comment">//MTD索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_ooblayout_ops</span> *<span class="title">ooblayout</span>;</span> <span class="comment">//OOB layout操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_pairing_scheme</span> *<span class="title">pairing</span>;</span><span class="comment">//MLC/TLC NANDs Flash 颗粒的配对策略</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_step_size; <span class="comment">//ecc步长</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_strength; <span class="comment">//ecc最大可纠正错误bit数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numeraseregions;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_erase_region_info</span> *<span class="title">eraseregions</span>;</span> <span class="comment">//擦除区域信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为Flash操作的回调函数，不同flash有不同实现</span></span><br><span class="line"><span class="keyword">int</span> (*_erase) (struct mtd_info *mtd, struct erase_info *instr);</span><br><span class="line"><span class="keyword">int</span> (*_point) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">void</span> **virt, <span class="keyword">resource_size_t</span> *phys);</span><br><span class="line"><span class="keyword">int</span> (*_unpoint) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*_get_unmapped_area)</span> <span class="params">(struct mtd_info *mtd,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*_read) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len,</span><br><span class="line">      <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len,</span><br><span class="line">       <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_panic_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">  struct mtd_oob_ops *ops);</span><br><span class="line"><span class="keyword">int</span> (*_write_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to,</span><br><span class="line">   struct mtd_oob_ops *ops);</span><br><span class="line"><span class="keyword">int</span> (*_get_fact_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_fact_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_get_user_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len,  <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_write_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_lock_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,  <span class="keyword">size_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_writev) (struct mtd_info *mtd, <span class="keyword">const</span> struct kvec *vecs, <span class="keyword">unsigned</span> <span class="keyword">long</span> count, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> *retlen);</span><br><span class="line"><span class="keyword">void</span> (*_sync) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">int</span> (*_lock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_unlock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_is_locked) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_block_isreserved) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_block_isbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_block_markbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_suspend) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_resume) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_reboot) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">int</span> (*_get_device) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_put_device) (struct mtd_info *mtd);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">reboot_notifier</span>;</span>  <span class="comment">//重启通知</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_ecc_stats</span> <span class="title">ecc_stats</span>;</span> <span class="comment">//ECC统计数据</span></span><br><span class="line"><span class="keyword">int</span> subpage_sft;</span><br><span class="line"><span class="keyword">void</span> *priv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">int</span> usecount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外一个比较重要的数据结构为mtd_partition，顾名思义，对一块flash进行分区:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//分区名称</span></span><br><span class="line"><span class="keyword">uint64_t</span> size;<span class="comment">//大小</span></span><br><span class="line"><span class="keyword">uint64_t</span> offset; <span class="comment">//在MTD设备的偏移</span></span><br><span class="line"><span class="keyword">uint32_t</span> mask_flags; <span class="comment">//MTD主设备的掩码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常每种类型的Flash芯片定义了这样一个数据结构，用于对Flash进行操作。可参考drivers/mtd/devices下相关使用（例如lpddr2_nvm.c）</p><p>mtdcore.h/mtdcore.c下定义了一系列使用MTD设备的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *__<span class="title">mtd_next_device</span>(<span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注册MTD设备</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注销</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *, <span class="keyword">const</span> struct mtd_partition *, <span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_partitions</span><span class="params">(struct mtd_info *)</span></span>; <span class="comment">//添加、删除MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span>; <span class="comment">//从MTD设备查找MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mtd_part_parser_cleanup</span><span class="params">(struct mtd_partitions *parts)</span></span>;<span class="comment">//清除parse_mtd_partitions得到的MTD分区数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">init_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">cleanup_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//注册、清除MTD字符设备</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_mtd_user</span> <span class="params">(struct mtd_notifier *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unregister_mtd_user</span> <span class="params">(struct mtd_notifier *old)</span> <span class="comment">//注册、去注册MTD使用者（当有MTD变动时通知）</span></span></span><br></pre></td></tr></table></figure><h3 id="MTD字符设备"><a href="#MTD字符设备" class="headerlink" title="MTD字符设备"></a>MTD字符设备</h3><p>MTD字符设备定义在mtdchar.c，其中定义了字符设备的相关操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mtd_fops</span> = &#123;</span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.llseek= mtdchar_lseek,</span><br><span class="line">.read= mtdchar_read,</span><br><span class="line">.write= mtdchar_write,</span><br><span class="line">.unlocked_ioctl= mtdchar_unlocked_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">.compat_ioctl= mtdchar_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">.open= mtdchar_open,</span><br><span class="line">.release= mtdchar_close,</span><br><span class="line">.mmap= mtdchar_mmap,</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">.get_unmapped_area = mtdchar_get_unmapped_area,</span><br><span class="line">.mmap_capabilities = mtdchar_mmap_capabilities,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MTD块设备"><a href="#MTD块设备" class="headerlink" title="MTD块设备"></a>MTD块设备</h3><p>MTD块设备定义在mtdblock.c/mtdblock_ro.c，定义了块设备相关操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"mtdblock"</span>,</span><br><span class="line">.major= MTD_BLOCK_MAJOR,</span><br><span class="line">.part_bits= <span class="number">0</span>,</span><br><span class="line">.blksize = <span class="number">512</span>,</span><br><span class="line">.open= mtdblock_open,</span><br><span class="line">.flush= mtdblock_flush,</span><br><span class="line">.release= mtdblock_release,</span><br><span class="line">.readsect= mtdblock_readsect,</span><br><span class="line">.writesect= mtdblock_writesect,</span><br><span class="line">.add_mtd= mtdblock_add_mtd,</span><br><span class="line">.remove_dev= mtdblock_remove_dev,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"mtdblock"</span>,</span><br><span class="line">.major= MTD_BLOCK_MAJOR,</span><br><span class="line">.part_bits= <span class="number">0</span>,</span><br><span class="line">.blksize = <span class="number">512</span>,</span><br><span class="line">.readsect= mtdblock_readsect,</span><br><span class="line">.writesect= mtdblock_writesect,</span><br><span class="line">.add_mtd= mtdblock_add_mtd,</span><br><span class="line">.remove_dev= mtdblock_remove_dev,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>在嵌入式设备，一个flash往往会被划分做不同的功能分区。例如，升级分区、文件系统分区、bootloader分区、配置分区、备份分区等等。代码树中的drivers/mtd/mtdpart.c实现了分区的相关操作：</p><p>以下全局变量定义了MTD分区的链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(mtd_partitions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(mtd_partitions_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>链表元素为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_part</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> <span class="title">mtd</span>;</span>      <span class="comment">//MTD信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">master</span>;</span>  <span class="comment">//MTD 设备指针</span></span><br><span class="line"><span class="keyword">uint64_t</span> offset;          <span class="comment">//主设备偏移</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相关操作为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mtd_part *<span class="title">allocate_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *part, <span class="keyword">int</span> partno, <span class="keyword">uint64_t</span> cur_offset)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分配分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtd_add_partition_attrs</span><span class="params">(struct mtd_part *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_add_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">long</span> <span class="keyword">long</span> offset, <span class="keyword">long</span> <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_del_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">int</span> partno)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加删除分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *parts, <span class="keyword">int</span> nbparts)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据分区表添加分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __<span class="title">register_mtd_parser</span><span class="params">(struct mtd_part_parser *p, struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister_mtd_parser</span><span class="params">(struct mtd_part_parser *p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//向内核注册和去注册回调函数用于MTD分区时执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>《<a href="http://www.linux-mtd.infradead.org/doc/general.html" target="_blank" rel="noopener">General MTD documentation</a>》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要MTD子系统&quot;&gt;&lt;a href=&quot;#为什么需要MTD子系统&quot; class=&quot;headerlink&quot; title=&quot;为什么需要MTD子系统&quot;&gt;&lt;/a&gt;为什么需要MTD子系统&lt;/h3&gt;&lt;p&gt;嵌入式系统使用Flash作为存储设备，Flash类别有Nand、Nor等。Flash的上层是文件系统。直觉上，系统中使用这些Flash时，我们需要为每种Flash编写驱动。同时在调用Flash的文件系统做接口对接。这样，每使用一种新的Flash类型甚至型号，都得修改文件系统的编码来做适配。显然，这会造成代码的爆炸，同时也不方便大家各司其职（例如：厂商A做Flash，添加一个新的Flash需要厂商A的驱动开发人员去改写所有文件系统的接口，这显然不现实）。&lt;/p&gt;&lt;p&gt;几乎所有的现代操作系统都不会允许以上事情的发生。通用的做法是，抽象出上下层对接的方式，厂商驱动开发人员只需要按照接口进行匹配节课。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux文件系统" scheme="http://l2h.site/categories/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="MTD" scheme="http://l2h.site/tags/MTD/"/>
    
  </entry>
  
  <entry>
    <title>教你关闭微信朋友圈的广告</title>
    <link href="http://l2h.site/2019/08/02/e6-95-99-e4-bd-a0-e5-85-b3-e9-97-ad-e5-be-ae-e4-bf-a1-e6-9c-8b-e5-8f-8b-e5-9c-88-e7-9a-84-e5-b9-bf-e5-91-8a/"/>
    <id>http://l2h.site/2019/08/02/e6-95-99-e4-bd-a0-e5-85-b3-e9-97-ad-e5-be-ae-e4-bf-a1-e6-9c-8b-e5-8f-8b-e5-9c-88-e7-9a-84-e5-b9-bf-e5-91-8a/</id>
    <published>2019-08-02T00:18:23.000Z</published>
    <updated>2019-10-05T13:55:11.759Z</updated>
    
    <content type="html"><![CDATA[<p>刷微信朋友圈时，是不是经常看到一些广告，有时还不小心点到上边？可以使用以下步骤关闭：</p><ul><li>电脑打开<a href="https://privacy.qq.com/advertisement.htm" target="_blank" rel="noopener">https://privacy.qq.com/advertisement.htm</a></li><li>在“二、如何管理您看到的广告”点击“<strong><em>管理</em></strong>”</li><li>此时会让您用微信扫码登录，按照提示登录即可</li><li>在“个性化服务设置”关闭“_<strong>根据您的信息展示广告</strong>_”即可</li></ul><p>注意，以上方法有效期半年，半年后需重新操作。不过不得不说微信对比其他社交软件满人性化，至少提供了可以关闭广告的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刷微信朋友圈时，是不是经常看到一些广告，有时还不小心点到上边？可以使用以下步骤关闭：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电脑打开&lt;a href=&quot;https://privacy.qq.com/advertisement.htm&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始爬草榴成人文学 (3) – 聚类和PCA</title>
    <link href="http://l2h.site/2019/07/19/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-3-e8-81-9a-e7-b1-bb-e5-92-8cpca/"/>
    <id>http://l2h.site/2019/07/19/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-3-e8-81-9a-e7-b1-bb-e5-92-8cpca/</id>
    <published>2019-07-19T07:58:11.000Z</published>
    <updated>2019-10-05T13:28:07.921Z</updated>
    
    <content type="html"><![CDATA[<p>本文继续上一章对爬到的数据按照文章标题进行分析。</p><p>首先使用结巴分词对爬到的标题进行分词，得到分词过后的带空格的标题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg <span class="comment">#引入词性标注接口 </span></span><br><span class="line"><span class="keyword">import</span> codecs,sys</span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_titles</span><span class="params">(df)</span>:</span></span><br><span class="line">    strs = <span class="string">' '</span>.join(jieba.cut(df[<span class="string">'lit_title'</span>&#125;,cut_all=<span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> strs</span><br><span class="line">  </span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = items.apply(<span class="keyword">lambda</span> r: split_titles(r), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>接着使用TF-IDF按照标题产生每个标题对应的TFIDF向量（因为字典并不大，可以用来作为该标题的嵌入，参考<a href="https://l2h.site/2019/07/19/word-embedding-model/">本博文章</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_extraction  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer  </span><br><span class="line"></span><br><span class="line">corpus = items[<span class="string">'split_title'</span>&#125;.tolist()<span class="comment">#将文章标题视作TF-IDF的语料</span></span><br><span class="line">vectorizer=CountVectorizer()<span class="comment">#该类会将文本中的词语转换为词频矩阵，矩阵元素a[i&#125;[j&#125; 表示j词在i类文本下的词频  </span></span><br><span class="line">transformer=TfidfTransformer()<span class="comment">#该类会统计每个词语的tf-idf权值  </span></span><br><span class="line">tfidf=transformer.fit_transform(vectorizer.fit_transform(corpus))<span class="comment">#第一个fit_transform是计算tf-idf，第二个fit_transform是将文本转为词频矩阵  </span></span><br><span class="line">weight=tfidf.toarray()<span class="comment">#将tf-idf矩阵抽取出来，元素a[i&#125;[j&#125;表示j词在i类文本中的tf-idf权重</span></span><br></pre></td></tr></table></figure><p>对TFIDF嵌入处理后的向量进行PCA降维（降至2维，方便绘图）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">new_df = pd.DataFrame(weight)</span><br><span class="line">cls=KMeans(n_clusters=<span class="number">2</span>).fit(new_df)</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">new_pca = pd.DataFrame(pca.fit_transform(new_df), columns=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.scatter(new_pca[<span class="string">'A'</span>&#125;, new_pca[<span class="string">'B'</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-19-%E4%B8%8B%E5%8D%883.49.09.png"></p><p>按标题聚类并PCA降维后的文章分布</p><p>上图可以看出，有两类文章偏离较远，我们可以看看是什么文章：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(new_pca[new_pca[<span class="string">'B'</span>&#125;&gt;<span class="number">0.6</span>&#125;.index):</span><br><span class="line">    new_items = items.reset_index()</span><br><span class="line">    print(new_items[<span class="string">'lit_title'</span>&#125;[i&#125;)</span><br></pre></td></tr></table></figure><p>打印这些一类文章的标题后我们发现，这是两篇文章被按照章节写成多篇了。</p><p>除此之外，还可以做什么？</p><ul><li>我们的语料库是文章标题本身，内容有限，分类其实是按照标题自身进行分类的。若我们的语料库是更大的词典，经过对大语料库进行训练后，人工提供分类“武侠类”、“现代类”等等，能否将相应文章准确分类？</li><li>能否抓取文章完整内容进行分词和聚类？避免教坏小朋友，留待大家讨论</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文继续上一章对爬到的数据按照文章标题进行分析。&lt;/p&gt;&lt;p&gt;首先使用结巴分词对爬到的标题进行分词，得到分词过后的带空格的标题&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba.analyse&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba.posseg &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pseg &lt;span class=&quot;comment&quot;&gt;#引入词性标注接口 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; codecs,sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;items[&lt;span class=&quot;string&quot;&gt;&#39;split_title&#39;&lt;/span&gt;&amp;#125; = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;split_titles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(df)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    strs = &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;.join(jieba.cut(df[&lt;span class=&quot;string&quot;&gt;&#39;lit_title&#39;&lt;/span&gt;&amp;#125;,cut_all=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; strs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;items[&lt;span class=&quot;string&quot;&gt;&#39;split_title&#39;&lt;/span&gt;&amp;#125; = items.apply(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; r: split_titles(r), axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://l2h.site/categories/Python/"/>
    
    
      <category term="草榴" scheme="http://l2h.site/tags/%E8%8D%89%E6%A6%B4/"/>
    
      <category term="PCA" scheme="http://l2h.site/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>Word Embedding（词嵌入）模型介绍</title>
    <link href="http://l2h.site/2019/07/19/word-embedding-model/"/>
    <id>http://l2h.site/2019/07/19/word-embedding-model/</id>
    <published>2019-07-19T02:08:13.000Z</published>
    <updated>2019-10-05T11:04:33.171Z</updated>
    
    <content type="html"><![CDATA[<p>词嵌入可以算是无监督机器学习最成功的应用之一。它不要求对数据标注，就可以从未标注预料里产生标注。单词嵌入可以从输入的字符产生量更小的向量标签，可以使得被使用到后续的其他学习任务中。</p><h2 id="词嵌入的概念"><a href="#词嵌入的概念" class="headerlink" title="词嵌入的概念"></a>词嵌入的概念</h2><p>简言之，词嵌入是指将文本转化为数字表示的方法。为什么需要词嵌入呢？</p><p>众所周知，许多机器学习算法，甚至几乎所有的深度学习算法，是无法直接处理字符串或者纯文本形式的输入。相反，他们需要数字作为各种任务的输入（例如分类、回归等）。不过，通常任务（例，网站评论中的情感分析）中大量的数据字段都是文本格式的，因此在需要学习前必须从这些文本输入中提取出数字表示的信息。因此，我们可以给词嵌入一个正式的定义：</p><blockquote><p>词嵌入方法，是将字典中的单词转化为向量的方法。</p></blockquote><a id="more"></a><p>例如，我们对如下句子做词嵌入：</p><blockquote><p>Word Embeddings are Word converted into numbers</p></blockquote><p>“词”指的是类似句子中的“Embedding”、“numbers”等</p><p>“字典”指的是句子中所有不重复单词的列表。所以，上述句子的词典是[‘Word’,’Embeddings’,’are’,’Converted’,’into’,’numbers’]</p><h2 id="词嵌入的不同方法"><a href="#词嵌入的不同方法" class="headerlink" title="词嵌入的不同方法"></a>词嵌入的不同方法</h2><p>我们当然可以使用本博客&lt;<a href="https://l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/">机器学习为什么使用独热(ONE-HOT ENCODING)编码</a>&gt;介绍的独热编码进行词嵌入，这是一种较为简单的处理方式。除此之外，还有许多不同的词嵌入方法。这些词嵌入方法可以大概分为如下两类：</p><ul><li>基于频率的嵌入（简称“词频嵌入”）</li><li>基于预测的嵌入</li></ul><p>我们本节会深入介绍这两类方法。</p><h3 id="词频嵌入"><a href="#词频嵌入" class="headerlink" title="词频嵌入"></a>词频嵌入</h3><p>现行流行的词频嵌入方法包括如下几类的嵌入向量：</p><ul><li>Count Vector</li><li>TF_IDF Vector</li><li>Co-Occurence Vector</li></ul><h4 id="Count-Vector"><a href="#Count-Vector" class="headerlink" title="Count Vector"></a>Count Vector</h4><p>考虑包括如下D个文档[latex]{d_1,d_2,…..,d_D}[/latex]的语料库及从C中提取的N个唯一单词。这N个唯一单词组成我们的字典，对应Count Vector矩阵M的大小为[latex]D*N[/latex]。矩阵M的每一行为[latex]d_i[/latex]文档中的单词频率。</p><p>举个简单的例子：</p><ul><li>[latex]d_1[/latex]: He is a lazy boy. She is also lazy</li><li>[latex]d_2[/latex]: Neeraj is a lazy person</li></ul><p>这两个文档形成字典：[‘He’,’She’,’lazy’,’boy’,’Neeraj’,’person’]，这里D=2，N=6，则该2*6矩阵M可作如下表示：</p><p>He</p><p>She</p><p>lazy</p><p>boy</p><p>Neeraj</p><p>person</p><p>[latex]d_1[/latex]</p><p>1</p><p>1</p><p>2</p><p>1</p><p>0</p><p>0</p><p>[latex]d_2[/latex]</p><p>0</p><p>0</p><p>1</p><p>0</p><p>1</p><p>1</p><p>这里，每一行代表的是文档集合中的一个文档，每一列代表的是单词。这样，矩阵中的一列就代表对应单词的词向量。例如，“lazy”的词向量为[2,1]。</p><p>很简单不是吗。不过这里有很多不同的形成矩阵M的变种方法。主要有两大类：</p><ul><li>字典的形成方式。以上为一个理想的例子，但一个现实问题往往有成千上万个文本作为语料。所以向量往往是成千上万列。而一种替代的表示方法是取其中10000个单词作为字典。</li><li>每个单词数量的表示方式。我们可以用单词出现的数量或者是单词是否出现来表示（一般是采用前者）。</li></ul><p>下图帮忙理解矩阵M的形式：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/count-vector.png"></p><h4 id="TF-IDF-Vector"><a href="#TF-IDF-Vector" class="headerlink" title="TF-IDF Vector"></a>TF-IDF Vector</h4><p>TF-IDF是另外一种基于词频的方法，但是计算词频时不仅仅考虑单个文档而是整个预料。这其中的原理是什么呢？</p><p>常用词‘is’、‘the’、‘a’等词在英文文档中通常出现的频率超过文档的主要词汇。例如，描述梅西的文档中会比其他文档更常出现‘Messi’一词。但是诸如‘the’一词在所有文档（当然是英文文档）都以很高频率出现。</p><p>理想状态下，我们更希望降低这些在所有文档中都会出现的词，相反提升其他文档相关性更高单词的频率。TF-IDF的工作原理，便是给这些常现词一些惩罚，赋予更低的权重。我们以如下两个文档范例看TF-IDF的工作方式：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/Tf-IDF.png"></p><p>与TF-IDF相关的定义有如下：</p><p>[latex]f()=TF =\frac{t单词出现在文档的次数}{文档中单词的总数量}[/latex]</p><p>因此 TF(This, Document1) = 1/8, TF(This, Document2) = 1/5</p><p>TF代表了单词对文档的“贡献”。即，与文档相关的单词应该出现频率更高。例，关于梅西的文档里，“梅西”单词出现的频率一定很高。</p><p>[latex]IDF=log(N/n)[/latex]</p><p>其中N代表文档的数量，n代表t单词有出现的文档的数量。因此IDF(This)=log(2/2)=0</p><p>因此如何解释IDF背后的原理？一般情况下，如果一个单词在所有的单词中都出现，那么很有可能这个单词与某一个特定的文档关联不大。如果单词只在一部分文档中出现，那么该单词与其所出现的文档关联的可能性就较大。我们可以计算上例中“Messi”一词的IDF为：</p><p>[latex]IDF(Messi)=log(2/1)=0.301[/latex]</p><p>现在，让我们来对比“This”和“Messi”对Document1的关联性。</p><blockquote><p>TF-IDF(This, Document1) = (1/8)*(0)=0</p><p>TF-IDF(This, Document2)=(1/5)*(0)=0</p><p>TF-IDF(Messi, Document1) = (4/8)*0.301 = 0.15  </p></blockquote><p>因此我们可以看到，对Document1，TF-IDF方法对“This”赋予较小的权重，远小于单词“Messi”。因此在整个语料库里，“Messi”对Document1是非常重要的单词。</p><h4 id="固定上下文窗口的Co-Occurence矩阵"><a href="#固定上下文窗口的Co-Occurence矩阵" class="headerlink" title="固定上下文窗口的Co-Occurence矩阵"></a>固定上下文窗口的Co-Occurence矩阵</h4><p>该方法主要思想为：类似的单词有一起出现的倾向，也有相同的上下文。例，苹果是一种水果，芒果也是一种水果。苹果和芒果倾向于有相同的上下文。即，水果。</p><p>我们先理解一下Co-Occurence和上下文窗口的含义，再具体介绍该方法。</p><p>Co-Occurence：给定语料，一对单词W1和W2的Co-Occurence指的是他们在一个上下文窗口一起出现的次数。</p><p>Context Window: 上下文窗口由一个数字和方向指定。让我们看如下例子：</p><p>Quick</p><p>Brown</p><p>Fox</p><p>Jump</p><p>Over</p><p>The</p><p>Lazy</p><p>Dog</p><p>紫色框字体是“Fox”的大小为2的上下文窗口，当计算co-occurence时，只有这些单词会算在内。同理，对单词“Over”的上下文窗口为：</p><p>Quick</p><p>Brown</p><p>Fox</p><p>Jump</p><p>Over</p><p>The</p><p>Lazy</p><p>Dog</p><p>因此，让我们使用一个范例语料来描述Co-Occurence矩阵。语料为： He is not lazy. He is intelligent. He is smart。则语料矩阵为：</p><p><strong>He</strong></p><p><strong>is</strong></p><p><strong>not</strong></p><p><strong>lazy</strong></p><p><strong>intelligent</strong></p><p><strong>smart</strong></p><p><strong>He</strong></p><p>0</p><p>4</p><p>2</p><p>1</p><p>2</p><p>1</p><p><strong>is</strong></p><p>4</p><p>0</p><p>1</p><p>2</p><p>2</p><p>1</p><p><strong>not</strong></p><p>2</p><p>1</p><p>0</p><p>1</p><p>0</p><p>0</p><p><strong>lazy</strong></p><p>1</p><p>2</p><p>1</p><p>0</p><p>0</p><p>0</p><p><strong>intelligent</strong></p><p>2</p><p>2</p><p>0</p><p>0</p><p>0</p><p>0</p><p><strong>smart</strong></p><p>1</p><p>1</p><p>0</p><p>0</p><p>0</p><p>0</p><p>上图中红色的单元表示”He”和”is”在2长度的上下文窗口的值为4，而“lazy”和“intelligent”的上下文窗口值为0。</p><p>但是真实的语料库往往有很多单词，如果构建像上表一样的N*N矩阵，对计算机处理起来复杂度过高。因此这个矩阵往往是N*M大小的矩阵，其中M为N的子集。即选择字典中的最重要的一些单词作为矩阵的其一维度。选择的方法有SVD，PCA分析等方法。</p><p>Co-Occurence矩阵的优势：</p><ul><li>保留了单词间的语义关系。例如“男人”和“女人”的距离近过“男人”和“苹果”</li><li>使用SVD作为其核心，比现有其他方法来输出更为精确的单词向量。</li><li>只需要做一次计算，之后可直接使用。</li></ul><p>Co-Occurence矩阵的缺点：</p><ul><li>使用大量的内存来存储Co-Occurence矩阵。当然，有一些现有的方法可以减轻该问题。</li></ul><h3 id="基于预测的嵌入"><a href="#基于预测的嵌入" class="headerlink" title="基于预测的嵌入"></a>基于预测的嵌入</h3><p>上述基于词频的计算单词嵌入方法的应用范围有限。直到word2vec这种基于预测的嵌入方法被提出并广泛应用到现有的各种场景中。而Wordvec并不是一个单独的算法，而是两种算法模型：CBOW（Continuous bag of words）和Skip-gram的组合。这两种方法均是浅神经网络，可以接受单词作为输入，同样使用单词作为输出，并映射为向量。下面分别进行介绍。</p><h4 id="CBOW-Continuous-Bag-of-words"><a href="#CBOW-Continuous-Bag-of-words" class="headerlink" title="CBOW(Continuous Bag of words)"></a>CBOW(Continuous Bag of words)</h4><p>CBOW模型工作的原理是根据输入的上下文来预测输出单词的概率。上下文可能为一个单词，或者是一组单词。为了描述方便，我们以一个单词作为输入来预测一个单词输出。</p><p>假设我们的语料为 C = “Hey, this is sample corpus using only one context word.”同时定义上下文窗口为1。输入语料可以以如下<a href="https://l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/">独热编码</a>方式呈现：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/cbow1-1024x289.png"></p><p>上述矩阵被送到一个三层神经网络来训练：包含输入层，隐层和输出层。其中输出层是一个softmax层，用来呈现输出层为某个单词的可能性。</p><p>下图呈现了CBOW的网络模型：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/Screenshot-from-2017-06-04-22-40-29.png"></p><p>上面架构的矩阵表示如下图：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/Screenshot-from-2017-06-04-22-19-202-1024x154.png"></p><p>计算方法如下：</p><ul><li>输入层和输出均为[1*V]的独热向量，V表示上述语料的字典大小</li><li>输入层和隐层，以及隐层和输出层分别有节点间权重矩阵大小为[V*N]，以及[N*V]。N为隐层神经元的数量，这里N=4</li><li>层与层之间没有激活函数</li><li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）</li><li>隐藏输出乘以隐层-输出层权重得到输出</li><li>根据输出使用逆传播算法来调整权重</li><li>隐藏-输出层权重被用作最后的词向量</li></ul><p>以上为一个输入的例子，假如是多个输入呢？</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/1-1.png"></p><p>上述为多个输入的神经网络架构，而下图为其矩阵表示：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/2-3-1024x150.png"></p><p>输入三个上下文单词预测一个目标单词。输入可以用三个独热向量表示。上述输入层有3个[1*V]向量作为输入，以及一个[1*V]向量作为输出。</p><p>以上计算方法与单输入的CBOW模型类似。只不过最终的输出为多个权重矩阵的算术平均值</p><p>上述算法与一般神经网络类似，主要差异在于：</p><ul><li>不同于计算算术平方误差作为损失，CBOW是计算最小化选中单词的负对数似然</li><li>CBOW每层神经元未使用激活函数做非线性化激活</li></ul><h4 id="Skip-–-Gram模型"><a href="#Skip-–-Gram模型" class="headerlink" title="Skip – Gram模型"></a>Skip – Gram模型</h4><p>Skip-gram模型与CBOW架构类似。不过其核心思想与CBOW正好相反，是给定单词预测期上下文。架构如图：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/3-1.png"></p><p>其矩阵形式架构如图：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/4-1024x223.png"></p><p>输入层大小为[1*V]，输入-隐层权重矩阵大小[V*N]，输出-权重矩阵[N*V]，输出层大小[1*V]</p><p>计算方法如下：</p><ul><li>上图红色输入为独热编码</li><li>中间桔黄色矩阵为隐层-输出层权重矩阵。</li><li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）， 桔黄色矩阵乘以 “隐层激活(Hidden Activation)” 得到蓝色矩阵</li><li>图右蓝色矩阵的每行使用Softmax进行计算得到图右绿色矩阵。</li><li>图右灰色矩阵为输入单词上下文的2两个单词的独热编码。使用绿色矩阵逐行减去灰色矩阵，得到误差向量</li><li>对所有的输入计算误差向量后求和得到损失，并进行逆传播优化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了基于词频和基于预测的两种嵌入方式，并对其中的常用模型进行了介绍。其中基于预测的嵌入方式是现行较为常用且有效的方式。其模型CBOW和Skip-Gram分别为使用上下文预测单词和使用单词预测上下文的两种不同模型，均为广泛使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;词嵌入可以算是无监督机器学习最成功的应用之一。它不要求对数据标注，就可以从未标注预料里产生标注。单词嵌入可以从输入的字符产生量更小的向量标签，可以使得被使用到后续的其他学习任务中。&lt;/p&gt;&lt;h2 id=&quot;词嵌入的概念&quot;&gt;&lt;a href=&quot;#词嵌入的概念&quot; class=&quot;headerlink&quot; title=&quot;词嵌入的概念&quot;&gt;&lt;/a&gt;词嵌入的概念&lt;/h2&gt;&lt;p&gt;简言之，词嵌入是指将文本转化为数字表示的方法。为什么需要词嵌入呢？&lt;/p&gt;&lt;p&gt;众所周知，许多机器学习算法，甚至几乎所有的深度学习算法，是无法直接处理字符串或者纯文本形式的输入。相反，他们需要数字作为各种任务的输入（例如分类、回归等）。不过，通常任务（例，网站评论中的情感分析）中大量的数据字段都是文本格式的，因此在需要学习前必须从这些文本输入中提取出数字表示的信息。因此，我们可以给词嵌入一个正式的定义：&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;词嵌入方法，是将字典中的单词转化为向量的方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Embedding" scheme="http://l2h.site/tags/Embedding/"/>
    
      <category term="嵌入" scheme="http://l2h.site/tags/%E5%B5%8C%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>机器学习术语归纳</title>
    <link href="http://l2h.site/2019/07/15/machine-learning-terms/"/>
    <id>http://l2h.site/2019/07/15/machine-learning-terms/</id>
    <published>2019-07-15T07:30:50.000Z</published>
    <updated>2019-10-06T00:40:27.512Z</updated>
    
    <content type="html"><![CDATA[<p>初学机器学习，往往容易淹没在浩瀚的属于中，本文归纳总结一下机器学习相关的术语，帮您更好理解神经网络</p><p>本文大部分翻译自<a href="http://www.wildml.com/deep-learning-glossary/" target="_blank" rel="noopener">wildml.com</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="Activation-Function（激活函数）"><a href="#Activation-Function（激活函数）" class="headerlink" title="Activation Function（激活函数）"></a>Activation Function（激活函数）</h4><p>使用非线性函数对训练模型中的输出（当然不限于最终输出）进行非线性化处理，这样神经网络可以学习到复杂的决策边界。常用的激活函数包括  <a href="https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank" rel="noopener">sigmoid</a>, <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" target="_blank" rel="noopener">tanh</a>, <a href="http://www.wildml.com/deep-learning-glossary/#relu" target="_blank" rel="noopener">ReLU (Rectified Linear Unit)</a>以及众多的变种.</p><h4 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h4><p>一直基于梯度下降的学习算法，可以自适应调整参数的学习速率。作为<br> <a href="http://www.wildml.com/deep-learning-glossary/#adagrad" target="_blank" rel="noopener">Adagrad</a> 的变种，对超参数敏感，容易造成学习速率过快下降。可以作为标准<br> <a href="http://www.wildml.com/deep-learning-glossary/#sgd" target="_blank" rel="noopener">SGD</a>替代。相关文献：</p><ul><li><p><a href="http://arxiv.org/abs/1212.5701" target="_blank" rel="noopener">ADADELTA: An Adaptive Learning Rate Method</a></p></li><li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p></li><li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p></li></ul><a id="more"></a><h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><p>Adagrad是一种自适应调整学习速率的算法，它会追踪梯度平方的变化，并对学习速率做自适应调整。对稀疏数据处理非常有效（会对不常更新的参数加快学习速率）。</p><ul><li><p><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a>  </p></li><li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p></li><li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p></li></ul><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><p>类似于 <a href="http://www.wildml.com/deep-learning-glossary/#rmsprop" target="_blank" rel="noopener">rmsprop</a> 的学习速率更新算法，更新主要采取即时的第一和第二时刻平均值。另外算法也包括了bias纠正单元，相关文献：</p><ul><li><a href="http://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam: A Method for Stochastic Optimization</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h4 id="Affine-Layer"><a href="#Affine-Layer" class="headerlink" title="Affine Layer"></a>Affine Layer</h4><p>神经网络的一种全连接层。Affine的含义是：每个上层的神经元链接当前层的神经元，即这是标准的神经网络层。Affine层通常会与 <a href="http://www.wildml.com/deep-learning-glossary/#cnn" target="_blank" rel="noopener">Convolutional Neural Networks</a> 或者 <a href="http://www.wildml.com/deep-learning-glossary/#rnn" target="_blank" rel="noopener">Recurrent Neural Networks</a>  一起使用，用于最终产生一个决策。函数形式通常是[latex]y=f(Wx+b)[/latex]。W,X,b分别是权值，输入和偏移向量。f通常为非线性函数</p><h4 id="Attention-Mechanism"><a href="#Attention-Mechanism" class="headerlink" title="Attention Mechanism"></a>Attention Mechanism</h4><p>Attention Mechanisms（注意力机制）灵感的源于人类视觉注意力特点 ：可以关注图片上的特定某个区域。注意力机制可以与自然语言处理或者图片识别结构一起工作，帮助神经网络学习到进行决策时该“注意”到哪些部分。相关文献：</p><ul><li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">Attention and Memory in Deep Learning and NLP</a></li></ul><h4 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h4><p>Alexnet是大优势赢得2012年ILSVRC竞赛使用的CNN架构，它使大家重新对使用_<strong>CNN网络</strong>_识别图片的产生兴趣。它由5层卷积层组成，部分卷积层后跟随池化层，最后的全连接层是1000路的softmax分类。Alexnet的介绍见<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a>.</p><h4 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h4><p>Autoencoder是一种神经网络模型，目标为通过网络中的一些“瓶颈”来预测网络的输入。通过引入瓶颈，强制网络学习到输入的低维度映射，从而有效地压缩输入维度。Autoencoders与PCA即一些其他降维技术有关，因为其本质上的非线性化特点，可以处理更复杂的映射。现有大量的autoencoder架构，包括<a href="http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf" target="_blank" rel="noopener">Denoising Autoencoders</a>,、<a href="http://arxiv.org/abs/1312.6114" target="_blank" rel="noopener">Variational Autoencoders</a>,或者<a href="http://arxiv.org/abs/1511.01432" target="_blank" rel="noopener">Sequence Autoencoders</a></p><h4 id="Average-Pooling"><a href="#Average-Pooling" class="headerlink" title="Average-Pooling"></a>Average-Pooling</h4><p>Average-Pooling是<strong><em>卷积神经网络</em></strong>识别图片采用的一种池化技术。工作原理为使用小于图片的窗口在图片特征上进行滑动，取得滑动位置上数值的平均值。从而降低数据特征的维度，同时有效保持数据的特征。与之类似的有最大值池化等方法。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="Backpropagation（逆传播，后向传播）"><a href="#Backpropagation（逆传播，后向传播）" class="headerlink" title="Backpropagation（逆传播，后向传播）"></a>Backpropagation（逆传播，后向传播）</h4><p>Backpropagation是有效计算神经网络梯度的方法。它通过微分运算，有效地将误差从输出位置传递到输入位置。它与上世纪70年代开始被使用。文献：</p><ul><li><a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="noopener">Calculus on Computational Graphs: Backpropagation</a></li></ul><h4 id="Backpropagation-Through-Time-BPTT"><a href="#Backpropagation-Through-Time-BPTT" class="headerlink" title="Backpropagation Through Time (BPTT)"></a>Backpropagation Through Time (BPTT)</h4><p>Backpropagation Through Time (<a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">paper</a>)是<strong><em>循环神经网络</em></strong>使用的逆传播算法。RNN的网络结构与传统的网络结构不同（每个阶段的神经单元共享参数），因此采用的逆传播也稍后差异。相关介绍见</p><ul><li><a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">Backpropagation Through Time: What It Does and How to Do It</a></li></ul><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><p>Batch Normalization是对神经网络层输入数据进行小批量分组使用的技术。使用小批量数据分组而非完整数据包可以加速训练速度。其在<strong><em>卷积神经网络</em></strong>或者_<strong>前向神经网络</strong>_使用中被证明非常有效，不过其目前在<strong>循环神经网络</strong>的使用中，效果有限</p><ul><li><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="noopener">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li><li><a href="http://arxiv.org/abs/1510.01378" target="_blank" rel="noopener">Batch Normalized Recurrent Neural Networks</a></li></ul><h4 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h4><p>双向循环神经网络是包含两个不同走向循环神经网络的网络。正向RNN从前向后读取输入序列，逆向RNN反之。两个RNN互相交叠，输出由这两个RNN的隐藏层的状态决定。双向RNN主要被用于自然语言处理问题（例，处理一个单词需要考虑单词前后的单词）。相关文献</p><ul><li><a href="http://www.di.ufpe.br/~fnj/RNA/bibliografia/BRNN.pdf" target="_blank" rel="noopener">Bidirectional Recurrent Neural Networks</a></li></ul><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h4><p><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a> 是 Berkeley Vision和Learning Center开发的深度学习框架，在处理视觉处理问题和CNN模型方面非常有用。</p><h4 id="Categorical-Cross-Entropy-Loss"><a href="#Categorical-Cross-Entropy-Loss" class="headerlink" title="Categorical Cross-Entropy Loss"></a>Categorical Cross-Entropy Loss</h4><p>分类交叉熵损失也被称作负对数似然，它是处理分类问题或者评估概率分布相似性的方法，特别是用于评估真值标签。其公式为[latex]L = -sum(y * log(y_prediction))[/latex]，其中y是真标签的概率分布（独热向量），[latex]y_prediction[/latex]是已预测标签的概率分布（一般使用softmax函数）</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>深度学习模型的输入数据可以有多个通道。例如，图片有RGB三个通道。因此图片可以被一个3维张量表示，分别是通道、高度和宽度。自然语言处理数据也有多个通道的概念。例如，数据有不同类别的_<strong>嵌入</strong>_表示。</p><h4 id="Convolutional-Neural-Network-CNN-ConvNet"><a href="#Convolutional-Neural-Network-CNN-ConvNet" class="headerlink" title="Convolutional Neural Network (CNN, ConvNet)"></a>Convolutional Neural Network (CNN, ConvNet)</h4><p>卷积神经网络使用卷积层从输入数据中提取有效特征。通常卷积神经网络由卷积、池化和全连接层组成。因为其在视觉处理任务的出色表现，卷积神经网络近年来一直非常流行。相关文章：</p><ul><li><a href="http://cs231n.github.io/" target="_blank" rel="noopener">Stanford CS231n class – Convolutional Neural Networks for Visual Recognition</a></li><li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">Understanding Convolutional Neural Networks for NLP</a></li></ul><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="Deep-Belief-Network-DBN"><a href="#Deep-Belief-Network-DBN" class="headerlink" title="Deep Belief Network (DBN)"></a>Deep Belief Network (DBN)</h4><p>深度信念网络，通过无监督的概率图模型来学习数据特征。DBN由多个隐层组成，前后隐层的神经元间相互连接。每层神经网络由受限玻尔兹曼机组成，分别进行训练层。</p><ul><li><a href="https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf" target="_blank" rel="noopener">A fast learning algorithm for deep belief nets</a></li></ul><h4 id="Deep-Dream"><a href="#Deep-Dream" class="headerlink" title="Deep Dream"></a>Deep Dream</h4><p>Google发明的一项技术，对深度卷积神经网络学习到的数据进行提取，并用于生成新图片、修改图片甚至给图片加入梦幻般的效果。相关资料：</p><ul><li><a href="https://github.com/google/deepdream" target="_blank" rel="noopener">Deep Dream on Github</a></li><li><a href="http://googleresearch.blogspot.ch/2015/06/inceptionism-going-deeper-into-neural.html" target="_blank" rel="noopener">Inceptionism: Going Deeper into Neural Networks</a></li></ul><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>随机失活是神经网络中用于避免过拟合的一种方法。最早被用于CNN网络，目前被广泛使用到其他神经网络中。相关资料：</p><ul><li><a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf" target="_blank" rel="noopener">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li><li><a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="noopener">Recurrent Neural Network Regularization</a></li></ul><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="Embedding（嵌入）"><a href="#Embedding（嵌入）" class="headerlink" title="Embedding（嵌入）"></a>Embedding（嵌入）</h4><p>嵌入指的是将单词或者句子映射成向量形式。比较流行的嵌入是单词嵌入（例如，<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a> 或 <a href="http://www.wildml.com/deep-learning-glossary/#glove" target="_blank" rel="noopener">GloVe</a>）。我们也可以嵌入句子、段落或者图片。比如说，通过映射图片和他们的文字描述到嵌入空间来减少他们之间的距离，来将图片和对应的标签进行关联。嵌入可以单独进行（如采用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>），也可以作为某个机器学习任务的一部分，例如情感分析。通常，神经网络的输入均是已经训练和优化过的数据。</p><h4 id="Exploding-Gradient-Problem（梯度爆炸问题）"><a href="#Exploding-Gradient-Problem（梯度爆炸问题）" class="headerlink" title="Exploding Gradient Problem（梯度爆炸问题）"></a>Exploding Gradient Problem（梯度爆炸问题）</h4><p>梯度爆炸问题与梯度消失问题正好相反。在深度神经网络中，逆传播过程可能会造成梯度爆炸从而产生数字溢出。一种解决梯度爆炸的方式是<a href="http://www.wildml.com/deep-learning-glossary/#gradient-clipping" target="_blank" rel="noopener">梯度修剪</a></p><ul><li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><h4 id="Fine-Tuning"><a href="#Fine-Tuning" class="headerlink" title="Fine-Tuning"></a>Fine-Tuning</h4><p>优化调节指的是从另外的任务得到优化过的初始化学习参数。例如，使用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>对自然语言处理任务的单词做预处理</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h4 id="Gradient-Clipping"><a href="#Gradient-Clipping" class="headerlink" title="Gradient Clipping"></a>Gradient Clipping</h4><p>梯度修剪主要用于避免深度神经网络（特别是循环神经网络）的梯度爆炸问题。进行梯度修剪的方式有多种，一种常用的方式是对梯度进行L2正则化（new_gradients = gradients * threshold / l2_norm(gradients)），参考：</p><ul><li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h4 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h4><p>Glove是一种用于单词嵌入的无监督学习算法。Glove向量和wordvec用途相同，但是表示有差异，这是由于用于嵌入方式不同</p><ul><li><a href="http://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="noopener">GloVe: Global Vectors for Word Representation</a></li></ul><h4 id="GoogleLeNet"><a href="#GoogleLeNet" class="headerlink" title="GoogleLeNet"></a>GoogleLeNet</h4><p>赢得2014年ILSVRC挑战的卷积神经网络框架。它使用记忆模块减少参数，同时提升对计算资源的有效利用率。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li></ul><h4 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h4><p>GRU( Gated Recurrent Unit ,门循环单元)是LSTM单元的简化形式，有更少的参数。类似于LSTM神经元，它使用门策略来避免梯度消失问题，使得RNN有效地学习长范围的关联。GRU内部有重置和更新门来决定旧的记忆是否需要保留还是要用当前时间的新值进行更新。参考：</p><ul><li><a href="http://arxiv.org/abs/1406.1078v3" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ul><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><h4 id="Highway-Layer"><a href="#Highway-Layer" class="headerlink" title="Highway Layer"></a>Highway Layer</h4><p>Highway Layer (<a href="http://arxiv.org/abs/1505.00387" target="_blank" rel="noopener">论文参考</a>)是使用门策略来控制神经网络层信息流的机制。叠加使用多个Highway层可以训练非常深层次的神经网络。Highway通过门函数选择输入的那个部分通过以及那个部分需要通过变化函数处理。Highway层的基本公式为[latex]T * h(x) + (1 - T) * x[/latex]，其中T是学习门函数，值位于0和1之间，h(x)是任意输入变化函数，x为输入数据。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><h4 id="ICML"><a href="#ICML" class="headerlink" title="ICML"></a>ICML</h4><p> <a href="http://icml.cc/" target="_blank" rel="noopener">International Conference for Machine Learning</a>, 机器学习领域顶级会议</p><h4 id="ILSVRC"><a href="#ILSVRC" class="headerlink" title="ILSVRC"></a>ILSVRC</h4><p><a href="http://www.image-net.org/challenges/LSVRC/" target="_blank" rel="noopener">ImageNet Large Scale Visual Recognition Challenge</a> 是图像识别分类领域最热门的竞赛。</p><h4 id="Inception-Module"><a href="#Inception-Module" class="headerlink" title="Inception Module"></a>Inception Module</h4><p>记忆单元用于卷积神经网络，提升网络的计算性能。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li></ul><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><h4 id="KerasK"><a href="#KerasK" class="headerlink" title="KerasK"></a>Keras<a href="http://keras.io/" target="_blank" rel="noopener">K</a></h4><p><a href="http://keras.io/" target="_blank" rel="noopener">Keras</a>是包含对深度学习进行深度封装的Python库。可以在<a href="http://www.wildml.com/deep-learning-glossary/#tensorflow" target="_blank" rel="noopener">TensorFlow</a>, <a href="http://www.wildml.com/deep-learning-glossary/#theano" target="_blank" rel="noopener">Theano</a>, 或 <a href="https://github.com/Microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>上层使用</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>长期短记忆网络主要用记忆门来避免RNN网络的梯度消失问题。利用LSTM单元计算RNN隐层，可以有效的传递梯度以及学习长范围关联。参考：</p><ul><li><a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Long Short-Term Memory</a></li><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ul><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><h4 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max-Pooling"></a>Max-Pooling</h4><p>最大池化是卷积神经网络的一种池化操作，池化时选择特征片段里的最大值，是卷积神经网络的常用池化操作。</p><h3 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h3><h4 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h4><p> MNIST 数据集 是最常使用的图像识别数据集了。基本上也是许多机器学习课程的范例数据集，更多介绍直接参考<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">官网</a>即可。</p><h4 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h4><p>Momentum是梯度下降算法的扩展，加速和优化了参数更新过程。实际使用中，加入momentum到梯度下降中，可以使深度网络得到更好的收敛 。参考：</p><ul><li><a href="http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html" target="_blank" rel="noopener">Learning representations by back-propagating errors</a></li></ul><h4 id="Multilayer-Perceptron-MLP"><a href="#Multilayer-Perceptron-MLP" class="headerlink" title="Multilayer Perceptron (MLP)"></a>Multilayer Perceptron (MLP)</h4><p>多层感知是一种多全连接层的前馈神经网络，使用<strong>激活函数</strong>处理数据做非线性化。MLP是多层神经网络或深度神经网络的最基本形式。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><h4 id="Negative-Log-Likelihood-NLL"><a href="#Negative-Log-Likelihood-NLL" class="headerlink" title="Negative Log Likelihood (NLL)"></a>Negative Log Likelihood (NLL)</h4><p>见 <a href="http://www.wildml.com/deep-learning-glossary/#ce-loss" target="_blank" rel="noopener">Categorical Cross Entropy Loss</a>.</p><h4 id="Neural-Machine-Translation-NMT"><a href="#Neural-Machine-Translation-NMT" class="headerlink" title="Neural Machine Translation (NMT)"></a>Neural Machine Translation (NMT)</h4><p>神经机器翻译指的是使用神经网络来翻译语言。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to sequence learning with neural networks</a></li><li><a href="http://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li></ul><h4 id="Neural-Turing-Machine-NTM"><a href="#Neural-Turing-Machine-NTM" class="headerlink" title="Neural Turing Machine (NTM)"></a>Neural Turing Machine (NTM)</h4><p>神经图灵机可以从范例中推导简单的算法。例如，NTM可以从输入输出范例中学习分类算法。在程序运行时神经图灵机通常可以学习到一些处理状态的记忆方法</p><ul><li><a href="http://arxiv.org/abs/1410.5401" target="_blank" rel="noopener">Neural Turing Machines</a></li></ul><h4 id="Nonlinearity（去线性化）"><a href="#Nonlinearity（去线性化）" class="headerlink" title="Nonlinearity（去线性化）"></a>Nonlinearity（去线性化）</h4><p>见<strong><em>激活函数</em></strong>.</p><h4 id="Noise-contrastive-estimation-NCE"><a href="#Noise-contrastive-estimation-NCE" class="headerlink" title="Noise-contrastive estimation (NCE)"></a>Noise-contrastive estimation (NCE)</h4><p>噪声对比评估是一种在大量词汇表输出常见用来训练分类器的损失抽样方法。通过计算所有可能分类的Softmax是代价昂贵的。而使用NCE，可以有效减少二分类问题的代价，而只需要通过从“真”分布和人工产生的噪声分布区来训练分类器。例如：</p><ul><li><a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf" target="_blank" rel="noopener">Noise-contrastive estimation: A new estimation principle for unnormalized statistical models</a></li><li><a href="http://papers.nips.cc/paper/5165-learning-word-embeddings-efficiently-with-noise-contrastive-estimation.pdf" target="_blank" rel="noopener">Learning word embeddings efficiently with noise-contrastive estimation</a></li></ul><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><h4 id="Pooling"><a href="#Pooling" class="headerlink" title="Pooling"></a>Pooling</h4><p>见<strong><em>最大池化</em></strong>和<strong><em>平均池化</em></strong>.</p><h4 id="Restricted-Boltzmann-Machine-RBN"><a href="#Restricted-Boltzmann-Machine-RBN" class="headerlink" title="Restricted Boltzmann Machine (RBN)"></a>Restricted Boltzmann Machine (RBN)</h4><p>受限玻尔兹曼机是深度信念网络使用的一种概率图模型。参考：</p><ul><li><a href="http://www-psych.stanford.edu/~jlm/papers/PDP/Volume%201/Chap6_PDP86.pdf" target="_blank" rel="noopener">Chapter 6: Information Processing in Dynamical Systems: Foundations of Harmony Theory</a></li><li><a href="http://image.diku.dk/igel/paper/AItRBM-proof.pdf" target="_blank" rel="noopener">An Introduction to Restricted Boltzmann Machines</a></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><h4 id="Recurrent-Neural-Network-RNN"><a href="#Recurrent-Neural-Network-RNN" class="headerlink" title="Recurrent Neural Network (RNN)"></a>Recurrent Neural Network (RNN)</h4><p>RNN代表循环神经网络，参考<a href="https://l2h.site/2019/07/13/%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9crnn%e7%ae%80%e5%8d%95%e7%90%86%e8%a7%a3/">本站文章</a>，或者：</p><ul><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></li></ul><h4 id="Recursive-Neural-Network"><a href="#Recursive-Neural-Network" class="headerlink" title="Recursive Neural Network"></a>Recursive Neural Network</h4><p>递归神经网络是循环神经网络的一种树状形式。详情参见：</p><ul><li><a href="http://ai.stanford.edu/~ang/papers/icml11-ParsingWithRecursiveNeuralNetworks.pdf" target="_blank" rel="noopener">Parsing Natural Scenes and Natural Language with Recursive Neural Networks</a></li></ul><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>线性整流函数（Rectified Linear Unit）是一种激活函数，深度学习中做去线性化处理。参考：</p><ul><li><a href="http://arxiv.org/abs/1502.01852" target="_blank" rel="noopener">Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification</a></li><li><a href="http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf" target="_blank" rel="noopener">Rectifier Nonlinearities Improve Neural Network Acoustic Models</a></li><li><a href="http://www.cs.toronto.edu/~fritz/absps/reluICML.pdf" target="_blank" rel="noopener">Rectified Linear Units Improve Restricted Boltzmann Machines</a></li></ul><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>深度残差网络（Deep Residual Network），赢得了ILSVRC 2015挑战赛，参考。</p><ul><li><a href="http://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">Deep Residual Learning for Image Recognition</a></li></ul><h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>RMSProp是一种基于梯度的优化算法。具体算法介绍见 ：</p><ul><li><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="noopener">Neural Networks for Machine Learning Lecture 6a</a></li><li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><h4 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h4><p>序列到序列模型读取血量作为输入，产生另外一个序列作为输出。与RNN不同的地方是，在产生输出之前，输入序列被一次性完整的输入。一般使用两个RNN实现，经典应用为机器翻译、编解码等，参考：</p><ul><li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></li></ul><h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><p>随机梯度下降是一种有效的梯度优化算法(<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="noopener">Wikipedia</a>)，其扩展算法包括 <strong>Momentum</strong>, <strong>Adagrad</strong>, <strong>rmsprop</strong>, <strong>Adadelta</strong> 以及 <strong>Adam</strong>.参考：</p><ul><li><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a></li><li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p><a href="https://baike.baidu.com/item/Softmax%E5%87%BD%E6%95%B0/22772270?fr=aladdin" target="_blank" rel="noopener">Softmax函数</a>，它能将一个含任意实数的K维向量 “压缩”到另一个K维实向量 中，使得每一个元素的范围都在 （0,1）之间，并且所有元素的和为1。主要作为处理分类问题的输出</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><h4 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a> 是Google提供的开源深度学习框架，可以对数据流图做计算，也封装了现行主要的神经网络运算。支持C++/Python.</p><h4 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h4><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a> 是一个封装深度神经网络算法的Python库</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><h4 id="Vanishing-Gradient-Problem"><a href="#Vanishing-Gradient-Problem" class="headerlink" title="Vanishing Gradient Problem"></a>Vanishing Gradient Problem</h4><p>梯度消失问题在深度神经网络学习中越来越常见，特别是循环神经网络，使用较小的梯度（位于0和1直接）。因为梯度在逆传播过程中会相乘，所以会在层与层传递间逐渐“消失”，导致长范围的关联消失。解决方法主要有使用<strong>ReLU</strong>激活，或者使用改进网络<strong><em>LSTM</em></strong>等。参考：</p><ul><li><a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p>VGG是赢得2014 ImageNet定位和分类跟踪问题第一二名的卷积神经网络。它由16到19个权重层和1*1或3*3的小卷积过滤器组成。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">Very Deep Convolutional Networks for Large-Scale Image Recognition</a></li></ul><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><p>word2vec用于单词嵌入的算法，参考：</p><ul><li><a href="http://arxiv.org/abs/1301.3781" target="_blank" rel="noopener">Efficient Estimation of Word Representations in Vector Space</a></li><li><a href="http://arxiv.org/abs/1310.4546" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality</a></li><li><a href="http://arxiv.org/abs/1411.2738" target="_blank" rel="noopener">word2vec Parameter Learning Explained</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学机器学习，往往容易淹没在浩瀚的属于中，本文归纳总结一下机器学习相关的术语，帮您更好理解神经网络&lt;/p&gt;&lt;p&gt;本文大部分翻译自&lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wildml.com&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;h4 id=&quot;Activation-Function（激活函数）&quot;&gt;&lt;a href=&quot;#Activation-Function（激活函数）&quot; class=&quot;headerlink&quot; title=&quot;Activation Function（激活函数）&quot;&gt;&lt;/a&gt;Activation Function（激活函数）&lt;/h4&gt;&lt;p&gt;使用非线性函数对训练模型中的输出（当然不限于最终输出）进行非线性化处理，这样神经网络可以学习到复杂的决策边界。常用的激活函数包括  &lt;a href=&quot;https://en.wikipedia.org/wiki/Sigmoid_function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sigmoid&lt;/a&gt;, &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicTangent.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tanh&lt;/a&gt;, &lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/#relu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReLU (Rectified Linear Unit)&lt;/a&gt;以及众多的变种.&lt;/p&gt;&lt;h4 id=&quot;Adadelta&quot;&gt;&lt;a href=&quot;#Adadelta&quot; class=&quot;headerlink&quot; title=&quot;Adadelta&quot;&gt;&lt;/a&gt;Adadelta&lt;/h4&gt;&lt;p&gt;一直基于梯度下降的学习算法，可以自适应调整参数的学习速率。作为&lt;br&gt; &lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/#adagrad&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Adagrad&lt;/a&gt; 的变种，对超参数敏感，容易造成学习速率过快下降。可以作为标准&lt;br&gt; &lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/#sgd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SGD&lt;/a&gt;替代。相关文献：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://arxiv.org/abs/1212.5701&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ADADELTA: An Adaptive Learning Rate Method&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://cs231n.github.io/neural-networks-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Stanford CS231n: Optimization Algorithms&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://sebastianruder.com/optimizing-gradient-descent/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;An overview of gradient descent optimization algorithms&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习几个要素</title>
    <link href="http://l2h.site/2019/07/14/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e5-87-a0-e4-b8-aa-e8-a6-81-e7-b4-a0/"/>
    <id>http://l2h.site/2019/07/14/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e5-87-a0-e4-b8-aa-e8-a6-81-e7-b4-a0/</id>
    <published>2019-07-14T14:41:18.000Z</published>
    <updated>2019-10-05T13:32:46.642Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为个人学习机器学习的一些入门级总结，若您是机器学习大神，可以直接留言点赞就好，嘿嘿。</p></blockquote><p>要实现一个机器学习功能，以下要素必不可少：</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是机器学习的灵魂，万物的基石，女娲造人的泥土。可以说，所有的机器学习都是围绕着数据来进行的。数据的作用：</p><ul><li>训练模型</li><li>验证模型有效性</li><li>分析模型</li></ul><p>Tensorflow在学习是，需要先为数据站位（Placeholder），主要作用是预留出学习过程中数据所需要占用的系统资源（内存）。例如下边代码tensorflow处理<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MINIST数据集</a>的预先占位：</p><p>mnist = read_data_sets(‘./‘,one_hot=True)</p><p>sess = tf.InteractiveSession()</p><a id="more"></a><p>x = tf.placeholder(“float”, [None, 784])<br>##省略与placeholder无关部分<br>for i in range(1000):<br>  batch_xs, batch_ys = mnist.train.next_batch(100)<br>  sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型表示采用什么样的模式训练数据，是神经网络（深度神经网络又分CNN、RNN等）、决策树算法、贝叶斯分类或者线性回归等等。这些模型在成熟的机器学习框架如Tensorflow或者Pytorch中都有实现（直接API调用）。例如下面例子是Tensorflow使用CNN训练的网络模型：</p><p>def cov2d(x, W):<br>  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=’SAME’)<br>def max_pool_2x2(x):<br>  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],<br>                        strides=[1, 2, 2, 1], padding=’SAME’)<br>#第一层卷积层<br>W_conv1 = weight_variable([5, 5, 1, 32])<br>b_conv1 = bias_variable([32])<br>x_image = tf.reshape(x, [-1,28,28,1])<br>h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)<br>h_pool1 = max_pool_2x2(h_conv1)</p><p>#第二层<br>W_conv2 = weight_variable([5, 5, 32, 64])<br>b_conv2 = bias_variable([64])<br>h_conv2= tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)<br>h_pool2 = max_pool_2x2(h_conv2)<br>#全连接层<br>W_fc1 = weight_variable([7 * 7 * 64, 1024])<br>b_fc1 = bias_variable([1024])<br>h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])<br>h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</p><p>#Dropout<br>keep_prob = tf.placeholder(“float”)<br>h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</p><p>#输出层<br>W_fc2 = weight_variable([1024, 10])<br>b_fc2 = bias_variable([10])</p><h3 id="优化算法（Optimizer）"><a href="#优化算法（Optimizer）" class="headerlink" title="优化算法（Optimizer）"></a>优化算法（Optimizer）</h3><p>优化算法体现的是学习的方法。例如一个学生，你是希望他死记硬背还是寓教于乐。当然，这个比喻可能不是很恰当。其实就是告诉整个训练模型，每一步采用什么算法更新权值。一些常用的优化算法如梯度下降法、Adam、SGD等等，在处理不同的数据时各有优劣。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>主要用于对输出进行非线性化处理。一些比较复杂的数据，不是简单一条线，或者多次方程就能拟合出来的。而模型的形式往往是(F=wT+b)这种线性方程，所以需要使用激活函数对输出做非线性化处理。一些常见的非线性化函数包括Sigmoid、tanh、RELU、Softmax等等</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上为机器学习的必不可少的构成单元，直接计算会涉及到非常多的公式推导。还好现成的机器学习框架帮大家封装好了以上实现，大家直接使用即可。说到底、回头看，机器学习其实就是数据工程。如何选择和预处理数据，并使用合理的模型进行训练，是机器学习成败的关键</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为个人学习机器学习的一些入门级总结，若您是机器学习大神，可以直接留言点赞就好，嘿嘿。&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;要实现一个机器学习功能，以下要素必不可少：&lt;/p&gt;&lt;h3 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h3&gt;&lt;p&gt;数据是机器学习的灵魂，万物的基石，女娲造人的泥土。可以说，所有的机器学习都是围绕着数据来进行的。数据的作用：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;训练模型&lt;/li&gt;
&lt;li&gt;验证模型有效性&lt;/li&gt;
&lt;li&gt;分析模型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Tensorflow在学习是，需要先为数据站位（Placeholder），主要作用是预留出学习过程中数据所需要占用的系统资源（内存）。例如下边代码tensorflow处理&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MINIST数据集&lt;/a&gt;的预先占位：&lt;/p&gt;&lt;p&gt;mnist = read_data_sets(‘./‘,one_hot=True)&lt;/p&gt;&lt;p&gt;sess = tf.InteractiveSession()&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://l2h.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环神经网络(RNN)简单理解</title>
    <link href="http://l2h.site/2019/07/13/e5-be-aa-e7-8e-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9crnn-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3/"/>
    <id>http://l2h.site/2019/07/13/e5-be-aa-e7-8e-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9crnn-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3/</id>
    <published>2019-07-13T08:55:32.000Z</published>
    <updated>2019-10-05T13:32:12.955Z</updated>
    
    <content type="html"><![CDATA[<p>循环神经网络(Recurrent Nerual Networks,简称RNN)近年来被业界视作处理序列数据以及做自然语言处理的灵丹妙药。其变种LSTM仍是当今最先进的数据处理模型之一。</p><p>理解RNN的工作原理，可帮助机器学习人员建立起有效的模型，更好地对数据进行有效的处理。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是RNN？首先让我们比较下传统前向神经网络与RNN的网络架构。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/Slide3-1.jpg"></p><p>左：传统神经网络架构 右：RNN架构</p><p>从图中可以看出，两者的差异主要在于网络是如何接收输入数据的。</p><ul><li><strong>传统前向神经网络</strong>：接受固定数量（所有数据量）的输入，进行定量的输出</li><li><strong>RNN</strong>：并非一次性使用所有的数据作为输入。反之，RNN有多个步骤，每个步骤将一部分数据序列化输入，经过一系列计算产生输出，直到所有的序列结束。</li></ul><a id="more"></a><p>这样讲可能仍然难以理解，下把这张序列化的动图可以辅助大家更好地理解。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/rnn-2.gif"></p><p>上图可以看到，每一步的计算会将上一步的计算输出对应的隐藏状态（Hidden State）作为一部分输入。由此看出，RNN对处理序列化相关的数据有天生的优势。</p><p>另外我们可以看到，RNN每一步的神经元计算，是采用相同的网络结构，这是RNN的另外一个重要特点。</p><h3 id="RNN网络的输入输出"><a href="#RNN网络的输入输出" class="headerlink" title="RNN网络的输入输出"></a>RNN网络的输入输出</h3><p>您可能会有疑问了：RNN输出来自于网络的哪一步？答案是，这取决于您要解决的问题是什么。例如，如果您用RNN做分类任务，那么您所需要的是从所有输入得到的最终输出；或者您要做单词预测任务，那么您会需要RNN网络序列的每一步都作出输出。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/karpathy.jpeg"></p><p>RNN输出数据多种形式</p><p>上图可以看出，RNN是非常灵活的，可以根据您的需要制定RNN的网络模型，喂给网络不同类型的输入，得到不同的输出。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/Slide6.jpg"></p><p>RNN多对一输出</p><p>上图示例中，所有时刻的输入，经过RNN网络，得到最后的输出结果。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/Slide7.jpg"></p><p>RNN多对多输出</p><p>而本示例中（上图），RNN序列的每一步输出都是我们需要的。除此之外，在例如翻译任务中，我们可能在会先接受多个输入序列，产生一个输出。再根据这个输出，最后产生多个输出序列。如下图英语翻译为法语的示例：</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/Slide8.jpg"></p><p>RNN 翻译示例</p><h3 id="RNN单元内部工作原理"><a href="#RNN单元内部工作原理" class="headerlink" title="RNN单元内部工作原理"></a>RNN单元内部工作原理</h3><p>到这里，您可能对RNN网络的框架有个基本了解。不过具体每一个RNN单元是如何工作的呢？</p><p>首先我们看传给RNN序列下一步的隐藏状态是如何产生的。有如下公式：</p><p>[latex] hidden_t = F(hidden_{t-1}, input_t) [/latex]</p><p>即当前步的隐藏状态，由上一步的隐藏状态加上这部分的输入经过函数F处理后产生。而第一步的隐藏状态，一般会在整个RNN初始化时人为设置为0。在最简单的RNN中，函数F一般为每个输入乘以对应的权重再用激活函数做非线性处理。激活函数一般有RELU、Sigmoid或tanh。下边公式为采用tanh作为激活函数：</p><p>[latex] hidden_t = tanh(W_{hiddent}*hidden_{t-1},W_{input} * input_t) [/latex]</p><p>而我们若需要在RNN单元每一步产生一个输出，那么这个输出一般由该步的隐藏单元做一个线性处理产生，例如：</p><p>[latex] output_t = W_{output}* hidden_t [/latex]</p><p>可以看出，上一个RNN单元的隐藏状态会被传递给下一个RNN单元，如此重复，直到运行到我们设定的停止条件。</p><p>当然，这是一个最简单的RNN网络形式。RNN网络还有许多相对复杂的变种（当然是为了针对性解决其他网络形式的一些问题而提出），例如LSTM、GRU等。</p><h3 id="RNN网络的训练"><a href="#RNN网络的训练" class="headerlink" title="RNN网络的训练"></a>RNN网络的训练</h3><p>RNN需要经过训练才能学习“”到更精准的拟合，从而得到我们想要的数据。</p><p><img alt data-src="https://blog.floydhub.com/content/images/2019/04/rnn-bptt-with-gradients.png"></p><p>RNN网络的权重更新</p><p>我们知道，神经网络通过学习和更新网络中的权重来接近最优解（见<a href="https://l2h.site/2019/02/02/machine-learning-neural-network-1/">本站文章</a>），RNN也不例外。通过一步步后传播算法来减小损失函数（Cost Function）最终得到最小值，RNN的后传播会需要前面RNN单元的数据，本文不作推导。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对循环神经网络(RNN)的基本框架和原理做了介绍。为方便理解，略去的数学推导。接下来，计划对RNN网络的变形LSTM、GRU等做介绍，并增加Tensorflow代码实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;循环神经网络(Recurrent Nerual Networks,简称RNN)近年来被业界视作处理序列数据以及做自然语言处理的灵丹妙药。其变种LSTM仍是当今最先进的数据处理模型之一。&lt;/p&gt;&lt;p&gt;理解RNN的工作原理，可帮助机器学习人员建立起有效的模型，更好地对数据进行有效的处理。&lt;/p&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;什么是RNN？首先让我们比较下传统前向神经网络与RNN的网络架构。&lt;/p&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://blog.floydhub.com/content/images/2019/04/Slide3-1.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;左：传统神经网络架构 右：RNN架构&lt;/p&gt;&lt;p&gt;从图中可以看出，两者的差异主要在于网络是如何接收输入数据的。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统前向神经网络&lt;/strong&gt;：接受固定数量（所有数据量）的输入，进行定量的输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RNN&lt;/strong&gt;：并非一次性使用所有的数据作为输入。反之，RNN有多个步骤，每个步骤将一部分数据序列化输入，经过一系列计算产生输出，直到所有的序列结束。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="RNN" scheme="http://l2h.site/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow在线资源汇总</title>
    <link href="http://l2h.site/2019/07/12/tensorflow-e5-9c-a8-e7-ba-bf-e8-b5-84-e6-ba-90-e6-b1-87-e6-80-bb/"/>
    <id>http://l2h.site/2019/07/12/tensorflow-e5-9c-a8-e7-ba-bf-e8-b5-84-e6-ba-90-e6-b1-87-e6-80-bb/</id>
    <published>2019-07-12T07:01:46.000Z</published>
    <updated>2019-10-06T00:30:58.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>Tensorflow API在线文档</p><p><a href="https://l2h.site/docs/tf-api/">https://l2h.site/docs/tf-api/﻿</a></p><p>TensorFlow官方文档中文版-v1.2</p><p><a href="https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ</a><br>提取码: qykw</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h3&gt;&lt;p&gt;Tensorflow API在线文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://l2h.site/docs/tf-api/&quot;&gt;http
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorflow" scheme="http://l2h.site/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络(CNN)的理解</title>
    <link href="http://l2h.site/2019/07/10/e5-8d-b7-e7-a7-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9ccnn-e7-9a-84-e7-90-86-e8-a7-a3/"/>
    <id>http://l2h.site/2019/07/10/e5-8d-b7-e7-a7-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9ccnn-e7-9a-84-e7-90-86-e8-a7-a3/</id>
    <published>2019-07-10T07:54:26.000Z</published>
    <updated>2019-10-05T13:28:04.804Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的目标是可以让计算机像人一样对事物进行理解，近些年深度学习得到了深入的发展，并有了广泛地产业化应用。一些常见的机器学习应用包括音视频识别、音视频分类、自然语言处理（NPL）等。</p><p>卷积神经网络（<strong>Convolutional Neural Network，CNN</strong>）最早提出于1979年，于今时在机器学习领域得到了广泛地应用，特别是在执行图片分类、识别等任务时，有着绝佳的效果。这是因为其在处理大量数据集时，计算复杂度上有着很大的优势。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/1.jpg"></p><p>神经网络的框架如图所示，它主要由以下几个部分组成：</p><ul><li>卷积</li><li>(ReLU)非线性化</li><li>池化</li><li>分类</li></ul><p>以上为卷积神经网络必不可少的部分，接下来我们试着对以上步骤分别进行理解（本文不涉及数学公式部分）。</p><a id="more"></a><h2 id="CNN深入理解"><a href="#CNN深入理解" class="headerlink" title="CNN深入理解"></a>CNN深入理解</h2><p>在对以上步骤进行介绍之前，我们先看一下计算机对视觉图像是如何进行理解的。如下图，对计算机来讲，每个图像都是以像素值作为元素的一组向量。每个像素点有RGB三种不同的<strong><em>通道</em></strong>，每个通道的取值为0-255的数字。而<strong>灰度</strong>图像，往往是只有一个通道的图像。为介绍的简便性，本文考虑只有一个通道的灰度图像。</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>CNN的名称即来自于“卷积”这一步骤。后者的主要目标是从输入中提取出可以用于分类的特征，同时保留像素间的空间距离。</p><p>考虑如下图左5<em>5像素大小的灰度图像，其中像素值为0或1（注意，这只是为了说明问题的一个特殊例子。灰度图像的像素点取值范围仍是0-255），以及图右的3</em>3矩阵</p><ul><li><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/2-2.png"></p><p>图像像素点</p></li><li><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/3.png"></p><p>过滤矩阵</p></li></ul><p>卷积操作即是类似如下动图对5<em>5图像和3</em>3矩阵的操作。橘色的矩阵在绿色原始图像像素矩阵上进行1像素大小滑动（Stride），每次对叠加元素间的积求和到新的向量矩阵元素（下图粉色矩阵）。</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/4.gif"></p><p>在卷积神经网络概念中，橘色的3*3矩阵被成为“过滤器”或“核函数”，而滑动过滤器并计算粉色向量的过程成为“特征卷积”或者“特征映射”。即，我们使用橘色的矩阵作为了原始图像的特征映射器。</p><p>很明显，从动图可以看出，对同一个图像不同的过滤矩阵值会产品不同的特征映射矩阵。考虑下图输入图像，我们可以从下表中看出，不同的过滤矩阵，如何影响到卷积的效果：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/5.png"></p><ul><li><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-10-%E4%B8%8B%E5%8D%882.21.42.png"></p><p>不同卷积操作对原始图的影响</p></li></ul><p>从下图也可以很清楚地看到卷积操作的过程及产生的结果（两个不同的过滤矩阵，过滤出了同一图像的不同特征矩阵。）：</p><p><img alt data-src="https://wx2.sinaimg.cn/mw690/62d92af0ly1g4uq9zl5isg20dc07k7wm.gif"></p><p>在实际应用，CNN的训练过程会对过滤矩阵中的参数值进行学习（当然在这之前“我们”要负责选择过滤矩阵的数量、矩阵的大小以及网络的结构）。我们选择越多的过滤矩阵，卷积过程便得到越多的图像特征，这样网络识别图像的效果也越好。</p><p>卷积层的大小主要由以下三个参数来决定（学习开始前“我们”需要决定这些参数）：</p><ul><li>深度(Depth): 即卷积矩阵的数量，例如上图狗狗相片我们采取的Edge Detection、Box Blur矩阵等。不同的矩阵维度表示不同的特征。</li><li>步长(Stride)：卷积矩阵每次在原始图像像素矩阵上的滑动距离。例，2代表每次滑动2个像素的宽度</li><li>0填充(Zero-Padding)：有时需要在原始数据边界填充0作为被卷积的对象。此时称为宽卷积（Wide Convolution），反之称为窄卷积（Narrow Convolution）。0填充的一个作用是，当移动步长超过1时，有时移动会超出数据边界，此时适当做一些0填充来让移动可以顺利进行</li></ul><h3 id="非线性化-ReLU"><a href="#非线性化-ReLU" class="headerlink" title="非线性化(ReLU)"></a>非线性化(ReLU)</h3><p>卷积操作之后，会对数据进行非线性化。ReLU为常用非线性化函数（Rectified Linear Uni），下图为该函数的坐标轴表示：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/screen-shot-2016-08-10-at-2-23-48-am.png"></p><p>ReLU对卷积化后的输出矩阵元素的负值进行处理，替换成0，主要目标便是将数据非线性化（因为真实世界中的数据往往也是非线性化的，而卷积是一个线性过程，需要对卷积后的数据做非线性处理）。</p><p>下图描述了ReLU操作对卷积操作后的特征矩阵的影响：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/screen-shot-2016-08-07-at-6-18-19-pm.png"></p><p>也有一些其他非线性函数如Sigmoid和tanh（最朴素的神经网络里也会用到这些函数），ReLU在实际使用中性能优于这两个函数。</p><h3 id="池化过程-Polling"><a href="#池化过程-Polling" class="headerlink" title="池化过程(Polling)"></a>池化过程(Polling)</h3><p>空间池化（也成为“子抽样”）可以对卷积和非线性化的特征矩阵做有效降维，同时保持了矩阵的重要信息。池化主要用到的函数包括最大值(Max)、平均值(Average)、求和(Sum)等。</p><p>以最大值池化为例，我们在特征矩阵上定义空间近邻（如下图，2*2的窗口），取出其中每个窗口的最大元素，重新组成特征矩阵。若该层卷积选择了多个过滤窗口，那么我们对每个卷积化特征矩阵做池化处理得到池化后的特征矩阵。</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/screen-shot-2016-08-10-at-3-38-39-am.png"></p><p>下图显示了图片被池化后的效果：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/screen-shot-2016-08-07-at-6-11-53-pm.png"></p><p>池化的主要作用就是有效降低输入数据的空间大小，节省计算量。其优势总结如下：</p><ul><li>不损失信息前提下，减小特征数据</li><li>减少神经网络需要计算的参数数量和计算量，因此可以有效抑制过拟合</li><li>减少输入数据因为转化变形等操作带来的影响</li></ul><p>以上过程介绍了构建CNN的基础成分卷积、非线性化和池化。这些过程的最终目的是得到与图片相关的、小数据量的、且能有效表达图像特征的特征矩阵。而这个特征矩阵的目的则是为最后一步，全连接神经网络的计算做准备，即我们提到的“分类”步骤</p><p>全连接神经网络的主要原理可以参考本站&lt;<a href="https://l2h.site/2019/02/02/machine-learning-neural-network-1/">神经网络和深度学习</a>&gt;一文的介绍，此处不做过多阐述。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结使用卷积神经网络进行机器学习的主要过程为：</p><ol><li>选择卷积神经网络的卷积、非线性化、池化等参数。同时初始化各个过程权值的初始值（可以随机化处理）</li><li>输入图像，并得到图片输出。</li><li>计算图片输出和实际输出的损失。</li><li>使用BP算法来优化神经网络，降低损失。</li></ol><p>欢迎留言探讨</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习的目标是可以让计算机像人一样对事物进行理解，近些年深度学习得到了深入的发展，并有了广泛地产业化应用。一些常见的机器学习应用包括音视频识别、音视频分类、自然语言处理（NPL）等。&lt;/p&gt;&lt;p&gt;卷积神经网络（&lt;strong&gt;Convolutional Neural Network，CNN&lt;/strong&gt;）最早提出于1979年，于今时在机器学习领域得到了广泛地应用，特别是在执行图片分类、识别等任务时，有着绝佳的效果。这是因为其在处理大量数据集时，计算复杂度上有着很大的优势。&lt;/p&gt;&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h2&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://l2h.site/wp-content/uploads/2019/07/1.jpg&quot;&gt;&lt;/p&gt;&lt;p&gt;神经网络的框架如图所示，它主要由以下几个部分组成：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;卷积&lt;/li&gt;
&lt;li&gt;(ReLU)非线性化&lt;/li&gt;
&lt;li&gt;池化&lt;/li&gt;
&lt;li&gt;分类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上为卷积神经网络必不可少的部分，接下来我们试着对以上步骤分别进行理解（本文不涉及数学公式部分）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CNN" scheme="http://l2h.site/tags/CNN/"/>
    
      <category term="机器学习" scheme="http://l2h.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>机器学习为什么使用独热(One-hot Encoding)编码</title>
    <link href="http://l2h.site/2019/07/09/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e7-8b-ac-e7-83-adone-hot-encoding-e7-bc-96-e7-a0-81/"/>
    <id>http://l2h.site/2019/07/09/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e4-b8-ba-e4-bb-80-e4-b9-88-e4-bd-bf-e7-94-a8-e7-8b-ac-e7-83-adone-hot-encoding-e7-bc-96-e7-a0-81/</id>
    <published>2019-07-09T04:19:29.000Z</published>
    <updated>2019-10-05T13:32:30.849Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看一些机器学习资料，发现使用起来真的蛮难。特征工程，如何有效地对数据进行预处理使得学习过程可以有效进行，是其中一个重要的难点。因为任何一个数据模型，都需要你准备相应的数据，错误的数据往往造成训练无法拟合（Fitting）。</p><p>在处理特征数据时，独热编码是一种常用的对离散特征进行处理的编码方式。本文根据个人理解，讨论为什么需要独热编码，它的好处是什么</p><h3 id="分类数据"><a href="#分类数据" class="headerlink" title="分类数据"></a>分类数据</h3><p>要了解独热编码啊，先理解什么是分类数据。顾名思义，这类数据往往不是直接以数值或向量化形式呈现的数据，其一般为具有实际含义的名称标签。例如，</p><ul><li>某一列数据表示为‘宠物’。相应的值有“狗”、“猫”、“兔子”等</li><li>表示“城市”的数据值有“北京”、“上海”、“成都”等</li></ul><a id="more"></a><p>这些数据值在特定机器学习训练中往往具有有限的类别。</p><h3 id="分类数据的问题"><a href="#分类数据的问题" class="headerlink" title="分类数据的问题"></a>分类数据的问题</h3><p>一些诸如“决策树”算法的学习方法，可以直接利用这些分类数据而无需进行数据转化。但更多的机器学习算法，需要进行的是数字或向量运算，没有办法直接处理这些文字型标签。这意味着，这些文字型的分类数据需要一定的转化，编程机器学习算法可以处理的数字型。</p><p><em>如何进行转化？</em></p><p>从程序员直觉上讲，很简单嘛，类似C语言的枚举类型，每种类型赋一个数字的值。例如，狗=1，猫=2，兔子=3，……</p><p>对一些学习场景，这种编码或许足够了。但是这种简单粗暴的编码方式，忽视掉了数据类别之间的距离。例如，狗和兔子之间的差异，并不会比狗和猫之间的差异大。但枚举方式进行编码，往往把这些特征值做了排序，与实际状况并不相符，最后导致学习的结果受到影响。</p><p>而解决这种问题的方式就是独热编码。某种特征有N种值，那么值就可以编码为1*N的向量，向量取值有N中，每种取值向量有且仅有一位为1。例如，狗=[1,0,0]，猫=[0,1,0]，兔子=[0,0,1]。可以看出，这三个值的距离是相等的。这就解决了枚举方式编码带来的问题。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>有许多现成的Python库可以进行独热编码:</p><ul><li><a href="https://www.tensorflow.org/api_docs/python/tf/one_hot" target="_blank" rel="noopener">One-Hot</a></li><li><a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank" rel="noopener">scikit-learn</a></li><li>…..</li></ul><p>我们所需要做的就是根据相应的文档使用对应的API即可？</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文大概介绍了独热编码的原理和使用场景。一般来说：</p><ul><li>为什么使用独热编码：大部分机器学习算法需要数字输入输出，而文字型标签无法被处理，枚举方式的编码可能错误地体现特征值间关系</li><li>如何使用：SKlearn或Numpy有现成的API可以使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看一些机器学习资料，发现使用起来真的蛮难。特征工程，如何有效地对数据进行预处理使得学习过程可以有效进行，是其中一个重要的难点。因为任何一个数据模型，都需要你准备相应的数据，错误的数据往往造成训练无法拟合（Fitting）。&lt;/p&gt;&lt;p&gt;在处理特征数据时，独热编码是一种常用的对离散特征进行处理的编码方式。本文根据个人理解，讨论为什么需要独热编码，它的好处是什么&lt;/p&gt;&lt;h3 id=&quot;分类数据&quot;&gt;&lt;a href=&quot;#分类数据&quot; class=&quot;headerlink&quot; title=&quot;分类数据&quot;&gt;&lt;/a&gt;分类数据&lt;/h3&gt;&lt;p&gt;要了解独热编码啊，先理解什么是分类数据。顾名思义，这类数据往往不是直接以数值或向量化形式呈现的数据，其一般为具有实际含义的名称标签。例如，&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;某一列数据表示为‘宠物’。相应的值有“狗”、“猫”、“兔子”等&lt;/li&gt;
&lt;li&gt;表示“城市”的数据值有“北京”、“上海”、“成都”等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://l2h.site/tags/python/"/>
    
      <category term="机器学习" scheme="http://l2h.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="独热编码" scheme="http://l2h.site/tags/%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>从零开始爬草榴成人文学 (2) – 分析</title>
    <link href="http://l2h.site/2019/07/08/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-2-e5-88-86-e6-9e-90/"/>
    <id>http://l2h.site/2019/07/08/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-2-e5-88-86-e6-9e-90/</id>
    <published>2019-07-08T07:48:52.000Z</published>
    <updated>2019-10-05T13:28:10.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://l2h.site/2019/07/08/scrapy%e7%88%ac%e5%8f%96%e8%8d%89%e6%a6%b4%e6%88%90%e4%ba%ba%e6%96%87%e5%ad%a6%e5%88%97%e8%a1%a8%e5%b9%b6%e5%88%86%e6%9e%90-1-%e7%88%ac%e5%8f%96/">前文</a>介绍了Scrapy爬取CL的成人文学区文章列表，本文介绍如何进行一些简单的数据分析。本文为分析过程中记录的交互式笔记。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文对X榴成人文学区抓取文章标题2000条信息进行分析.抓取的数据格式为：</p><ul><li>lit_type</li><li>lit_title</li><li>lit_url</li><li>lit_writer</li><li>lit_submit</li><li>lit_comments</li><li>lit_last_comments</li></ul><p>存储在MongoDB实验云存储上。 使用pymongo前安装</p><blockquote><p>pip install pymongo dnspython</p></blockquote><p>先导入必要的库，并对画图做一些基本的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> pandas.io.json <span class="keyword">import</span> json_normalize</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">15</span>, <span class="number">15</span>))  <span class="comment">#把plt默认的图片size调大一点</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>&#125; = [<span class="string">'SimSun'</span>&#125;</span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>&#125; = [<span class="string">'SimSun'</span>&#125;</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>&#125; = <span class="literal">False</span></span><br><span class="line">plt.rcParams[<span class="string">"figure.dpi"</span>&#125; = <span class="literal">False</span> <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>从数据库中读取所有的文章数据，并格式化到<a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas</a>的DataFrame里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client = pymongo.MongoClient(<span class="string">"mongodb+srv://用户名:密码@xxxx.mongodb.net/test?retryWrites=true&amp;w=majority"</span>)</span><br><span class="line">db = client[<span class="string">'t66y'</span>&#125;</span><br><span class="line">sheets = db[<span class="string">'main'</span>&#125;</span><br><span class="line">data = sheets.find()</span><br><span class="line">items = pd.DataFrame(list(data))</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>对数据做一些筛选处理，前20个数据应该是网站的公告，丢掉了事。另外将一些文本格式的日期形式做一下转换，转换为datetime格式，将评论数量转换为数字格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items.drop([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">21</span>)&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line">items[<span class="string">'lit_submit'</span>&#125; = pd.to_datetime(items[<span class="string">'lit_submit'</span>&#125;)</span><br><span class="line">items[<span class="string">'lit_comments'</span>&#125; = pd.to_numeric(items[<span class="string">'lit_comments'</span>&#125;)</span><br><span class="line">items[<span class="string">'lit_title'</span>&#125; = items[<span class="string">'lit_title'</span>&#125;.str.strip()</span><br></pre></td></tr></table></figure><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>做完以上数据转化后我们简单做一些分析，首先看一下哪个作者是最高产的？原理是“东京热”网友</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">items[<span class="string">'lit_writer'</span>&#125;.value_counts().head(<span class="number">20</span>).plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.09.png"></p><p>哪个时间段发布和评论小黄文最集中？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items[<span class="string">'lit_submit'</span>&#125;.value_counts().plot(kind=<span class="string">'line'</span>,subplots=<span class="literal">False</span>)</span><br><span class="line">items[<span class="string">'lit_last_comments'</span>&#125;.value_counts().plot(kind=<span class="string">'line'</span>,subplots=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.23.png"></p><p>评论看最热文章？可以看出连载文章是评率最多的，也许是因为作者用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items_title_idxed = items.set_index(<span class="string">'lit_title'</span>).sort_values(by=<span class="string">'lit_comments'</span>,ascending=<span class="literal">False</span>).head(<span class="number">10</span>)</span><br><span class="line">items_title_idxed[<span class="string">'lit_comments'</span>&#125;.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.50.png"></p><p>以上就是一些简单的分析。这些数据还可以做哪些分析？或许可以用自然语言处理的一些工具做如下处理</p><ul><li>哪类文章最受欢迎？</li><li>哪类文章创作率最高？</li><li>能不能自己创作小黄文？</li></ul><p>待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://l2h.site/2019/07/08/scrapy%e7%88%ac%e5%8f%96%e8%8d%89%e6%a6%b4%e6%88%90%e4%ba%ba%e6%96%87%e5%ad%a6%e5%88%97%e8%a1%a8%e5%b9%b6%e5%88%86%e6%9e%90-1-%e7%88%ac%e5%8f%96/&quot;&gt;前文&lt;/a&gt;介绍了Scrapy爬取CL的成人文学区文章列表，本文介绍如何进行一些简单的数据分析。本文为分析过程中记录的交互式笔记。&lt;/p&gt;&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;本文对X榴成人文学区抓取文章标题2000条信息进行分析.抓取的数据格式为：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;lit_type&lt;/li&gt;
&lt;li&gt;lit_title&lt;/li&gt;
&lt;li&gt;lit_url&lt;/li&gt;
&lt;li&gt;lit_writer&lt;/li&gt;
&lt;li&gt;lit_submit&lt;/li&gt;
&lt;li&gt;lit_comments&lt;/li&gt;
&lt;li&gt;lit_last_comments&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储在MongoDB实验云存储上。 使用pymongo前安装&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;pip install pymongo dnspython&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;先导入必要的库，并对画图做一些基本的配置&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; seaborn &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sns&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pymongo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pandas.io.json &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; json_normalize&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.style.use(&lt;span class=&quot;string&quot;&gt;&#39;ggplot&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rc(&lt;span class=&quot;string&quot;&gt;&#39;figure&#39;&lt;/span&gt;, figsize=(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;#把plt默认的图片size调大一点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;font.sans-serif&#39;&lt;/span&gt;&amp;#125; = [&lt;span class=&quot;string&quot;&gt;&#39;SimSun&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;font.serif&#39;&lt;/span&gt;&amp;#125; = [&lt;span class=&quot;string&quot;&gt;&#39;SimSun&#39;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;axes.unicode_minus&#39;&lt;/span&gt;&amp;#125; = &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&quot;figure.dpi&quot;&lt;/span&gt;&amp;#125; = &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 解决保存图像是负号&#39;-&#39;显示为方块的问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%matplotlib inline&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://l2h.site/categories/Python/"/>
    
    
      <category term="python" scheme="http://l2h.site/tags/python/"/>
    
      <category term="草榴" scheme="http://l2h.site/tags/%E8%8D%89%E6%A6%B4/"/>
    
  </entry>
  
  <entry>
    <title>从零开始爬草榴小黄文 (1) - 爬取</title>
    <link href="http://l2h.site/2019/07/08/scrapy-e7-88-ac-e5-8f-96-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-e5-88-97-e8-a1-a8-e5-b9-b6-e5-88-86-e6-9e-90-1-e7-88-ac-e5-8f-96/"/>
    <id>http://l2h.site/2019/07/08/scrapy-e7-88-ac-e5-8f-96-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-e5-88-97-e8-a1-a8-e5-b9-b6-e5-88-86-e6-9e-90-1-e7-88-ac-e5-8f-96/</id>
    <published>2019-07-08T02:31:07.000Z</published>
    <updated>2019-10-05T14:34:40.218Z</updated>
    
    <content type="html"><![CDATA[<p>最近想学习下Python。考虑到一点一点看教程学习过于枯燥，没有时间也没有学习动力。爬虫和Python最常用的功能就是爬虫和数据分析。不如就先从这两样着手做个简单的小项目，爬取一些网站数据，并做一些简单的分析。选定了爬取草榴成人文学的标题列表（不好内容）来作为学术目的。</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h3><p><a href="https://scrapy.org/" target="_blank" rel="noopener">Scrapy</a>是一个现行常用的爬虫框架，扩展性强，拥有强大的爬取和分析能力，安装起来也蛮简单。</p><blockquote><p>** pip install scrapy **  </p></blockquote><p>当然安装使用起来也有很多的坑会踩，比如说没有安装Twisted、lxml等，这在Python下都不是问题，一个_pip install_搞定。</p><p>另外CentOS服务器会碰到运行时找不到__sqlite3模块的错误。靠如下方法搞定：</p><a id="more"></a><ol><li>_sudo yum install sqlite-deve_l</li><li>重新编译python3.6：<em>./configure –enable-loadable-sqlite-extensions –with-ssl;make;sudo make install</em></li></ol><p>P.S. 简单的功能，其实爬虫完全可以利用现行的HTTP Request类来写也不复杂。个人只是图省事儿用了Scrapy</p><h3 id="安装Pymongo"><a href="#安装Pymongo" class="headerlink" title="安装Pymongo"></a>安装Pymongo</h3><p>原本以为数据量很大，就打算直接使用数据库来存储爬取到的数据，而Python常用的数据库为Mongo，使用需要安装Pymongo（后来发现其实只有2000多条数据，直接存文本就可以的）。</p><blockquote><p>pip install Pymongo</p></blockquote><p>这里说一下，数据库我直接使用的是<a href="https://cloud.mongodb.com" target="_blank" rel="noopener">Pymongo官方</a>提供的实验数据库，有500M空间，可以远程使用.</p><p>Python使用Pymongo的文档，可以参考<a href="http://api.mongodb.com/python/current/" target="_blank" rel="noopener">pymongo 文档</a></p><h2 id="使用Scrapy爬取"><a href="#使用Scrapy爬取" class="headerlink" title="使用Scrapy爬取"></a>使用Scrapy爬取</h2><p>先执行s_crapy startproject 爬虫项目名_来创建项目，得到如下目录结构</p><p>t66y<br>    ├── proxy.py<br>    ├── scrapy.cfg<br>    └── t66y<br>        ├── <strong>init</strong>.py<br>        ├── items.py<br>        ├── middlewares.py<br>        ├── pipelines.py<br>        ├── settings.py<br>        └── spiders<br>            └── <strong>init</strong>.py</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们在spiders下建立t66y.py，直接上代码了（为避免教坏小朋友，删掉网址）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> t66y.items <span class="keyword">import</span> T66YItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">t66yLitSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"t66yLit"</span> </span><br><span class="line">    allowed_domains = [<span class="string">'草榴域名'</span>]</span><br><span class="line">    <span class="comment">#start_urls为开始抓取的网址</span></span><br><span class="line">    start_urls = [<span class="string">'http://草榴域名/thread0806.php?fid=20&amp;search=&amp;page=&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">22</span>)]</span><br><span class="line">    <span class="comment">#对抓取到的网页进行Xpath解析，得到数据。注意每一个T66YItem对象对应一条pymongo中的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = T66YItem()</span><br><span class="line">        lits = response.xpath(<span class="string">'//tr[@class="tr3 t_one tac"]'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> lit <span class="keyword">in</span> lits:</span><br><span class="line">            item[<span class="string">'lit_type'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]/text()[1]'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_title'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]//h3/a/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_title'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_title'</span>] = item[<span class="string">'lit_title'</span>][<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_url'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]//h3/a/@href'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_writer'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a/text()'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_submit'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a//following-sibling::*[1]/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_submit'</span>]) == <span class="number">1</span>:</span><br><span class="line">                lit_submit = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a//following-sibling::*[1]'</span>)</span><br><span class="line">                item[<span class="string">'lit_submit'</span>] = lit_submit.xpath(<span class="string">'string(.)'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_comments'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[3]/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_comments'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_comments'</span>] = item[<span class="string">'lit_comments'</span>][<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'lit_last_comments'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[4]/a/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_last_comments'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_last_comments'</span>] = item[<span class="string">'lit_last_comments'</span>][<span class="number">0</span>]</span><br><span class="line">            self.log(<span class="string">"[%s],[%s],[%s],[%s],[%s],[%s],[%s]"</span> % (item[<span class="string">'lit_type'</span>],item[<span class="string">'lit_title'</span>],item[<span class="string">'lit_url'</span>],item[<span class="string">'lit_writer'</span>],item[<span class="string">'lit_submit'</span>],item[<span class="string">'lit_comments'</span>],item[<span class="string">'lit_last_comments'</span>]))</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>T66YItem定义在items.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://doc.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T66YItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    lit_type = scrapy.Field()</span><br><span class="line">    lit_title = scrapy.Field()</span><br><span class="line">    lit_url = scrapy.Field()</span><br><span class="line">    lit_writer = scrapy.Field()</span><br><span class="line">    lit_submit = scrapy.Field()</span><br><span class="line">    lit_comments = scrapy.Field()</span><br><span class="line">    lit_last_comments = scrapy.Field()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>pipeline.py负责抓取后的mongodb存储</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> scrapy.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T66YPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        host = settings[<span class="string">'MONGODB_HOST'</span>]</span><br><span class="line">        user = settings[<span class="string">'MONGODB_USER'</span>]</span><br><span class="line">        passwd = settings[<span class="string">'MONGODB_PASSWD'</span>]</span><br><span class="line">        dbname = settings[<span class="string">'MONGODB_DBNAME'</span>]</span><br><span class="line">        sheetname = settings[<span class="string">'MONGODB_SHEET'</span>]</span><br><span class="line">        client = pymongo.MongoClient(<span class="string">"mongodb+srv://&#123;0&#125;:&#123;1&#125;@&#123;2&#125;/test?retryWrites=true&amp;w=majority"</span>.format(user,passwd,host))</span><br><span class="line">        </span><br><span class="line">        mydb = client[dbname] </span><br><span class="line">        self.post = mydb[sheetname]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        data = dict(item)</span><br><span class="line">        self.post.insert(data)<span class="comment">#这行就是存储mongo数据了</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>若要抓取时同步保存，需要对setting.py进行配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOT_NAME = <span class="string">'t66y'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'t66y.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'t66y.spiders'</span></span><br><span class="line"><span class="comment">#看到这些配置和t66y.py里的关联了吗。对应配置名就是setting['xxxx']</span></span><br><span class="line">MONGODB_USER = <span class="string">'***'</span></span><br><span class="line">MONGODB_PASSWD = <span class="string">'***'</span></span><br><span class="line">MONGODB_DBNAME = <span class="string">'***'</span></span><br><span class="line">MONGODB_SHEET = <span class="string">'***'</span></span><br><span class="line">MONGODB_HOST = <span class="string">'***.mongodb.net'</span></span><br><span class="line"></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"><span class="comment">#需要定义一个延迟时间，否则会被服务器当成DDOS攻击</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">5</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">   <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">   <span class="string">'Accept-Language'</span>: <span class="string">'en'</span>,</span><br><span class="line">   <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#pipeline的名字要和pipeline.py里定义的类名相同</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'t66y.pipelines.T66YPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到创建工程的时候还有一个middleware.py文件生成，从名字看它应该是一种中间件对吧。其实一般大家用它来更换代理IP（有些网站会查询爬虫的ip，过于频繁的读取会被当成不合规行为，并进行拦截），更换代理IP的代码一般放在此处。当然当碰到网站返回错误要做一些处理的时候，也通常会在这里实现相应代码。好在CL并没有麻烦到需要更换代理IP。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>直接看在mongoDB存储的内容。可以看到爬取过程中插入操作增多了，右边是爬取到的数据，文章名称过于暴露就不再显示。</p><ul><li><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/1-1024x358.png"></p></li><li><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/07/2-1024x498.png"></p></li></ul><p>下一章我们介绍：</p><p>Jupyter+Pandas+Pyplot进行简单的数据分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想学习下Python。考虑到一点一点看教程学习过于枯燥，没有时间也没有学习动力。爬虫和Python最常用的功能就是爬虫和数据分析。不如就先从这两样着手做个简单的小项目，爬取一些网站数据，并做一些简单的分析。选定了爬取草榴成人文学的标题列表（不好内容）来作为学术目的。&lt;/p&gt;&lt;h2 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h2&gt;&lt;h3 id=&quot;安装Scrapy&quot;&gt;&lt;a href=&quot;#安装Scrapy&quot; class=&quot;headerlink&quot; title=&quot;安装Scrapy&quot;&gt;&lt;/a&gt;安装Scrapy&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://scrapy.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Scrapy&lt;/a&gt;是一个现行常用的爬虫框架，扩展性强，拥有强大的爬取和分析能力，安装起来也蛮简单。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;** pip install scrapy **  &lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;当然安装使用起来也有很多的坑会踩，比如说没有安装Twisted、lxml等，这在Python下都不是问题，一个_pip install_搞定。&lt;/p&gt;&lt;p&gt;另外CentOS服务器会碰到运行时找不到__sqlite3模块的错误。靠如下方法搞定：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://l2h.site/categories/Python/"/>
    
    
      <category term="python" scheme="http://l2h.site/tags/python/"/>
    
      <category term="草榴" scheme="http://l2h.site/tags/%E8%8D%89%E6%A6%B4/"/>
    
      <category term="Scrapy" scheme="http://l2h.site/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow ImportError：DLL加载失败，错误代码为-1073741795 问题解决</title>
    <link href="http://l2h.site/2019/06/28/tensorflow-importerror-ef-bc-9adll-e5-8a-a0-e8-bd-bd-e5-a4-b1-e8-b4-a5-ef-bc-8c-e9-94-99-e8-af-af-e4-bb-a3-e7-a0-81-e4-b8-ba-1073741795-e9-97-ae-e9-a2-98-e8-a7-a3-e5-86-b3/"/>
    <id>http://l2h.site/2019/06/28/tensorflow-importerror-ef-bc-9adll-e5-8a-a0-e8-bd-bd-e5-a4-b1-e8-b4-a5-ef-bc-8c-e9-94-99-e8-af-af-e4-bb-a3-e7-a0-81-e4-b8-ba-1073741795-e9-97-ae-e9-a2-98-e8-a7-a3-e5-86-b3/</id>
    <published>2019-06-28T04:59:01.000Z</published>
    <updated>2019-10-05T14:35:41.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>赛扬J3160 CPU，使用pip install tensorflow安装好tensorflow，运行如下代码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><p>得到错误如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ImportError: Traceback (most recent call last):</span><br><span class="line">  File "C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>Administrator.USER-20190627CO<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Local<span class="symbol">\\</span>Programs<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python37<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages<span class="symbol">\\</span>tensorflow<span class="symbol">\\</span>python<span class="symbol">\\</span>pywrap_tensorflow.py", line 58, in &lt;module&gt;</span><br><span class="line">    from tensorflow.python.pywrap<span class="symbol">\_</span>tensorflow<span class="symbol">\_</span>internal import *</span><br><span class="line">  File "C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>Administrator.USER-20190627CO<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Local<span class="symbol">\\</span>Programs<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python37<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages<span class="symbol">\\</span>tensorflow<span class="symbol">\\</span>python<span class="symbol">\\</span>pywrap<span class="symbol">\_</span>tensorflow<span class="symbol">\_</span>internal.py", line 28, in &lt;module&gt;</span><br><span class="line">    <span class="symbol">\_</span>pywrap<span class="symbol">\_</span>tensorflow<span class="symbol">\_</span>internal = swig<span class="symbol">\_</span>import_helper()</span><br><span class="line">  File "C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>Administrator.USER-20190627CO<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Local<span class="symbol">\\</span>Programs<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python37<span class="symbol">\\</span>lib<span class="symbol">\\</span>site-packages<span class="symbol">\\</span>tensorflow<span class="symbol">\\</span>python<span class="symbol">\\</span>pywrap<span class="symbol">\_</span>tensorflow<span class="symbol">\_</span>internal.py", line 24, in swig<span class="symbol">\_</span>import<span class="symbol">\_</span>helper</span><br><span class="line">    <span class="symbol">\_</span>mod = imp.load<span class="symbol">\_</span>module('<span class="symbol">\_</span>pywrap<span class="symbol">\_</span>tensorflow_internal', fp, pathname, description)</span><br><span class="line">  File "C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>Administrator.USER-20190627CO<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Local<span class="symbol">\\</span>Programs<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python37<span class="symbol">\\</span>lib<span class="symbol">\\</span>imp.py", line 242, in load_module</span><br><span class="line">    return load_dynamic(name, filename, file)</span><br><span class="line">  File "C:<span class="symbol">\\</span>Users<span class="symbol">\\</span>Administrator.USER-20190627CO<span class="symbol">\\</span>AppData<span class="symbol">\\</span>Local<span class="symbol">\\</span>Programs<span class="symbol">\\</span>Python<span class="symbol">\\</span>Python37<span class="symbol">\\</span>lib<span class="symbol">\\</span>imp.py", line 342, in load_dynamic</span><br><span class="line">    return _load(spec)</span><br><span class="line">ImportError: DLL load failed with error code -1073741795</span><br></pre></td></tr></table></figure><a id="more"></a><p>找到<a href="https://github.com/tensorflow/tensorflow/issues/17386" target="_blank" rel="noopener">github上</a>有人碰到类似错误，原因是CPU缺少 AVX 指令集支持（看来是赛扬处理器稍低端了）。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解法也很简单，依次执行如下步骤:</p><ul><li>pip uninstall tensorflow</li><li>到<a href="https://github.com/fo40225/tensorflow-windows-wheel" target="_blank" rel="noopener">github</a>下不支持AVX指令集的tensorflow轮子。一般选最新版的tensorflow；注意您的python版本，若是3.7，就选1.x.0/py37/CPU/sse2下的wheel</li><li>下好到本地后执行“pip install 刚刚下好wheel的本地路径”</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;赛扬J3160 CPU，使用pip install tensorflow安装好tensorflow，运行如下代码，&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; tf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; math&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; tensorflow.python.data &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Dataset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; matplotlib &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; seaborn &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; sns&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;得到错误如下：&lt;/p&gt;&lt;figure class=&quot;highlight taggerscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ImportError: Traceback (most recent call last):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &quot;C:&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Users&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Administrator.USER-20190627CO&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;AppData&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Local&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Programs&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python37&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;lib&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;site-packages&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;pywrap_tensorflow.py&quot;, line 58, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    from tensorflow.python.pywrap&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;internal import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &quot;C:&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Users&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Administrator.USER-20190627CO&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;AppData&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Local&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Programs&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python37&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;lib&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;site-packages&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;pywrap&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;internal.py&quot;, line 28, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;pywrap&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;internal = swig&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;import_helper()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &quot;C:&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Users&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Administrator.USER-20190627CO&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;AppData&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Local&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Programs&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python37&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;lib&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;site-packages&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;pywrap&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;tensorflow&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;internal.py&quot;, line 24, in swig&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;import&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;helper&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;mod = imp.load&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;module(&#39;&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;pywrap&lt;span class=&quot;symbol&quot;&gt;\_&lt;/span&gt;tensorflow_internal&#39;, fp, pathname, description)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &quot;C:&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Users&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Administrator.USER-20190627CO&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;AppData&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Local&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Programs&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python37&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;lib&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;imp.py&quot;, line 242, in load_module&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return load_dynamic(name, filename, file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  File &quot;C:&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Users&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Administrator.USER-20190627CO&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;AppData&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Local&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Programs&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;Python37&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;lib&lt;span class=&quot;symbol&quot;&gt;\\&lt;/span&gt;imp.py&quot;, line 342, in load_dynamic&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _load(spec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ImportError: DLL load failed with error code -1073741795&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorflow" scheme="http://l2h.site/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>L&amp;H的半北疆8日游</title>
    <link href="http://l2h.site/2019/06/18/lh-xinjiang-1/"/>
    <id>http://l2h.site/2019/06/18/lh-xinjiang-1/</id>
    <published>2019-06-18T02:12:06.000Z</published>
    <updated>2019-10-06T00:23:14.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想游 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 已久，一直因为某些众所周知的因素不敢出行。终于，趁着这段空档期，恰在X程订到了1500一人的端午开始的8天7晚 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10757.html" target="_blank" rel="noopener">北疆</a> 游，便开始这场说走就走的旅行。后来根据一路的住宿游玩等内容算起来，这段行程对旅行社一定是亏本赚吆喝买卖。</p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>动身：<br>我们是从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> 出发，由于想（机）多玩（票）地方（贵），真正动身先坐火车卧铺到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> ，从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a>转机到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 。  </p><p>紧接着随团行程如下图：</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/565857780.html" target="_blank" rel="noopener"><img alt data-src="http://n1-q.mafengwo.net/s14/M00/87/51/wKgE2l0HT3iAaYxoAAwnlE5wL2E379.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>以下为行车线路：</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/565917107.html" target="_blank" rel="noopener"><img alt data-src="http://n3-q.mafengwo.net/s14/M00/8B/DE/wKgE2l0HUMKAPqHkAAcQr2y5lm8180.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>返程：最后一日回程从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 直飞 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13663.html" target="_blank" rel="noopener">绵阳</a> 转动车回蓉（省钱）  </p><h2 id="兰州二打卡"><a href="#兰州二打卡" class="headerlink" title="兰州二打卡"></a>兰州二打卡</h2><p><img alt data-src="http://images.mafengwo.net/images/i/face/brands_v3/10.png"></p><p>上次到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 是4年前，当时是将其作为到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> 的中转站。时间仓促，只逛了兰大老校区，在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13295.html" target="_blank" rel="noopener">甘肃</a> 省博物馆参观了著名的马踏飞燕。<br>此行 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 仍为中转站目的，因为到达 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 时间较早，参观了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18668.html" target="_blank" rel="noopener">黄河</a> 母亲雕像，以及著名的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10514.html" target="_blank" rel="noopener">中山</a> 桥。中午 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10805.html" target="_blank" rel="noopener">日照</a> 强烈，并未登上白塔山公园。我想如果有下次中转打卡时候，将 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 市看完  。  </p><a id="more"></a><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566047603.html" target="_blank" rel="noopener"><img alt data-src="http://b1-q.mafengwo.net/s14/M00/94/52/wKgE2l0HVAeAZfGuAAf6dzgRjY4679.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566047604.html" target="_blank" rel="noopener"><img alt data-src="http://p3-q.mafengwo.net/s14/M00/94/54/wKgE2l0HVAiAK5N5AAmHeocZm1o624.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>游览完 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 当天飞到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 为9点，天仍大亮，因之前到过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> ，并不觉得新奇。第一感觉反而是，机场真大，真TM辽阔！然而此时并来不及赞叹观赏，饥肠辘辘的我们亟待回到市区解决肚子的需求。当晚住在一家新开的如家（非旅行社安排内）。</p><h2 id="“亚洲，美洲，巴州”"><a href="#“亚洲，美洲，巴州”" class="headerlink" title="“亚洲，美洲，巴州”"></a>“亚洲，美洲，巴州”</h2><p>翌日是端午节，自由活动，当天好友带着游 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 。<br>中午12点好友到酒店来接吃饭（顺便讲一下， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 的作息时间与内地相差2个小时左右），吃饭的地方是一家有歌舞表演的餐馆“纳瓦”。</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566662062.html" target="_blank" rel="noopener"><img alt data-src="http://p1-q.mafengwo.net/s14/M00/BE/D0/wKgE2l0HbzGAKRqYAAl0ZHSaNPk126.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>参观了大巴扎，当时正好广场上在跳舞，大家尽情施展舞技，也可以随意参与。不得不说维族人民各个能歌善舞。</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566666079.html" target="_blank" rel="noopener"><img alt data-src="http://n1-q.mafengwo.net/s14/M00/BF/38/wKgE2l0Hb5aAEEL6AAHGZSfEiUs454.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>晚上好友约上其高中同学一起撸串，听到我第二天出行，其高中同学谈起 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 之大，说起了标题的梗：“世界几大洲来数一数： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/52314.html" target="_blank" rel="noopener">亚洲</a> 、美洲、巴州（ <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18231.html" target="_blank" rel="noopener">巴音郭楞</a> 自治州）”。<br>微醺之后打车回到住处（旅行社所订酒店）， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 昆仑宾馆。这个宾馆有名之处在于其为“八楼”地名的来历，想来听过刀郎“2002年的第一场雪”的朋友们不会陌生（暴露年龄了）。</p><h2 id="“这是一段魔鬼行程”"><a href="#“这是一段魔鬼行程”" class="headerlink" title="“这是一段魔鬼行程”"></a>“这是一段魔鬼行程”</h2><p>第二天真正开始旅途，同行还有母女两人，坐一个7人商务车。师傅上车就跟我们讲道，旅行社这个安排有诸多往返行程。单日有时要开上700多公里甚至更多。他们其他师傅，甚至负责调度的旅行社同事一致觉得这是魔鬼行程。主要是因为：<br>– <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 之大<br>–旅行的安排景点够多<br>–路况虽好，一路低至60、70码的限速、<br>–师傅除了开车，还要负责安排食宿买景点票等<br>当然师傅虽累，却也非常负责。师傅本人是随兵团来的疆三代，一路上和师傅也聊了蛮多有关 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 的东西。</p><h2 id="额尔齐斯河"><a href="#额尔齐斯河" class="headerlink" title="额尔齐斯河"></a>额尔齐斯河</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18027.html" target="_blank" rel="noopener">额尔齐斯河</a> （简称“额河”）是学初中地理时就学过甚至特别有印象的河流。除了其是我国唯一一个自东向西并灌入北冰洋的河流，更因为其好听的名字。<br>行程第一天的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/64136.html" target="_blank" rel="noopener">可可托海</a> 和第二天的五彩滩则全为额河景点。6月河水正为丰水期，在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18027.html" target="_blank" rel="noopener">额尔齐斯河</a> 大峡谷看到奔流但又凶恶的河水，流过针叶树林，以及旁边带草的浅滩，一阵阵开阔奔腾之感油然而生，让人好不生爱。  </p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566826828.html" target="_blank" rel="noopener"><img alt data-src="http://p1-q.mafengwo.net/s14/M00/CB/D7/wKgE2l0He5KAYToIAAmQ77LiJMI169.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>看过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11340.html" target="_blank" rel="noopener">张掖</a> 丹霞，却不胜五彩滩的丹霞地貌，在额河风光的映衬下好似一副画作，更为出众。  </p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566841987.html" target="_blank" rel="noopener"><img alt data-src="http://b1-q.mafengwo.net/s14/M00/CC/D4/wKgE2l0HfHuAEPh1AA8_e1JuJGs403.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><h2 id="星空呢？"><a href="#星空呢？" class="headerlink" title="星空呢？"></a>星空呢？</h2><p>不同于额河， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 和 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 风景与 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/12703.html" target="_blank" rel="noopener">四川</a> 的高原草场比较像：高山草甸、野花、马牛羊在草场悠然地吃着草。一时间让人觉得，就在这个地方作只牛羊也甚好。  </p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567699124.html" target="_blank" rel="noopener"><img alt data-src="http://b3-q.mafengwo.net/s14/M00/16/8D/wKgE2l0HqRiALuIgAAaEF52WyoU208.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567699125.html" target="_blank" rel="noopener"><img alt data-src="http://p2-q.mafengwo.net/s14/M00/16/8F/wKgE2l0HqRmANK16AAca-RcnW04835.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 最期待的就是看到星空银河，况且一直对自己“召唤阳光”的技能充满自信，但是此行 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> ，无奈连日落雨，小木屋里看银河以及观 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/144202.html" target="_blank" rel="noopener">鱼台</a> 上找 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 水怪行程都落空。虽是如此，小木屋里听雨已经<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 湖边漫步则是另外一种感觉。<br>因为行程安排较紧， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 这种需要慢下来享受的地方，没有玩得很充分。希望下次再来，悠然地住上几天。</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742350.html" target="_blank" rel="noopener"><img alt data-src="http://p2-q.mafengwo.net/s14/M00/18/71/wKgE2l0HqjyAVIisAAWVm8T-CCY758.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742351.html" target="_blank" rel="noopener"><img alt data-src="http://n2-q.mafengwo.net/s14/M00/18/72/wKgE2l0Hqj2AQWyGAAYte1VLSfU048.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568203610.html" target="_blank" rel="noopener"><img alt data-src="http://n2-q.mafengwo.net/s14/M00/2F/A6/wKgE2l0HvMaAHUIgAAlDRoV89lk611.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742353.html" target="_blank" rel="noopener"><img alt data-src="http://n2-q.mafengwo.net/s14/M00/18/74/wKgE2l0Hqj-AYlbcAAzHPZPgZo0174.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>游览完 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 驱车几百公里回到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17988.html" target="_blank" rel="noopener">布尔津</a> ，下图为 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10300.html" target="_blank" rel="noopener">俄罗斯</a> 风情小镇。  </p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048108.html" target="_blank" rel="noopener"><img alt data-src="http://b4-q.mafengwo.net/s14/M00/25/79/wKgE2l0HsyeAMDyZAATgqMT8IEI892.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048109.html" target="_blank" rel="noopener"><img alt data-src="http://n2-q.mafengwo.net/s14/M00/25/7C/wKgE2l0HsyiANZPHAAhYR3f9PDQ984.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048111.html" target="_blank" rel="noopener"><img alt data-src="http://p3-q.mafengwo.net/s14/M00/25/7E/wKgE2l0HsymAY8XpAAa8RRCzkUY546.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><h2 id="重温魔鬼城"><a href="#重温魔鬼城" class="headerlink" title="重温魔鬼城"></a>重温魔鬼城</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> ，一座以石油命名的城市。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/21297.html" target="_blank" rel="noopener">乌尔禾</a> 魔鬼城就在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> ，之前到过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> “附近”（其实也有100多KM）雅丹魔鬼城，这种风化岩地形还蛮类似，因此比较震撼的是 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> 的油井。  </p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198721.html" target="_blank" rel="noopener"><img alt data-src="http://b4-q.mafengwo.net/s14/M00/2F/58/wKgE2l0HvHWAecfiAA8zkKV4bZw967.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198722.html" target="_blank" rel="noopener"><img alt data-src="http://b3-q.mafengwo.net/s14/M00/2F/59/wKgE2l0HvHWAQvYjAAXNplg6u5M013.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198723.html" target="_blank" rel="noopener"><img alt data-src="http://b3-q.mafengwo.net/s14/M00/2F/5C/wKgE2l0HvHeAe-kHAAjbwH5lbX8554.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>到处都是油井</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198725.html" target="_blank" rel="noopener"><img alt data-src="http://n3-q.mafengwo.net/s14/M00/2F/5D/wKgE2l0HvHiATokMAAUn4ccSa2Q361.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><h2 id="天山天池-新疆野马生态园"><a href="#天山天池-新疆野马生态园" class="headerlink" title="天山天池+新疆野马生态园"></a>天山天池+新疆野马生态园</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 南边200多公里， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> 和野马生态园是到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 路上经过乌市时经过的。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> 非常漂亮，海拔虽不高，但是因为纬度高的关系，山顶总是白雪覆盖。可惜到达天池一样下着小雨（第二天甚至已经被白雪覆盖）。</p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/569938993.html" target="_blank" rel="noopener"><img alt data-src="http://p2-q.mafengwo.net/s14/M00/73/C0/wKgE2l0IPJ6AKyNeAAF1uuYN864310.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/569938994.html" target="_blank" rel="noopener"><img alt data-src="http://n4-q.mafengwo.net/s14/M00/73/C0/wKgE2l0IPJ-AEJR-AAiDKw1KNHg936.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://p4-q.mafengwo.net/s14/M00/73/C2/wKgE2l0IPJ-ABv71AAQM4AwM9A8481.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://p4-q.mafengwo.net/s14/M00/73/C2/wKgE2l0IPJ-ABv71AAQM4AwM9A8481.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><h2 id="下雨的库木塔格沙漠"><a href="#下雨的库木塔格沙漠" class="headerlink" title="下雨的库木塔格沙漠"></a>下雨的库木塔格沙漠</h2><p>也许老天赏脸，到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 居然不热，第二天到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/16245.html" target="_blank" rel="noopener">鄯善</a> 的库木塔格沙漠还微微落雨。（复习一下高中地理， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 全年降雨量不过16.4毫米）。地面气温最高时有80多度的火焰山居然只有37度。<br>吃到了20块钱3个的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11348.html" target="_blank" rel="noopener">哈密</a> 瓜（果然是产地），与内地所吃味道略有不同（甜度更高，也有可能是心理因素）。据开车师傅讲，再过一个月上市高峰当地可以买到3毛钱一公斤。<br>晚上住在当地新开的一个酒庄宾馆</p><p><a href="https://n4-q.mafengwo.net/s14/M00/7E/02/wKgE2l0IQ9aAG8ExAAELGciI0_U018.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://n4-q.mafengwo.net/s14/M00/7E/02/wKgE2l0IQ9aAG8ExAAELGciI0_U018.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://p4-q.mafengwo.net/s14/M00/7E/04/wKgE2l0IQ9aAdqmsAAEmq3JDxRU225.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://p4-q.mafengwo.net/s14/M00/7E/04/wKgE2l0IQ9aAdqmsAAEmq3JDxRU225.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://b2-q.mafengwo.net/s14/M00/7E/05/wKgE2l0IQ9eAKXj2AAEr9RKCmCc803.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://b2-q.mafengwo.net/s14/M00/7E/05/wKgE2l0IQ9eAKXj2AAEr9RKCmCc803.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>骑了骆驼和沙滩越野车</p><p><a href="https://n4-q.mafengwo.net/s14/M00/7C/B9/wKgE2l0IQwmAMIpoAAJnYcrzOJI294.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://n4-q.mafengwo.net/s14/M00/7C/B9/wKgE2l0IQwmAMIpoAAJnYcrzOJI294.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://n1-q.mafengwo.net/s14/M00/7C/BA/wKgE2l0IQwqAVy0cAAagAF-44U4301.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://n1-q.mafengwo.net/s14/M00/7C/BA/wKgE2l0IQwqAVy0cAAagAF-44U4301.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p>坎儿井（从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 挖过火焰山一直到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> ，实际感受水温20度左右）  </p><p><a href="https://n3-q.mafengwo.net/s14/M00/7D/C7/wKgE2l0IQ7CAQJWuAAGVtnCFniE786.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://n3-q.mafengwo.net/s14/M00/7D/C7/wKgE2l0IQ7CAQJWuAAGVtnCFniE786.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://b4-q.mafengwo.net/s14/M00/7D/C8/wKgE2l0IQ7GAV68GAAFMXS89bqE804.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://b4-q.mafengwo.net/s14/M00/7D/C8/wKgE2l0IQ7GAV68GAAFMXS89bqE804.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><h2 id="后记：“一定要多推荐我们新疆”"><a href="#后记：“一定要多推荐我们新疆”" class="headerlink" title="后记：“一定要多推荐我们新疆”"></a>后记：“一定要多推荐我们新疆”</h2><p>离别前夜， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 观看当地丝路秀表演。</p><p><a href="https://n3-q.mafengwo.net/s14/M00/7E/E2/wKgE2l0IRGyAVOqDAADKwKvgOXo690.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://n3-q.mafengwo.net/s14/M00/7E/E2/wKgE2l0IRGyAVOqDAADKwKvgOXo690.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="https://b1-q.mafengwo.net/s14/M00/7E/E4/wKgE2l0IRG2ABVV8AAEIKKh19rk251.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img alt data-src="https://b1-q.mafengwo.net/s14/M00/7E/E4/wKgE2l0IRG2ABVV8AAEIKKh19rk251.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90"></a></p><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 幅员辽阔，此行8天也只是走马观花看了4分之一都不到的地方，下次应该是到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11471.html" target="_blank" rel="noopener">伊犁</a> 吧。不禁想起第一天和好友吃饭出门，好友的高中好友再三给我嘱咐“回去一定要多推荐我们 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> ，我们 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 真的很好”。一定会的！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想游 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新疆&lt;/a&gt; 已久，一直因为某些众所周知的因素不敢出行。终于，趁着这段空档期，恰在X程订到了1500一人的端午开始的8天7晚 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10757.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北疆&lt;/a&gt; 游，便开始这场说走就走的旅行。后来根据一路的住宿游玩等内容算起来，这段行程对旅行社一定是亏本赚吆喝买卖。&lt;/p&gt;&lt;h2 id=&quot;行程&quot;&gt;&lt;a href=&quot;#行程&quot; class=&quot;headerlink&quot; title=&quot;行程&quot;&gt;&lt;/a&gt;行程&lt;/h2&gt;&lt;p&gt;动身：&lt;br&gt;我们是从 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;成都&lt;/a&gt; 出发，由于想（机）多玩（票）地方（贵），真正动身先坐火车卧铺到 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt; ，从 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt;转机到 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;乌鲁木齐&lt;/a&gt; 。  &lt;/p&gt;&lt;p&gt;紧接着随团行程如下图：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.mafengwo.cn/photo/13061/scenery_13759048/565857780.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img alt data-src=&quot;http://n1-q.mafengwo.net/s14/M00/87/51/wKgE2l0HT3iAaYxoAAwnlE5wL2E379.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以下为行车线路：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://www.mafengwo.cn/photo/13061/scenery_13759048/565917107.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img alt data-src=&quot;http://n3-q.mafengwo.net/s14/M00/8B/DE/wKgE2l0HUMKAPqHkAAcQr2y5lm8180.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90&quot;&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;返程：最后一日回程从 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;乌鲁木齐&lt;/a&gt; 直飞 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13663.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;绵阳&lt;/a&gt; 转动车回蓉（省钱）  &lt;/p&gt;&lt;h2 id=&quot;兰州二打卡&quot;&gt;&lt;a href=&quot;#兰州二打卡&quot; class=&quot;headerlink&quot; title=&quot;兰州二打卡&quot;&gt;&lt;/a&gt;兰州二打卡&lt;/h2&gt;&lt;p&gt;&lt;img alt data-src=&quot;http://images.mafengwo.net/images/i/face/brands_v3/10.png&quot;&gt;&lt;/p&gt;&lt;p&gt;上次到 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt; 是4年前，当时是将其作为到 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;敦煌&lt;/a&gt; 的中转站。时间仓促，只逛了兰大老校区，在 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13295.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;甘肃&lt;/a&gt; 省博物馆参观了著名的马踏飞燕。&lt;br&gt;此行 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt; 仍为中转站目的，因为到达 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt; 时间较早，参观了 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18668.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄河&lt;/a&gt; 母亲雕像，以及著名的 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10514.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中山&lt;/a&gt; 桥。中午 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10805.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;日照&lt;/a&gt; 强烈，并未登上白塔山公园。我想如果有下次中转打卡时候，将 &lt;a href=&quot;http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;兰州&lt;/a&gt; 市看完  。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
      <category term="L&amp;amp;H游记" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/L-amp-H%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="游记" scheme="http://l2h.site/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="新疆" scheme="http://l2h.site/tags/%E6%96%B0%E7%96%86/"/>
    
  </entry>
  
  <entry>
    <title>YAFFS文件系统(4)– 垃圾回收(GC)机制</title>
    <link href="http://l2h.site/2019/05/18/yaffs-4/"/>
    <id>http://l2h.site/2019/05/18/yaffs-4/</id>
    <published>2019-05-18T02:02:59.000Z</published>
    <updated>2019-10-06T00:29:06.907Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收(Garbage Collection。 注：其实“垃圾回收”比较像是直译，叫“块回收”似乎比较恰当 )机制的主要作用是为了回收空闲或接近空闲的Nand块（Block），供文件系统后续使用（例如，创建文件、扩展文件大小、修改文件内容）。第一章《<a href="https://l2h.site/2019/04/30/yaffs-1/">概述</a>》启动代码分析 yaffs_bg_start函数，其作用就是启用Linux内核线程，专门用来做垃圾回收。因为是内核线程做垃圾回收，后台工作找到可以回收的Flash块就用内核空闲的时间做回收，因此较大程度提升了Yaffs的工作性能。</p><p>“垃圾回收”的核心思想为：</p><ul><li>先找到可以或者说值得回收的Block。注意：这里值得回收并非指的是Block内所有的Chunk（或者说Page）都无用了。Yaffs的回收器会根据一定的算法（本章之后小节会介绍）来找到一个可回收的Block。</li><li>对该Block内所有的Chunk进行遍历。若当前Chunk正在使用中，会将该Chunk复制一份到另外的Block内，并删除该Chunk。同时要更新文件Tnode、Block使用等内存中的信息。<ul><li>所以同一个文件存储到Flash上后，就算不被改写，存放位置也不一定是一成不变的。</li><li>另外，因此我们也会看到Flash上可能会存储同一个文件的同一个Chunk在不同的位置（当然也有可能是文件被改写造成的）。Yaffs用seq_number位来标记使用哪一个chunk作为当前文件真正要使用的chunk（seq_number大者为较新）。</li></ul></li><li>当Block内所有的Chunk都顺利删除后，则可以对Block进行擦除，供后续使用。</li></ul><a id="more"></a><p>Yaffs的垃圾回收有两种模式，取决于当前Nand Flash空间的使用状况。当Flash中仍有许多可用Block时，回收机制会相对缓和地回收（实际程序执行上，Yaffs后台程序会每次回收较少数量的chunk而不用回收完一个完整的Block），称为Passive（被动）模式，此时需要尽快释放出一个完整可用的block。否则称为Aggressive（主动）模式。两种模式的判断依据为，Flash所剩可用的Block数量是否小于预留Block数量加上Checkpoint所需Block数量。</p><p>以下是代码分析。首先看入口函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_bg_thread_fn</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">while</span> (context-&gt;bg_running) &#123;</span><br><span class="line"><span class="comment">//此循环为后台垃圾回收线程主循环</span></span><br><span class="line">yaffs_trace(YAFFS_TRACE_BACKGROUND, <span class="string">"yaffs_background"</span>);</span><br><span class="line"><span class="keyword">if</span> (kthread_should_stop()) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//访问yaffs临界区数据做保护</span></span><br><span class="line">yaffs_gross_lock(dev);</span><br><span class="line"></span><br><span class="line">now = jiffies;</span><br><span class="line"><span class="comment">//若目前已经到脏目录更新时间，则更新脏目录信息。</span></span><br><span class="line"><span class="comment">//脏目录：目录内的文件被添加、修改或删除，则需要更新目录的访问时间等信息。Yaffs将此操作延后到垃圾回收时间，主要是性能考虑。例：若某段时间内该目录下有多个文件被修改，可以最后做一次更新而不用每次修改都更新该目录的访问时间</span></span><br><span class="line"><span class="keyword">if</span> (time_after(now, next_dir_update) &amp;&amp; yaffs_bg_enable) &#123;</span><br><span class="line">yaffs_update_dirty_dirs(dev);</span><br><span class="line">next_dir_update = now + HZ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若目前已到垃圾回收时间，则开始垃圾回收，并计算下次垃圾回收时间</span></span><br><span class="line"><span class="keyword">if</span> (time_after(now, next_gc) &amp;&amp; yaffs_bg_enable) &#123;</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;is_checkpointed) &#123;</span><br><span class="line">urgency = yaffs_bg_gc_urgency(dev);</span><br><span class="line"><span class="comment">//执行垃圾回收</span></span><br><span class="line">gc_result = yaffs_bg_gc(dev, urgency);</span><br><span class="line"><span class="comment">//根据紧急度来计算下次垃圾回收时间</span></span><br><span class="line"><span class="keyword">if</span> (urgency &gt; <span class="number">1</span>)</span><br><span class="line">next_gc = now + HZ / <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (urgency &gt; <span class="number">0</span>)</span><br><span class="line">next_gc = now + HZ / <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">next_gc = now + HZ * <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">next_gc = next_dir_update;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line">yaffs_gross_unlock(dev);</span><br><span class="line"><span class="comment">//计算下次唤醒该线程的时间</span></span><br><span class="line">expires = next_dir_update;</span><br><span class="line"><span class="keyword">if</span> (time_before(next_gc, expires))</span><br><span class="line">expires = next_gc;</span><br><span class="line"><span class="keyword">if</span> (time_before(expires, now))</span><br><span class="line">expires = now + HZ;</span><br><span class="line"><span class="comment">//将垃圾回收线程（也就是正在执行的线程自己）让出调度，同时增加内核定时器到时唤醒此线程</span></span><br><span class="line">Y_INIT_TIMER(&amp;timer.timer, yaffs_background_waker);</span><br><span class="line">timer.timer.expires = expires + <span class="number">1</span>;</span><br><span class="line">timer.task = current;</span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">add_timer(&amp;timer);</span><br><span class="line">schedule();</span><br><span class="line">del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看Yaffs如何进行脏目录更新：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yaffs_update_dirty_dirs</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">........</span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;dev-&gt;dirty_dirs)) &#123;</span><br><span class="line">link = dev-&gt;dirty_dirs.next;</span><br><span class="line">list_del_init(link);</span><br><span class="line"></span><br><span class="line">d_s = list_entry(link, struct yaffs_dir_var, dirty);</span><br><span class="line">o_v = list_entry(d_s, <span class="keyword">union</span> yaffs_obj_var, dir_variant);</span><br><span class="line">obj = list_entry(o_v, struct yaffs_obj, variant);</span><br><span class="line"><span class="keyword">if</span> (obj-&gt;dirty)</span><br><span class="line"><span class="comment">//执行更新目录的操作</span></span><br><span class="line">yaffs_update_oh(obj, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_update_oh</span><span class="params">(struct yaffs_obj \*in, <span class="keyword">const</span> YCHAR \*name, <span class="keyword">int</span> force,<span class="keyword">int</span> is_shrink, <span class="keyword">int</span> shadows, struct yaffs_xattr_mod *xmod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(old_name, _Y(<span class="string">"silly old name"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in-&gt;fake &amp;&amp; in != dev-&gt;root_dir &amp;&amp; !force &amp;&amp; !xmod)</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line"><span class="comment">//垃圾回收代码，后续分析</span></span><br><span class="line">yaffs_check_gc(dev, <span class="number">0</span>);</span><br><span class="line">yaffs_check_obj_details_loaded(in);</span><br><span class="line">buffer = yaffs_get_temp_buffer(in-&gt;my_dev);</span><br><span class="line">oh = (struct yaffs_obj_hdr *)buffer;</span><br><span class="line">prev_chunk_id = in-&gt;hdr_chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//从Flash读出文件或者目录的标签（主要是读出文件名）</span></span><br><span class="line">result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,buffer, &amp;old_tags);</span><br><span class="line"><span class="keyword">if</span> (result == YAFFS_OK) &#123;</span><br><span class="line"><span class="comment">//对新分配的目录对象赋值</span></span><br><span class="line">yaffs_verify_oh(in, oh, &amp;old_tags, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(old_name, oh-&gt;name, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line"><span class="built_in">memset</span>(oh, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(*oh));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0xff</span>, dev-&gt;data_bytes_per_chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oh-&gt;type = in-&gt;variant_type;</span><br><span class="line">oh-&gt;yst_mode = in-&gt;yst_mode;</span><br><span class="line">oh-&gt;shadows_obj = oh-&gt;inband_shadowed_obj_id = shadows;</span><br><span class="line"><span class="comment">//文件属性赋值</span></span><br><span class="line">yaffs_load_attribs_oh(oh, in);</span><br><span class="line"><span class="comment">//父目录赋值</span></span><br><span class="line"><span class="keyword">if</span> (in-&gt;parent)</span><br><span class="line">oh-&gt;parent_obj_id = in-&gt;parent-&gt;obj_id;</span><br><span class="line"><span class="keyword">else</span> oh-&gt;parent_obj_id = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//文件名赋值</span></span><br><span class="line"><span class="keyword">if</span> (name &amp;&amp; *name) &#123;</span><br><span class="line"><span class="built_in">memset</span>(oh-&gt;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">yaffs_load_oh_from_name(dev, oh-&gt;name, name);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(oh-&gt;name, old_name, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(oh-&gt;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">&#125;</span><br><span class="line">oh-&gt;is_shrink = is_shrink;</span><br><span class="line"><span class="keyword">switch</span> (in-&gt;variant_type) &#123;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_UNKNOWN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_FILE:</span><br><span class="line"><span class="keyword">if</span> (oh-&gt;parent_obj_id != YAFFS_OBJECTID_DELETED &amp;&amp;</span><br><span class="line">    oh-&gt;parent_obj_id != YAFFS_OBJECTID_UNLINKED)</span><br><span class="line">file_size = in-&gt;variant.file_variant.stored_size;</span><br><span class="line">yaffs_oh_size_load(dev, oh, file_size, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_HARDLINK:</span><br><span class="line">oh-&gt;equiv_id = in-&gt;variant.hardlink_variant.equiv_id;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_SPECIAL:</span><br><span class="line">/\* Do nothing */</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_DIRECTORY:</span><br><span class="line">/\* Do nothing */</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_SYMLINK:</span><br><span class="line">alias = in-&gt;variant.symlink_variant.alias;</span><br><span class="line"><span class="keyword">if</span> (!alias) alias = _Y(<span class="string">"no alias"</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(oh-&gt;alias, alias, YAFFS_MAX_ALIAS_LENGTH);</span><br><span class="line">oh-&gt;alias[YAFFS_MAX_ALIAS_LENGTH] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值过程</span></span><br><span class="line"><span class="keyword">if</span> (xmod)</span><br><span class="line">yaffs_apply_xattrib_mod(in, (<span class="keyword">char</span> *)buffer, xmod);</span><br><span class="line"><span class="built_in">memset</span>(&amp;new_tags, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_tags));</span><br><span class="line">in-&gt;serial++;</span><br><span class="line">new_tags.chunk_id = <span class="number">0</span>;</span><br><span class="line">new_tags.obj_id = in-&gt;obj_id;</span><br><span class="line">new_tags.serial_number = in-&gt;serial;</span><br><span class="line">new_tags.extra_available = <span class="number">1</span>;</span><br><span class="line">new_tags.extra_parent_id = oh-&gt;parent_obj_id;</span><br><span class="line">new_tags.extra_file_size = file_size;</span><br><span class="line">new_tags.extra_is_shrink = oh-&gt;is_shrink;</span><br><span class="line">new_tags.extra_equiv_id = oh-&gt;equiv_id;</span><br><span class="line">new_tags.extra_shadows = (oh-&gt;shadows_obj &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">new_tags.extra_obj_type = in-&gt;variant_type;</span><br><span class="line">yaffs_do_endian_oh(dev, oh);</span><br><span class="line"><span class="comment">//将新文件信息写回Nand Flash</span></span><br><span class="line">yaffs_verify_oh(in, oh, &amp;new_tags, <span class="number">1</span>);</span><br><span class="line">new_chunk_id =  yaffs_write_new_chunk(dev, buffer, &amp;new_tags,(prev_chunk_id &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buffer) yaffs_release_temp_buffer(dev, buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_chunk_id &lt; <span class="number">0</span>) <span class="keyword">return</span> new_chunk_id;</span><br><span class="line"></span><br><span class="line">in-&gt;hdr_chunk = new_chunk_id;</span><br><span class="line"><span class="comment">//删除原有的文件chunk（因为我们已经有替代者了）。注意这里删除只是简单的对文件所在block的bitmap做一下标记</span></span><br><span class="line"><span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) yaffs_chunk_del(dev, prev_chunk_id, <span class="number">1</span>, __LINE__);</span><br><span class="line"><span class="keyword">if</span> (!yaffs_obj_cache_dirty(in))</span><br><span class="line">in-&gt;dirty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_shrink) &#123;</span><br><span class="line">bi = yaffs_get_block_info(in-&gt;my_dev, new_chunk_id / in-&gt;my_dev-&gt;param.chunks_per_block);</span><br><span class="line">bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> new_chunk_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">紧急程度计算方法见yaffs_bg_gc_urgency函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">yaffs_bg_gc_urgency</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_linux_context</span> *<span class="title">context</span> = <span class="title">yaffs_dev_to_lc</span>(<span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">unsigned</span> scattered = <span class="number">0</span>;<span class="comment">/* Free chunks not in an erased block */</span></span><br><span class="line"><span class="comment">//scattered为计算除空闲block外，整个flash剩余的可用chunk数量</span></span><br><span class="line"><span class="keyword">if</span> (erased_chunks &lt; dev-&gt;n_free_chunks) scattered = (dev-&gt;n_free_chunks - erased_chunks);</span><br><span class="line"><span class="comment">//若非后台运行，则直接返回urgency0</span></span><br><span class="line"><span class="keyword">if</span> (!context-&gt;bg_running)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//若数量小于2个block，表示暂时不需要开辟新block来做chunk分配</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (scattered &lt; (dev-&gt;param.chunks_per_block * <span class="number">2</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当可用非空block的空闲chunk已经不足2个block。则比较空闲block数量占所有空闲chunk比重。若占比较大，则回收紧急程度不高，否则紧急程度较高</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">4</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的垃圾回收代码yaffs_bg_gc如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_bg_gc</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">unsigned</span> urgency)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="comment">//垃圾回收</span></span><br><span class="line">yaffs_check_gc(dev, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_check_gc</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> background)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;param.gc_control_fn &amp;&amp; (dev-&gt;param.gc_control_fn(dev) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> YAFFS_OK;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;gc_disable) <span class="keyword">return</span> YAFFS_OK;</span><br><span class="line"><span class="comment">//执行垃圾回收</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">max_tries++;</span><br><span class="line"><span class="comment">//计算checkpoint所需的Flash Block数量</span></span><br><span class="line">checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);</span><br><span class="line"><span class="comment">//计算最少需要的块数量</span></span><br><span class="line">min_erased = dev-&gt;param.n_reserved_blocks + checkpt_block_adjust + <span class="number">1</span>;</span><br><span class="line">erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="comment">//若空闲Block数量小于最小需求，则需要进行主动回收</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; min_erased)</span><br><span class="line">aggressive = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若非后台回收，且空闲的block对应chunk数量大于总空闲chunk数量（含已分配Block中未使用的chunk）的四分之一则退出循环</span></span><br><span class="line"><span class="keyword">if</span> (!background &amp;&amp; erased_chunks &gt; (dev-&gt;n_free_chunks / <span class="number">4</span>)) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;gc_skip &gt; <span class="number">20</span>) dev-&gt;gc_skip = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (erased_chunks &lt; dev-&gt;n_free_chunks / <span class="number">2</span> || dev-&gt;gc_skip &lt; <span class="number">1</span> || background) aggressive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dev-&gt;gc_skip--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;gc_skip = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//若目前还未指定到要回收的Block且执行被动模式，则尝试找到一个seq最老的需要刷新的block。</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;gc_block &lt; <span class="number">1</span> &amp;&amp; !aggressive) &#123;</span><br><span class="line">dev-&gt;gc_block = yaffs2_find_refresh_block(dev);</span><br><span class="line">dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若仍未找到可回收块。则查找最脏的块进行回收</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;gc_block &lt; <span class="number">1</span>) &#123;</span><br><span class="line">dev-&gt;gc_block = yaffs_find_gc_block(dev, aggressive, background);</span><br><span class="line">dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行回收</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;gc_block &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dev-&gt;all_gcs++;</span><br><span class="line"><span class="keyword">if</span> (!aggressive) dev-&gt;passive_gc_count++;</span><br><span class="line">gc_ok = yaffs_gc_block(dev, dev-&gt;gc_block, aggressive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks &amp;&amp; dev-&gt;gc_block &gt; <span class="number">0</span>) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_GC, <span class="string">"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d"</span>, dev-&gt;n_erased_blocks, max_tries, dev-&gt;gc_block);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks) &amp;&amp;  (dev-&gt;gc_block &gt; <span class="number">0</span>) &amp;&amp; (max_tries &lt; <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> aggressive ? gc_ok : YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yaffs_gc_block代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_gc_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block, <span class="keyword">int</span> whole_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">int</span> chunks_before = yaffs_get_erased_chunks(dev);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span> = <span class="title">yaffs_get_block_info</span>(<span class="title">dev</span>, <span class="title">block</span>);</span></span><br><span class="line">is_checkpt_block = (bi-&gt;block_state == YAFFS_BLOCK_STATE_CHECKPOINT);</span><br><span class="line"><span class="comment">//改变Block状态为正在回收</span></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_FULL) bi-&gt;block_state = YAFFS_BLOCK_STATE_COLLECTING;</span><br><span class="line"></span><br><span class="line">bi-&gt;has_shrink_hdr = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//因为正在做回收，暂时关闭回收</span></span><br><span class="line">dev-&gt;gc_disable = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//回收summary chunk</span></span><br><span class="line">yaffs_summary_gc(dev, block);</span><br><span class="line"><span class="comment">//若是checkpoint block或者block没有正在使用的chunk，直接回收</span></span><br><span class="line"><span class="keyword">if</span> (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) &#123;</span><br><span class="line">yaffs_block_became_dirty(dev, block);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则，复制block内的使用中chunk到其他block并回收block</span></span><br><span class="line">u8 *buffer = yaffs_get_temp_buffer(dev);</span><br><span class="line">yaffs_verify_blk(dev, bi, block);</span><br><span class="line">max_copies = (whole_block) ? dev-&gt;param.chunks_per_block : <span class="number">5</span>;</span><br><span class="line">old_chunk = block * dev-&gt;param.chunks_per_block + dev-&gt;gc_chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="comment">/* init already done */</span> ;</span><br><span class="line">     ret_val == YAFFS_OK &amp;&amp;</span><br><span class="line">     dev-&gt;gc_chunk &lt; dev-&gt;param.chunks_per_block &amp;&amp;</span><br><span class="line">     (bi-&gt;block_state == YAFFS_BLOCK_STATE_COLLECTING) &amp;&amp;</span><br><span class="line">     max_copies &gt; <span class="number">0</span>;  dev-&gt;gc_chunk++, old_chunk++) &#123;</span><br><span class="line"><span class="keyword">if</span> (yaffs_check_chunk_bit(dev, block, dev-&gt;gc_chunk)) &#123; </span><br><span class="line">max_copies--;</span><br><span class="line"><span class="comment">//对每个chunk进行复制和回收</span></span><br><span class="line">ret_val = yaffs_gc_process_chunk(dev, bi,</span><br><span class="line">old_chunk,buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">yaffs_release_temp_buffer(dev, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yaffs_verify_collected_blk(dev, bi, block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_COLLECTING) &#123;</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;n_clean_ups; i++) &#123;</span><br><span class="line"><span class="comment">//对所有的object，进行一次性统一删除</span></span><br><span class="line">struct yaffs_obj *object = yaffs_find_by_number(dev, dev-&gt;gc_cleanup_list[i]);</span><br><span class="line"><span class="keyword">if</span> (object) &#123;</span><br><span class="line">yaffs_free_tnode(dev,  object-&gt;variant.file_variant.top);</span><br><span class="line">object-&gt;variant.file_variant.top = <span class="literal">NULL</span>;</span><br><span class="line">yaffs_generic_obj_del(object);</span><br><span class="line">object-&gt;my_dev-&gt;n_deleted_files--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">chunks_after = yaffs_get_erased_chunks(dev);</span><br><span class="line"><span class="keyword">if</span> (chunks_before &gt;= chunks_after)</span><br><span class="line">yaffs_trace(YAFFS_TRACE_GC, <span class="string">"gc did not increase free chunks before %d after %d"</span>, chunks_before, chunks_after);</span><br><span class="line">dev-&gt;gc_block = <span class="number">0</span>;</span><br><span class="line">dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev-&gt;gc_disable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，即为Yaffs垃圾回收机制的分析。至此，Yaffs文件系统代码分析结束。若有不恰当之处，也请大家多交流指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收(Garbage Collection。 注：其实“垃圾回收”比较像是直译，叫“块回收”似乎比较恰当 )机制的主要作用是为了回收空闲或接近空闲的Nand块（Block），供文件系统后续使用（例如，创建文件、扩展文件大小、修改文件内容）。第一章《&lt;a href=&quot;https://l2h.site/2019/04/30/yaffs-1/&quot;&gt;概述&lt;/a&gt;》启动代码分析 yaffs_bg_start函数，其作用就是启用Linux内核线程，专门用来做垃圾回收。因为是内核线程做垃圾回收，后台工作找到可以回收的Flash块就用内核空闲的时间做回收，因此较大程度提升了Yaffs的工作性能。&lt;/p&gt;&lt;p&gt;“垃圾回收”的核心思想为：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;先找到可以或者说值得回收的Block。注意：这里值得回收并非指的是Block内所有的Chunk（或者说Page）都无用了。Yaffs的回收器会根据一定的算法（本章之后小节会介绍）来找到一个可回收的Block。&lt;/li&gt;
&lt;li&gt;对该Block内所有的Chunk进行遍历。若当前Chunk正在使用中，会将该Chunk复制一份到另外的Block内，并删除该Chunk。同时要更新文件Tnode、Block使用等内存中的信息。&lt;ul&gt;
&lt;li&gt;所以同一个文件存储到Flash上后，就算不被改写，存放位置也不一定是一成不变的。&lt;/li&gt;
&lt;li&gt;另外，因此我们也会看到Flash上可能会存储同一个文件的同一个Chunk在不同的位置（当然也有可能是文件被改写造成的）。Yaffs用seq_number位来标记使用哪一个chunk作为当前文件真正要使用的chunk（seq_number大者为较新）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当Block内所有的Chunk都顺利删除后，则可以对Block进行擦除，供后续使用。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux文件系统" scheme="http://l2h.site/categories/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="YAFFS" scheme="http://l2h.site/tags/YAFFS/"/>
    
      <category term="文件系统" scheme="http://l2h.site/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Yaffs文件系统(3)-- 检查点(Checkpoint)机制</title>
    <link href="http://l2h.site/2019/05/15/yaffs-3/"/>
    <id>http://l2h.site/2019/05/15/yaffs-3/</id>
    <published>2019-05-15T14:16:46.000Z</published>
    <updated>2019-10-06T00:29:52.302Z</updated>
    
    <content type="html"><![CDATA[<p>前文对Yaffs文件系统<a href="https://l2h.site/2019/04/30/yaffs-1/">框架</a>及<a href="https://l2h.site/2019/05/14/yaffs-2/">Block</a>管理，本文介绍Yaffs的检查点机制。什么是检查点机制？文件系统将目录结构存储在Nand Flash中一个特殊Block内，在Mount时快速加载，加速文件系统的加载。同时，机制也可以一定程度上避免因为突然掉电等因素造成的文件系统破坏。</p><p>本章先介绍文件的Tnode Tree，接着介绍Yaffs的checkpoint格式。</p><h2 id="Tnode-Tree"><a href="#Tnode-Tree" class="headerlink" title="Tnode Tree"></a>Tnode Tree</h2><p>Tnode Tree是Yaffs文件系统用来存储某个文件与其所在Nand Flash位置关系的一个树状结构。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tnode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tnode</span> *<span class="title">internal</span>\[<span class="title">YAFFS_NTNODES_INTERNAL</span>\];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以看出，tnode存储为简单的指针数组，内部存储为指向下一级tnodes的指针。其结构如下：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/05/tnode.png"></p><p>Tnode树结构</p><p>可以看出，只有最后一级（即Level 0）存放的是该文件所在Nand Flash的位置。具体如何存储的此处不做过多说明，请大家自行分析，主要为一些位计算。</p><h2 id="Checkpoint存储格式"><a href="#Checkpoint存储格式" class="headerlink" title="Checkpoint存储格式"></a>Checkpoint存储格式</h2><p>Checkpoint的存储格式如下图：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/05/checkpoint-2-1024x792.png"></p><p>在Checkpoint内部存储的内容依次是：</p><ul><li>1字节有效性标记</li><li>36字节的设备信息相关变量，储存第一章介绍的<a href="https://l2h.site/2019/04/30/yaffs-1/#i-4">yaffs_dev结构体</a>必须的内容</li><li>该分区所有Nand块的信息，包括块内的chunk是否被使用</li><li>所有文件或目录的信息，与运行时RAM里存储的内容类似</li><li>1字节尾部有效性标记</li><li>检查点所有内容的校验和</li></ul><p>需要说明的是Yaffs的检查点信息，会使用专门的块来存储。其obj_id为特殊的0x21，且checkpoint不存在chunk id为0的Object（即 Header Object）。一个简单的checkpoint存储内容如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+----------------------------+</span></span><br><span class="line">|数 据                       |</span><br><span class="line">|                            |</span><br><span class="line">|                        数据|</span><br><span class="line"><span class="code">+----------------------------+</span></span><br><span class="line">|0x21 chunk<span class="emphasis">_id(1) size ecc   |</span></span><br><span class="line"><span class="emphasis">+----------------------------+</span></span><br><span class="line"><span class="emphasis">|数据                        |</span></span><br><span class="line"><span class="emphasis">|                            |</span></span><br><span class="line"><span class="emphasis">|                        数据|</span></span><br><span class="line"><span class="emphasis">+----------------------------+</span></span><br><span class="line"><span class="emphasis">|0x21 chunk_</span>id(2) size ecc   |</span><br><span class="line"><span class="code">+----------------------------+</span></span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|  ........................  |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line"><span class="code">+----------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="Checkpoint读写擦除"><a href="#Checkpoint读写擦除" class="headerlink" title="Checkpoint读写擦除"></a>Checkpoint读写擦除</h2><p>Checkpoint是按照前一节所介绍存储结构的顺序进行读写。</p><ul><li>读Checkpoint的函数入口是yaffs2_checkpt_restore()-&gt;yaffs2_rd_checkpt_data()，一般在Mount时进行</li><li>写Checkpoint的函数入口是yaffs_checkpoint_save()-&gt;yaffs2_wr_checkpt_data()</li><li>擦除Checkpoint的函数入口是yaffs2_checkpt_invalidate()-&gt;yaffs2_checkpt_invalidate_stream()-&gt; yaffs_checkpt_erase()</li></ul><p>代码如下（相对比较容易理解不做过多注释）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs2_checkpt_restore</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">retval = yaffs2_rd_checkpt_data(dev);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;is_checkpointed) &#123;</span><br><span class="line">yaffs_verify_objects(dev);</span><br><span class="line">yaffs_verify_blocks(dev);</span><br><span class="line">yaffs_verify_free_chunks(dev);</span><br><span class="line">&#125;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"restore exit: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs2_rd_checkpt_data</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ok = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;param.is_yaffs2) ok = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ok &amp;&amp; dev-&gt;param.skip_checkpt_rd) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"skipping checkpoint read"</span>);</span><br><span class="line">ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line">ok = yaffs2_checkpt_open(dev, <span class="number">0</span>); <span class="comment">/* open for read */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint validity"</span>);</span><br><span class="line">ok = yaffs2_rd_checkpt_validity_marker(dev, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint device"</span>);</span><br><span class="line">ok = yaffs2_rd_checkpt_dev(dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint objects"</span>);</span><br><span class="line">ok = yaffs2_rd_checkpt_objs(dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"read checkpoint validity"</span>);</span><br><span class="line">ok = yaffs2_rd_checkpt_validity_marker(dev, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">ok = yaffs2_rd_checkpt_sum(dev);</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"read checkpoint checksum %d"</span>, ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!yaffs_checkpt_close(dev))ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) dev-&gt;is_checkpointed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dev-&gt;is_checkpointed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ok ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_checkpoint_save</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"save entry: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line">yaffs_verify_objects(dev);</span><br><span class="line">yaffs_verify_blocks(dev);</span><br><span class="line">yaffs_verify_free_chunks(dev);</span><br><span class="line"><span class="keyword">if</span> (!dev-&gt;is_checkpointed) &#123;</span><br><span class="line">yaffs2_checkpt_invalidate(dev);</span><br><span class="line">yaffs2_wr_checkpt_data(dev);</span><br><span class="line">&#125;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT, <span class="string">"save exit: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev-&gt;is_checkpointed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs2_wr_checkpt_data</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!yaffs2_checkpt_required(dev)) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"skipping checkpoint write"</span>);ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) ok = yaffs2_checkpt_open(dev, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint validity"</span>); ok = yaffs2_wr_checkpt_validity_marker(dev, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint device"</span>); ok = yaffs2_wr_checkpt_dev(dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint objects"</span>); ok = yaffs2_wr_checkpt_objs(dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint validity"</span>); ok = yaffs2_wr_checkpt_validity_marker(dev, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) ok = yaffs2_wr_checkpt_sum(dev);</span><br><span class="line"><span class="keyword">if</span> (!yaffs_checkpt_close(dev)) ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok) dev-&gt;is_checkpointed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dev-&gt;is_checkpointed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev-&gt;is_checkpointed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容即为Yaffs的Checkpoint机制，接下来将会介绍GC（Garbage Collection，垃圾回收）机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文对Yaffs文件系统&lt;a href=&quot;https://l2h.site/2019/04/30/yaffs-1/&quot;&gt;框架&lt;/a&gt;及&lt;a href=&quot;https://l2h.site/2019/05/14/yaffs-2/&quot;&gt;Block&lt;/a&gt;管理，本文介绍Yaffs的检查点机制。什么是检查点机制？文件系统将目录结构存储在Nand Flash中一个特殊Block内，在Mount时快速加载，加速文件系统的加载。同时，机制也可以一定程度上避免因为突然掉电等因素造成的文件系统破坏。&lt;/p&gt;&lt;p&gt;本章先介绍文件的Tnode Tree，接着介绍Yaffs的checkpoint格式。&lt;/p&gt;&lt;h2 id=&quot;Tnode-Tree&quot;&gt;&lt;a href=&quot;#Tnode-Tree&quot; class=&quot;headerlink&quot; title=&quot;Tnode Tree&quot;&gt;&lt;/a&gt;Tnode Tree&lt;/h2&gt;&lt;p&gt;Tnode Tree是Yaffs文件系统用来存储某个文件与其所在Nand Flash位置关系的一个树状结构。其定义如下：&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yaffs_tnode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yaffs_tnode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;internal&lt;/span&gt;\[&lt;span class=&quot;title&quot;&gt;YAFFS_NTNODES_INTERNAL&lt;/span&gt;\];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux文件系统" scheme="http://l2h.site/categories/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="YAFFS" scheme="http://l2h.site/tags/YAFFS/"/>
    
      <category term="文件系统" scheme="http://l2h.site/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Yaffs文件系统(2)--块及Chunk管理</title>
    <link href="http://l2h.site/2019/05/14/yaffs-2/"/>
    <id>http://l2h.site/2019/05/14/yaffs-2/</id>
    <published>2019-05-14T06:12:01.000Z</published>
    <updated>2019-10-06T00:30:05.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://l2h.site/2019/04/30/yaffs-1/">Yaffs文件系统(1)-概述</a>对文件系统的基本数据结构和初始化流程进行了介绍，本节着重介绍Yaffs如何对Block和Chunk进行管理的。</p><h2 id="Block分类"><a href="#Block分类" class="headerlink" title="Block分类"></a>Block分类</h2><p>UNKNOWN</p><p>区块状态未知</p><p>NEEDS_SCANNING</p><p>预扫描时确定该Block需要被扫描</p><p>SCANNING</p><p>Block正在扫描</p><p>EMPTY</p><p>Block为空，表示已经被擦除</p><p>ALLOCATING</p><p>Block被Chunk分配器使用中</p><p>FULL</p><p>Block已经分配，且至少有一个chunk被删除</p><p>DIRTY</p><p>Block全部chunk被删可被擦除</p><p>CHECKPOINT</p><p>Block中包含checkpoint数据</p><p>COLLECTING</p><p>Block正在被做垃圾回收</p><p>DEAD</p><p>Block为坏块</p><a id="more"></a><p>以上Block状态转化图如下：</p><p><img alt data-src="https://l2h.site/wp-content/uploads/2019/05/yaffs-2-1.png"></p><h2 id="Block和Chunk分配"><a href="#Block和Chunk分配" class="headerlink" title="Block和Chunk分配"></a>Block和Chunk分配</h2><p>Yaffs分配原则如下：</p><ul><li>Yaffs保存目前正在使用的Block编号，优先从该block上分配Chunk</li><li>当Block已经分配完毕（进入FULL状态），则选取另外一个未分配Block（即EMPTY Block）来分配</li><li>分配Chunk时，更新该Block对应的分配位图</li></ul><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_alloc_chunk</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> use_reserver, struct yaffs_block_info **block_ptr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret_val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span>;</span></span><br><span class="line">        <span class="comment">//若当前用于分配的Block为0，则找到一个EMPTY块分配</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev-&gt;alloc_block = yaffs_find_alloc_block(dev);</span><br><span class="line">dev-&gt;alloc_page = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">        ..........</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//取得当前Block信息</span></span><br><span class="line">bi = yaffs_get_block_info(dev, dev-&gt;alloc_block);</span><br><span class="line">                <span class="comment">//得到Chunk ID</span></span><br><span class="line">ret_val = (dev-&gt;alloc_block * dev-&gt;param.chunks_per_block) + dev-&gt;alloc_page;</span><br><span class="line">bi-&gt;pages_in_use++;</span><br><span class="line">                <span class="comment">//设定当前Block的Chunk位图，更新剩余chunk的id，以及当前Block已分配page数量</span></span><br><span class="line">yaffs_set_chunk_bit(dev, dev-&gt;alloc_block, dev-&gt;alloc_page);</span><br><span class="line">dev-&gt;alloc_page++;</span><br><span class="line">dev-&gt;n_free_chunks--;</span><br><span class="line">                <span class="comment">//若已经分配数量大于Block支持最大的数量，则标记block状态为FULL，同时设置alloc_block为-1，表示重新查找一个EMPTY block进行分配</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_page &gt;= dev-&gt;param.chunks_per_block)          &#123;</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">dev-&gt;alloc_block = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (block_ptr) *block_ptr = bi;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_find_alloc_block</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......<span class="comment">//若剩余可用Block不足，则不分配</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//以下为遍历查找一个可用block</span></span><br><span class="line"><span class="keyword">for</span> (i = dev-&gt;internal_start_block; i &lt;= dev-&gt;internal_end_block; i++) &#123;</span><br><span class="line">dev-&gt;alloc_block_finder++;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block_finder &lt; (<span class="keyword">int</span>)dev-&gt;internal_start_block || dev-&gt;alloc_block_finder &gt; (<span class="keyword">int</span>)dev-&gt;internal_end_block) &#123;</span><br><span class="line">dev-&gt;alloc_block_finder = dev-&gt;internal_start_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bi = yaffs_get_block_info(dev, dev-&gt;alloc_block_finder);</span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line"><span class="comment">//查找到一个EMPLY Block，则使用之，使用前更新状态为ALLOCATING</span></span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line"><span class="comment">//序列号，用于标记文件chunk的新旧，每分配一个block就+1</span></span><br><span class="line">dev-&gt;seq_number++;</span><br><span class="line">bi-&gt;seq_number = dev-&gt;seq_number;</span><br><span class="line">dev-&gt;n_erased_blocks--;</span><br><span class="line"><span class="keyword">return</span> dev-&gt;alloc_block_finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">..........</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct yaffs_block_info *<span class="title">yaffs_get_block_info</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">..........</span><br><span class="line">       <span class="comment">//返回当前Block的info</span></span><br><span class="line"><span class="keyword">return</span> &amp;dev-&gt;block_info[blk - dev-&gt;internal_start_block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Block的扫描"><a href="#Block的扫描" class="headerlink" title="Block的扫描"></a>Block的扫描</h2><p>扫描的目的是Mount时建立起Yaffs的文件结构，代码实现在yaffs_guts_initialise（如果您还有印象，即mount过程中yaffs_internal_read_super会调用到的），如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_guts_initialise</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//yaffs的Low Level初始化，主要为初始化一些基本参数</span></span><br><span class="line"><span class="keyword">if</span>(yaffs_guts_ll_init(dev) != YAFFS_OK) <span class="keyword">return</span> YAFFS_FAIL; </span><br><span class="line">......</span><br><span class="line">dev-&gt;is_mounted = <span class="number">1</span>;</span><br><span class="line">......<span class="comment">//初始化块管理相关一些基本参数</span></span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_init_blocks(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//初始化tnode对象树</span></span><br><span class="line">yaffs_init_tnodes_and_objs(dev);</span><br><span class="line">      <span class="comment">//初始化根目录、lost and found等特殊目录</span></span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_create_initial_dir(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//summary init（Yaffs2新引入的机制，利用block的空白chunk区域存储一些有效信息来帮助加速加载）</span></span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; dev-&gt;param.is_yaffs2 &amp;&amp; !dev-&gt;param.disable_summary &amp;&amp; !yaffs_summary_init(dev))</span><br><span class="line">init_failed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!init_failed) &#123;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;param.is_yaffs2) &#123;</span><br><span class="line">      <span class="comment">//尝试从checkpoint中恢复mount</span></span><br><span class="line"><span class="keyword">if</span> (yaffs2_checkpt_restore(dev)) &#123;</span><br><span class="line">yaffs_check_obj_details_loaded(dev-&gt;root_dir);</span><br><span class="line">......</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果checkpoint加载失败，则重新初始化block和tnode树（因为checkpoint加载过程中可能已经使用了相关结构做存储，而我们这里要重新建立）</span></span><br><span class="line">yaffs_deinit_blocks(dev);</span><br><span class="line">yaffs_deinit_tnodes_and_objs(dev);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; yaffs_init_blocks(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">yaffs_init_tnodes_and_objs(dev);</span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_create_initial_dir(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//执行Block扫描过程</span></span><br><span class="line"><span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs2_scan_backwards(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!yaffs1_scan(dev)) &#123;</span><br><span class="line">init_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yaffs_strip_deleted_objs(dev);</span><br><span class="line">yaffs_fix_hanging_objs(dev);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;param.empty_lost_n_found)</span><br><span class="line">yaffs_empty_l_n_f(dev);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文暂不讨论summary以及checkpoint等情况，那么整个block加载过程的核心代码即为：<strong>yaffs2_scan_backwards</strong>。详细如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs2_scan_backwards</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">dev-&gt;seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;</span><br><span class="line"><span class="comment">//为block信息存储分配空间</span></span><br><span class="line">block_index = kmalloc(n_blocks * <span class="keyword">sizeof</span>(struct yaffs_block_index), GFP_NOFS);</span><br><span class="line"><span class="keyword">if</span> (!block_index) &#123;</span><br><span class="line">block_index =  vmalloc(n_blocks * <span class="keyword">sizeof</span>(struct yaffs_block_index)); alt_block_index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">dev-&gt;blocks_in_checkpt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">chunk_data = yaffs_get_temp_buffer(dev);</span><br><span class="line"><span class="comment">//以下这段代码看着很长，但其实比较容易理解，详见注释</span></span><br><span class="line">bi = dev-&gt;block_info;</span><br><span class="line"><span class="keyword">for</span> (blk = dev-&gt;internal_start_block; blk &lt;= dev-&gt;internal_end_block; blk++) &#123;</span><br><span class="line"><span class="comment">//清除block的chunk使用标记</span></span><br><span class="line">yaffs_clear_chunk_bits(dev, blk);</span><br><span class="line">bi-&gt;pages_in_use = <span class="number">0</span>;</span><br><span class="line">bi-&gt;soft_del_pages = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//得到block初始状态以及序列号，即执行yaffs_tags_marshall_query_block得到当前block里chunk是否有正在使用，如果有则需要扫描</span></span><br><span class="line">yaffs_query_init_block_state(dev, blk, &amp;state, &amp;seq_number);</span><br><span class="line">bi-&gt;block_state = state;</span><br><span class="line">bi-&gt;seq_number = seq_number;</span><br><span class="line"><span class="keyword">if</span> (bi-&gt;seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_CHECKPOINT;</span><br><span class="line"><span class="keyword">if</span> (bi-&gt;seq_number == YAFFS_SEQUENCE_BAD_BLOCK)</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_DEAD;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_CHECKPOINT) &#123;</span><br><span class="line">dev-&gt;blocks_in_checkpt++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_DEAD) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, <span class="string">"block %d is bad"</span>, blk);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, <span class="string">"Block empty "</span>);</span><br><span class="line">dev-&gt;n_erased_blocks++;</span><br><span class="line">dev-&gt;n_free_chunks += dev-&gt;param.chunks_per_block;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) &#123;</span><br><span class="line"><span class="comment">//如果block状态为needs_scan，则标记后续对block进行scan</span></span><br><span class="line"><span class="keyword">if</span> (seq_number &gt;= YAFFS_LOWEST_SEQUENCE_NUMBER &amp;&amp; seq_number &lt; YAFFS_HIGHEST_SEQUENCE_NUMBER) &#123;</span><br><span class="line">block_index[n_to_scan].seq = seq_number;</span><br><span class="line">block_index[n_to_scan].block = blk;</span><br><span class="line">n_to_scan++;</span><br><span class="line"><span class="keyword">if</span> (seq_number &gt;= dev-&gt;seq_number)</span><br><span class="line">dev-&gt;seq_number = seq_number;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">"Block scanning block %d has bad sequence number %d"</span>, blk, seq_number);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bi++;</span><br><span class="line">&#125;</span><br><span class="line">...... <span class="comment">//对block进行排序，排序的依据是按照block的序列号。会这样做原因是yaffs在管理文件，采用就是逐步增加的序列号。同一个文件同一个chunk id，较大的序列号为最新。这也是函数scan_backwards的由来。</span></span><br><span class="line">sort(block_index, n_to_scan, <span class="keyword">sizeof</span>(struct yaffs_block_index),</span><br><span class="line">   yaffs2_ybicmp, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//真正开始进行扫描</span></span><br><span class="line">start_iter = <span class="number">0</span>;</span><br><span class="line">end_iter = n_to_scan - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (block_iter = end_iter;!alloc_failed &amp;&amp; block_iter &gt;= start_iter;block_iter--) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//对每个需要扫描的block进行扫描</span></span><br><span class="line">blk = block_index[block_iter].block;</span><br><span class="line">bi = yaffs_get_block_info(dev, blk);</span><br><span class="line">deleted = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//summary读取，本文不做详述</span></span><br><span class="line">summary_available = yaffs_summary_read(dev, dev-&gt;sum_tags, blk);</span><br><span class="line">found_chunks = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (summary_available)</span><br><span class="line">c = dev-&gt;chunks_per_summary - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c = dev-&gt;param.chunks_per_block - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//对block中的每一个chunk进行扫描</span></span><br><span class="line"><span class="keyword">for</span> (  !alloc_failed &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">     (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||</span><br><span class="line">      bi-&gt;block_state == YAFFS_BLOCK_STATE_ALLOCATING);</span><br><span class="line">      c--) &#123;</span><br><span class="line"><span class="keyword">if</span> (yaffs2_scan_chunk(dev, bi, blk, c, &amp;found_chunks, chunk_data, &amp;hard_list, summary_available) == YAFFS_FAIL) alloc_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) &#123;</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;pages_in_use == <span class="number">0</span> &amp;&amp;  !bi-&gt;has_shrink_hdr &amp;&amp;</span><br><span class="line">    bi-&gt;block_state == YAFFS_BLOCK_STATE_FULL) &#123;</span><br><span class="line">yaffs_block_became_dirty(dev, blk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yaffs_skip_rest_of_block(dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alt_block_index) vfree(block_index);</span><br><span class="line"><span class="keyword">else</span> kfree(block_index);</span><br><span class="line">        <span class="comment">//处理文件Hard Link</span></span><br><span class="line">yaffs_link_fixup(dev, &amp;hard_list);</span><br><span class="line">        <span class="comment">//释放分配的临时缓存</span></span><br><span class="line">yaffs_release_temp_buffer(dev, chunk_data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alloc_failed)</span><br><span class="line"><span class="keyword">return</span> YAFFS_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码注释可以看出，yaffs2_scan_backwards核心代码为yaffs2_scan_chunk,代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">yaffs2_scan_chunk</span><span class="params">(struct yaffs_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">struct yaffs_block_info *bi,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> blk, <span class="keyword">int</span> chunk_in_block,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> *found_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">u8 *chunk_data,</span></span></span><br><span class="line"><span class="function"><span class="params">struct list_head *hard_list,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> summary_available)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//如果存在summary则读取summary</span></span><br><span class="line"><span class="keyword">int</span> chunk = blk * dev-&gt;param.chunks_per_block + chunk_in_block</span><br><span class="line"><span class="keyword">if</span> (summary_available) &#123;</span><br><span class="line">result = yaffs_summary_fetch(dev, &amp;tags, chunk_in_block);</span><br><span class="line">tags.seq_number = bi-&gt;seq_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从chunk中读取对应tag信息</span></span><br><span class="line"><span class="keyword">if</span> (!summary_available || tags.obj_id == <span class="number">0</span>) &#123;</span><br><span class="line">result = yaffs_rd_chunk_tags_nand(dev, chunk, <span class="literal">NULL</span>, &amp;tags);</span><br><span class="line">dev-&gt;tags_used++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dev-&gt;summary_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!tags.chunk_used) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (*found_chunks) &#123;</span><br><span class="line"><span class="comment">/* This is a chunk that was skipped due</span></span><br><span class="line"><span class="comment"> * to failing the erased check */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (chunk_in_block == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//如果为block第一个chunk且未使用，则整个block为空</span></span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_EMPTY;</span><br><span class="line">dev-&gt;n_erased_blocks++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若扫到block末尾，则进行相应标记</span></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||  bi-&gt;block_state == YAFFS_BLOCK_STATE_ALLOCATING) &#123;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;seq_number == bi-&gt;seq_number) &#123;</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line">dev-&gt;alloc_block = blk;</span><br><span class="line">dev-&gt;alloc_page = chunk_in_block;</span><br><span class="line">dev-&gt;alloc_block_finder = blk;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从打印可以看出该block之前没有写完整，导致block内seq_number不相同</span></span><br><span class="line">yaffs_trace(YAFFS_TRACE_SCAN,</span><br><span class="line"><span class="string">"Partially written block %d detected. gc will fix this."</span>, blk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dev-&gt;n_free_chunks++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.ecc_result ==</span><br><span class="line">YAFFS_ECC_RESULT_UNFIXED) &#123;</span><br><span class="line"><span class="comment">//出现ECC校验失败</span></span><br><span class="line">                yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">" Unfixed ECC in chunk(%d:%d), chunk ignored"</span>,blk, chunk_in_block);</span><br><span class="line">dev-&gt;n_free_chunks++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.obj_id &gt; YAFFS_MAX_OBJECT_ID ||</span><br><span class="line">   tags.chunk_id &gt; YAFFS_MAX_CHUNK_ID ||</span><br><span class="line">   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||</span><br><span class="line">   (tags.chunk_id &gt; <span class="number">0</span> &amp;&amp;  tags.n_bytes &gt; dev-&gt;data_bytes_per_chunk) || tags.seq_number != bi-&gt;seq_number) &#123;</span><br><span class="line">                <span class="comment">//对一些异常chunk做处理</span></span><br><span class="line">yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored"</span>, blk, chunk_in_block, tags.obj_id, tags.chunk_id, tags.n_bytes);</span><br><span class="line">dev-&gt;n_free_chunks++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//所有的tag标记都正常，则开始进行后续处理</span></span><br><span class="line"><span class="comment">/* chunk_id &gt; 0 so it is a data chunk... */</span></span><br><span class="line"><span class="keyword">loff_t</span> endpos;</span><br><span class="line"><span class="keyword">loff_t</span> chunk_base = (tags.chunk_id - <span class="number">1</span>) *</span><br><span class="line">dev-&gt;data_bytes_per_chunk;</span><br><span class="line"></span><br><span class="line">*found_chunks = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记block中的chunk使用状况</span></span><br><span class="line">yaffs_set_chunk_bit(dev, blk, chunk_in_block);</span><br><span class="line">bi-&gt;pages_in_use++;</span><br><span class="line">        <span class="comment">//找到文件句柄。若没有，表示第一次扫到该文件，创建之</span></span><br><span class="line">in = yaffs_find_or_create_by_number(dev,tags.obj_id, YAFFS_OBJECT_TYPE_FILE);</span><br><span class="line"><span class="keyword">if</span> (!in)  alloc_failed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (in &amp;&amp;  in-&gt;variant_type == YAFFS_OBJECT_TYPE_FILE &amp;&amp;</span><br><span class="line">    chunk_base &lt; in-&gt;variant.file_variant.shrink_size) &#123;</span><br><span class="line"><span class="keyword">if</span> (!yaffs_put_chunk_in_file(in, tags.chunk_id, chunk, <span class="number">-1</span>)) alloc_failed = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将该文件部分加入tnode tree</span></span><br><span class="line">endpos = chunk_base + tags.n_bytes;</span><br><span class="line"><span class="keyword">if</span> (!in-&gt;valid &amp;&amp; in-&gt;variant.file_variant.scanned_size &lt; endpos) &#123;</span><br><span class="line">in-&gt;variant.file_variant.</span><br><span class="line">    scanned_size = endpos;</span><br><span class="line">in-&gt;variant.file_variant.</span><br><span class="line">    file_size = endpos;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (in) &#123;</span><br><span class="line"><span class="comment">//该文件超出了文件shrink大小，表示这是一个被resize过的文件，则删除超出文件大小的部分</span></span><br><span class="line">yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//存放文件头部（chunk id为0）的chunk进行处理</span></span><br><span class="line">*found_chunks = <span class="number">1</span>;</span><br><span class="line">yaffs_set_chunk_bit(dev, blk, chunk_in_block);</span><br><span class="line">bi-&gt;pages_in_use++;</span><br><span class="line">oh = <span class="literal">NULL</span>;</span><br><span class="line">in = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tags.extra_available) &#123;</span><br><span class="line">in = yaffs_find_or_create_by_number(dev,</span><br><span class="line">tags.obj_id,</span><br><span class="line">tags.extra_obj_type);</span><br><span class="line"><span class="keyword">if</span> (!in) alloc_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in || (!in-&gt;valid &amp;&amp; dev-&gt;param.disable_lazy_load) || tags.extra_shadows || (!in-&gt;valid &amp;&amp; (tags.obj_id == YAFFS_OBJECTID_ROOT || tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) &#123;</span><br><span class="line"><span class="comment">//从头部中读取文件信息</span></span><br><span class="line">result = yaffs_rd_chunk_tags_nand(dev, chunk,  chunk_data,  <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//文件头部的信息存放在chunk的数据起始位置</span></span><br><span class="line">oh = (struct yaffs_obj_hdr *)chunk_data;</span><br><span class="line"><span class="comment">//使用Inband tag的特殊处理</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;param.inband_tags) &#123;</span><br><span class="line">oh-&gt;shadows_obj = oh-&gt;inband_shadowed_obj_id;</span><br><span class="line">oh-&gt;is_shrink = oh-&gt;inband_is_shrink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建文件obj</span></span><br><span class="line"><span class="keyword">if</span> (!in) &#123;</span><br><span class="line">in = yaffs_find_or_create_by_number(dev, tags.obj_id, oh-&gt;type);</span><br><span class="line"><span class="keyword">if</span> (!in) alloc_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">..........</span><br><span class="line"><span class="keyword">if</span> (in-&gt;valid) &#123;</span><br><span class="line"><span class="comment">//找到过同一文件。删除该chunk之前进行必要清理工作</span></span><br><span class="line"><span class="keyword">if</span> ((in-&gt;variant_type == YAFFS_OBJECT_TYPE_FILE) &amp;&amp; ((oh &amp;&amp; oh-&gt;type == YAFFS_OBJECT_TYPE_FILE) || (tags.extra_available &amp;&amp;  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE) )) &#123;</span><br><span class="line"><span class="keyword">loff_t</span> this_size = (oh) ? yaffs_oh_to_size(oh) : tags.extra_file_size;</span><br><span class="line">u32 parent_obj_id = (oh) ? oh-&gt;parent_obj_id : tags.extra_parent_id;</span><br><span class="line">is_shrink = (oh) ? oh-&gt;is_shrink : tags.extra_is_shrink;</span><br><span class="line"><span class="comment">//文件的父id若为特殊标记，则文件大小为0</span></span><br><span class="line"><span class="keyword">if</span> (parent_obj_id == AFFS_OBJECTID_DELETED ||parent_obj_id == YAFFS_OBJECTID_UNLINKED) &#123;</span><br><span class="line">this_size = <span class="number">0</span>;</span><br><span class="line">is_shrink = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_shrink &amp;&amp;  in-&gt;variant.file_variant.shrink_size &gt; this_size)</span><br><span class="line">in-&gt;variant.file_variant.shrink_size = this_size;</span><br><span class="line"><span class="keyword">if</span> (is_shrink) bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Use existing - destroy this one. */</span></span><br><span class="line">yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!in-&gt;valid &amp;&amp; in-&gt;variant_type !=</span><br><span class="line">    (oh ? oh-&gt;type : tags.extra_obj_type)) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line"><span class="string">"yaffs tragedy: Bad type, %d != %d, for object %d at chunk %d during scan"</span>,</span><br><span class="line">oh ? oh-&gt;type : tags.extra_obj_type,</span><br><span class="line">in-&gt;variant_type, tags.obj_id,</span><br><span class="line">chunk);</span><br><span class="line">in = yaffs_retype_obj(in, oh ? oh-&gt;type : tags.extra_obj_type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Root目录和lostfound目录处理</span></span><br><span class="line"><span class="keyword">if</span> (!in-&gt;valid &amp;&amp;  (tags.obj_id == YAFFS_OBJECTID_ROOT || tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) &#123;</span><br><span class="line">in-&gt;valid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (oh) &#123;</span><br><span class="line">in-&gt;yst_mode = oh-&gt;yst_mode;</span><br><span class="line">yaffs_load_attribs(in, oh);</span><br><span class="line">in-&gt;lazy_loaded = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">in-&gt;lazy_loaded = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">in-&gt;hdr_chunk = chunk;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!in-&gt;valid) &#123;</span><br><span class="line"><span class="comment">//第一次找到文件头部</span></span><br><span class="line">in-&gt;valid = <span class="number">1</span>;</span><br><span class="line">in-&gt;hdr_chunk = chunk;</span><br><span class="line"><span class="keyword">if</span> (oh) &#123;</span><br><span class="line">in-&gt;variant_type = oh-&gt;type;</span><br><span class="line">in-&gt;yst_mode = oh-&gt;yst_mode;</span><br><span class="line">yaffs_load_attribs(in, oh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oh-&gt;shadows_obj &gt; <span class="number">0</span>) yaffs_handle_shadowed_obj(dev,  oh-&gt;shadows_obj, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">yaffs_set_obj_name_from_oh(in, oh);</span><br><span class="line">parent = yaffs_find_or_create_by_number(dev, oh-&gt;parent_obj_id, YAFFS_OBJECT_TYPE_DIRECTORY);</span><br><span class="line">file_size = yaffs_oh_to_size(oh);</span><br><span class="line">is_shrink = oh-&gt;is_shrink;</span><br><span class="line">equiv_id = oh-&gt;equiv_id;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">in-&gt;variant_type = tags.extra_obj_type;</span><br><span class="line">parent = yaffs_find_or_create_by_number(dev, tags.extra_parent_id, YAFFS_OBJECT_TYPE_DIRECTORY);</span><br><span class="line">file_size = tags.extra_file_size;</span><br><span class="line">is_shrink = tags.extra_is_shrink;</span><br><span class="line">equiv_id = tags.extra_equiv_id;</span><br><span class="line">in-&gt;lazy_loaded = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">in-&gt;dirty = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!parent)</span><br><span class="line">alloc_failed = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp;</span><br><span class="line">    parent-&gt;variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) &#123;</span><br><span class="line">parent-&gt;variant_type =</span><br><span class="line">YAFFS_OBJECT_TYPE_DIRECTORY;</span><br><span class="line">INIT_LIST_HEAD(&amp;parent-&gt;variant.dir_variant.children);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!parent || parent-&gt;variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) &#123;</span><br><span class="line"><span class="comment">//文件若找不到父目录放到lost and found</span></span><br><span class="line">yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line"><span class="string">"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."</span></span><br><span class="line">);</span><br><span class="line">parent = dev-&gt;lost_n_found;</span><br><span class="line">&#125;</span><br><span class="line">yaffs_add_obj_to_dir(parent, in);</span><br><span class="line"></span><br><span class="line">is_unlinked = (parent == dev-&gt;del_dir) || (parent == dev-&gt;unlinked_dir);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_shrink)</span><br><span class="line">bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (in-&gt;variant_type) &#123;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_UNKNOWN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_FILE:</span><br><span class="line">file_var = &amp;in-&gt;variant.file_variant;</span><br><span class="line"><span class="keyword">if</span> (file_var-&gt;scanned_size &lt; file_size) &#123;</span><br><span class="line"><span class="comment">//文件扫到的大小小于文件chunk头部表示的大小</span></span><br><span class="line">file_var-&gt;file_size = file_size;</span><br><span class="line">file_var-&gt;scanned_size = file_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file_var-&gt;shrink_size &gt; file_size)</span><br><span class="line">file_var-&gt;shrink_size = file_size;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_HARDLINK:</span><br><span class="line">hl_var = &amp;in-&gt;variant.hardlink_variant;</span><br><span class="line"><span class="keyword">if</span> (!is_unlinked) &#123;</span><br><span class="line">hl_var-&gt;equiv_id = equiv_id;</span><br><span class="line">list_add(&amp;in-&gt;hard_links, hard_list); &#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_DIRECTORY:</span><br><span class="line"><span class="comment">/* Do nothing */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_SPECIAL:</span><br><span class="line"><span class="comment">/* Do nothing */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> YAFFS_OBJECT_TYPE_SYMLINK:</span><br><span class="line">sl_var = &amp;in-&gt;variant.symlink_variant;</span><br><span class="line"><span class="keyword">if</span> (oh) &#123;</span><br><span class="line">sl_var-&gt;alias =</span><br><span class="line">    yaffs_clone_str(oh-&gt;alias);</span><br><span class="line"><span class="keyword">if</span> (!sl_var-&gt;alias)</span><br><span class="line">alloc_failed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> alloc_failed ? YAFFS_FAIL : YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，就完成了扫描过程。</p><h2 id="Block分配"><a href="#Block分配" class="headerlink" title="Block分配"></a>Block分配</h2><p>执行Block分配一般是由写操作触发的，最后的三个函数调用顺序为yaffs_write_new_chunk–&gt;yaffs_alloc_chunk–&gt;yaffs_find_alloc_block。代码分析如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_write_new_chunk</span><span class="params">(struct yaffs_dev *dev,<span class="keyword">const</span> u8 *data, struct yaffs_ext_tags *tags, <span class="keyword">int</span> use_reserver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//因为写信chunk，表示Flash上内容已经改变了，将Checkpoint的数据设置为无效</span></span><br><span class="line">yaffs2_checkpt_invalidate(dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">......<span class="comment">//分配chunk空间</span></span><br><span class="line">chunk = yaffs_alloc_chunk(dev, use_reserver, &amp;bi);</span><br><span class="line"><span class="keyword">if</span> (chunk &lt; <span class="number">0</span>) &#123;<span class="comment">/* no space */</span><span class="keyword">break</span>;&#125;</span><br><span class="line">attempts++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;param.always_check_erased)</span><br><span class="line">bi-&gt;skip_erased_check = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bi-&gt;skip_erased_check) &#123;</span><br><span class="line"><span class="comment">//确认chunk是否已经擦除</span></span><br><span class="line">erased_ok = yaffs_check_chunk_erased(dev, chunk);</span><br><span class="line"><span class="keyword">if</span> (erased_ok != YAFFS_OK) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line">  <span class="string">"**&gt;\&gt; yaffs chunk %d was not erased"</span>, chunk);</span><br><span class="line"><span class="comment">//如果chunk没有擦除，则删除该chunk，跳到下个可用block寻找chunk</span></span><br><span class="line">yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">yaffs_skip_rest_of_block(dev);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写数据和tag到chunk内</span></span><br><span class="line">write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);</span><br><span class="line"><span class="keyword">if</span> (!bi-&gt;skip_erased_check)</span><br><span class="line">write_ok =  yaffs_verify_chunk_written(dev, chunk, data, tags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (write_ok != YAFFS_OK) &#123;</span><br><span class="line"><span class="comment">//执行写错的回调</span></span><br><span class="line">yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bi-&gt;skip_erased_check = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//执行成功的回调</span></span><br><span class="line">yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (write_ok != YAFFS_OK &amp;&amp; (yaffs_wr_attempts == <span class="number">0</span> || attempts &lt;= yaffs_wr_attempts));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!write_ok) chunk = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (attempts &gt; <span class="number">1</span>) &#123;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_ERROR,<span class="string">"**&gt;&gt; yaffs write required %d attempts"</span>,attempts);</span><br><span class="line">dev-&gt;n_retried_writes += (attempts - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_alloc_chunk</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> use_reserver, struct yaffs_block_info **block_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//若当前无可分配的块，则分配块</span></span><br><span class="line">dev-&gt;alloc_block = yaffs_find_alloc_block(dev);</span><br><span class="line">dev-&gt;alloc_page = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!use_reserver &amp;&amp; !yaffs_check_alloc_available(dev, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">//不使用保留块也找不到可用块</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks &amp;&amp; dev-&gt;alloc_page == <span class="number">0</span>)</span><br><span class="line">yaffs_trace(YAFFS_TRACE_ALLOCATE, <span class="string">"Allocating reserve"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">bi = yaffs_get_block_info(dev, dev-&gt;alloc_block);</span><br><span class="line">ret_val = (dev-&gt;alloc_block * dev-&gt;param.chunks_per_block) +dev-&gt;alloc_page;</span><br><span class="line">bi-&gt;pages_in_use++;</span><br><span class="line">yaffs_set_chunk_bit(dev, dev-&gt;alloc_block, dev-&gt;alloc_page);</span><br><span class="line">dev-&gt;alloc_page++;</span><br><span class="line">dev-&gt;n_free_chunks--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若块已满，则标记状态为已满</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_page &gt;= dev-&gt;param.chunks_per_block) &#123;</span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">dev-&gt;alloc_block = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (block_ptr)</span><br><span class="line">*block_ptr = bi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line"><span class="string">"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_find_alloc_block</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span>;</span></span><br><span class="line"><span class="comment">//没有可使用的块则返回-1</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        yaffs_trace(YAFFS_TRACE_ERROR,<span class="string">"yaffs tragedy: no more erased blocks"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，遍历找到一个可使用的块</span></span><br><span class="line"><span class="keyword">for</span> (i = dev-&gt;internal_start_block; i &lt;= dev-&gt;internal_end_block; i++) &#123;</span><br><span class="line">dev-&gt;alloc_block_finder++;</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;alloc_block_finder &lt; (<span class="keyword">int</span>)dev-&gt;internal_start_block || dev-&gt;alloc_block_finder &gt; (<span class="keyword">int</span>)dev-&gt;internal_end_block) &#123;</span><br><span class="line">dev-&gt;alloc_block_finder = dev-&gt;internal_start_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bi = yaffs_get_block_info(dev, dev-&gt;alloc_block_finder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line"><span class="comment">//找到块的条件是该块的状态为EMPTY，此时返回块的编号</span></span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line">dev-&gt;seq_number++;</span><br><span class="line">bi-&gt;seq_number = dev-&gt;seq_number;</span><br><span class="line">dev-&gt;n_erased_blocks--;</span><br><span class="line">yaffs_trace(YAFFS_TRACE_ALLOCATE,</span><br><span class="line">  <span class="string">"Allocated block %d, seq  %d, %d left"</span> ,</span><br><span class="line">   dev-&gt;alloc_block_finder, dev-&gt;seq_number,</span><br><span class="line">   dev-&gt;n_erased_blocks);</span><br><span class="line"><span class="keyword">return</span> dev-&gt;alloc_block_finder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yaffs_trace(YAFFS_TRACE_ALWAYS,<span class="string">"yaffs tragedy: no more erased blocks, but there should have been %d"</span>,dev-&gt;n_erased_blocks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Block擦除"><a href="#Block擦除" class="headerlink" title="Block擦除"></a>Block擦除</h2><p>Block擦除的条件是：</p><ul><li>遇到坏块，且无法正确执行坏块标记</li><li>脏数据回收</li><li>上层下Format Flash指令</li></ul><p>其中脏数据回收是GC（Garbage Collection）机制在执行，后续章节会再对GC进行介绍。</p><p>擦除块执行的函数也很简单，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_erase_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">block_no -= dev-&gt;block_offset;</span><br><span class="line">dev-&gt;n_erasures++;</span><br><span class="line">result = dev-&gt;drv.drv_erase_fn(dev, block_no);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中drv_erase_fn回调函数在Linux的系统下最后MTD块系统的mtd_erase函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nandmtd_erase_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">mtd</span> = <span class="title">yaffs_dev_to_mtd</span>(<span class="title">dev</span>);</span></span><br><span class="line">u32 addr = ((<span class="keyword">loff_t</span>) block_no) * dev-&gt;param.total_bytes_per_chunk *dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">erase_info</span> <span class="title">ei</span>;</span></span><br><span class="line"><span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">........</span><br><span class="line">retval = mtd_erase(mtd, &amp;ei);</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">if</span> (retval == <span class="number">0</span>)<span class="keyword">return</span> YAFFS_OK;</span><br><span class="line"><span class="keyword">return</span> YAFFS_FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，块初始化及管理大致过程分析结束，下一章节介绍Checkpoint机制</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://l2h.site/2019/04/30/yaffs-1/&quot;&gt;Yaffs文件系统(1)-概述&lt;/a&gt;对文件系统的基本数据结构和初始化流程进行了介绍，本节着重介绍Yaffs如何对Block和Chunk进行管理的。&lt;/p&gt;&lt;h2 id=&quot;Block分类&quot;&gt;&lt;a href=&quot;#Block分类&quot; class=&quot;headerlink&quot; title=&quot;Block分类&quot;&gt;&lt;/a&gt;Block分类&lt;/h2&gt;&lt;p&gt;UNKNOWN&lt;/p&gt;&lt;p&gt;区块状态未知&lt;/p&gt;&lt;p&gt;NEEDS_SCANNING&lt;/p&gt;&lt;p&gt;预扫描时确定该Block需要被扫描&lt;/p&gt;&lt;p&gt;SCANNING&lt;/p&gt;&lt;p&gt;Block正在扫描&lt;/p&gt;&lt;p&gt;EMPTY&lt;/p&gt;&lt;p&gt;Block为空，表示已经被擦除&lt;/p&gt;&lt;p&gt;ALLOCATING&lt;/p&gt;&lt;p&gt;Block被Chunk分配器使用中&lt;/p&gt;&lt;p&gt;FULL&lt;/p&gt;&lt;p&gt;Block已经分配，且至少有一个chunk被删除&lt;/p&gt;&lt;p&gt;DIRTY&lt;/p&gt;&lt;p&gt;Block全部chunk被删可被擦除&lt;/p&gt;&lt;p&gt;CHECKPOINT&lt;/p&gt;&lt;p&gt;Block中包含checkpoint数据&lt;/p&gt;&lt;p&gt;COLLECTING&lt;/p&gt;&lt;p&gt;Block正在被做垃圾回收&lt;/p&gt;&lt;p&gt;DEAD&lt;/p&gt;&lt;p&gt;Block为坏块&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux文件系统" scheme="http://l2h.site/categories/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="YAFFS" scheme="http://l2h.site/tags/YAFFS/"/>
    
      <category term="文件系统" scheme="http://l2h.site/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
