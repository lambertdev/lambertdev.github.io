<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L&amp;H SITE</title>
  
  <subtitle>两个背包旅行者的网络自留地。分享旅行日记，Linux技术，机器学习，建站技巧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://l2h.site/"/>
  <updated>2020-08-23T05:00:44.000Z</updated>
  <id>http://l2h.site/</id>
  
  <author>
    <name>Lambert</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在家办公记</title>
    <link href="http://l2h.site/2020/02/02/20200202/"/>
    <id>http://l2h.site/2020/02/02/20200202/</id>
    <published>2020-02-02T08:34:10.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是20200202，难得的日期对称日，有必要记上一篇。</p><p>四川省最后还是刚起，仅仅发了一个不痛不痒的通知说企业可自行安排复工时间，成为遵守国务院命令2月3日准时上班的唯一一个省份。</p><p><img src="https://l2h.site/images/posts/20200202/1.jpeg" alt="全国开复工时间表"></p><p>看着最新的疫情地图，加上查到的1600多万的成都人口，心理慌得不要不要的。料医学博士的省长也没办法抑制得了新病毒的传播，希望成都不要学武汉的各种神操作。幸好公司人性化，允许在家办公。</p><a id="more"></a><p><img src="https://l2h.site/images/posts/20200202/2.png" alt="疫情地图"></p><p>仔细想想，如果可以解决公司信息泄露问题，IT行业在家办公其实挺好的。最起码有以下几点优势：</p><ul><li>节省时间（各种通勤时间）</li><li>对企业来讲节省各种水电物业等开销。</li><li>居家环境，压力更小，做事效率应也会更高。</li></ul><p>明天先这样工作第一天试试看，如果可行，强烈建议公司在疫情结束后也继续推广！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是20200202，难得的日期对称日，有必要记上一篇。&lt;/p&gt;&lt;p&gt;四川省最后还是刚起，仅仅发了一个不痛不痒的通知说企业可自行安排复工时间，成为遵守国务院命令2月3日准时上班的唯一一个省份。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://l2h.site/images/posts/20200202/1.jpeg&quot; alt=&quot;全国开复工时间表&quot;&gt;&lt;/p&gt;&lt;p&gt;看着最新的疫情地图，加上查到的1600多万的成都人口，心理慌得不要不要的。料医学博士的省长也没办法抑制得了新病毒的传播，希望成都不要学武汉的各种神操作。幸好公司人性化，允许在家办公。&lt;/p&gt;
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>新SARS</title>
    <link href="http://l2h.site/2020/01/23/new-sars-virus/"/>
    <id>http://l2h.site/2020/01/23/new-sars-virus/</id>
    <published>2020-01-23T06:16:33.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>人类自以为是世界的主宰，实则不然。2020新年伊始，新冠状病毒从武汉开始蔓延。</p><p>强大的传染力，加上春节的人口流动速率，病毒感染的人口可能远非官方所报道那么多。</p><p>想起2013年的SARS，我高三，生活在小县城也能深切感受到这传染病的威力。<br>每天早读几个温度计班里传递量体温，诊所里板蓝根早早卖断货。<br>晚上自习新闻时间打开电视随时关心病情进展，看到又是几个全身防护的医务人员感染甚至病逝的消息。</p><a id="more"></a><p>目前能做的，就是相信国家，好好待在家里，不出去添乱。希望大家一切都好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人类自以为是世界的主宰，实则不然。2020新年伊始，新冠状病毒从武汉开始蔓延。&lt;/p&gt;&lt;p&gt;强大的传染力，加上春节的人口流动速率，病毒感染的人口可能远非官方所报道那么多。&lt;/p&gt;&lt;p&gt;想起2013年的SARS，我高三，生活在小县城也能深切感受到这传染病的威力。&lt;br&gt;每天早读几个温度计班里传递量体温，诊所里板蓝根早早卖断货。&lt;br&gt;晚上自习新闻时间打开电视随时关心病情进展，看到又是几个全身防护的医务人员感染甚至病逝的消息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
      <category term="L&amp;amp;H随感" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/L-amp-H%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="SARS" scheme="http://l2h.site/tags/SARS/"/>
    
      <category term="冠状病毒" scheme="http://l2h.site/tags/%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92/"/>
    
  </entry>
  
  <entry>
    <title>小米手表使用ADB安装应用</title>
    <link href="http://l2h.site/2019/12/01/Mi-Watch-Install-By-ADB/"/>
    <id>http://l2h.site/2019/12/01/Mi-Watch-Install-By-ADB/</id>
    <published>2019-12-01T02:48:35.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想入手一个智能手表，可惜Apple Watch需要连接苹果手机，遂未能如愿。最近小米终于发布一款智能手表，支持ESIM，使用Wear OS，果断入手。  </p><p>实际使用发现Bug不少，软件不多。Bug可以等系统更新来解决。不过软件不多是生态链的问题，等生态链慢慢建起来实在太慢。Wear OS是Android的一个分支，理论上应该支持安装安卓应用才对。翻了下小米手表的设置，也是有看到可以做ADB调试，因此理应可以用ADB安装Android应用。  </p><a id="more"></a><p>步骤：</p><ol><li>电脑上安装ADB（可根据您自己的电脑系统自行百度安装方法）</li><li>手表上“设置–开发者选项”，打开ADB调试。如图：<br><img src="http://pic.l2h.site/xiaomiwatch1.jpg" alt="开启ADB调试"></li><li>将手表连上充电底座，并将USB连接电源插头端直接连上电脑。如图：<br><img src="http://pic.l2h.site/xiaomiwatch2.jpg" alt="连接电脑"></li><li>连上电脑后，手表弹出“是否允许调试”选择框。直接选择允许或者始终允许。<br><img src="http://pic.l2h.site/xiaomiwatch3.jpg" alt="允许调试"></li><li>电脑端执行ADB Install安装应用,待显示成功，便安装完成。例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install qqmail_android_5.7.1.10141908.2480_0.apk</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>手表内存小，APK程序越大，其所需的内存越大。因此尽量选择程序本身小于10MB的程序</li><li>大部分APP并未针对小屏幕做优化，目前提供方法和思路供试用。如上例子QQMAIL安装后就因其无法支持手表屏幕大小，因此无法做有效操作。</li></ol><p>最后，收集可支持手表的应用如下：</p><table><thead><tr><th>应用</th><th>版本</th><th>APK下载链接</th></tr></thead></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想入手一个智能手表，可惜Apple Watch需要连接苹果手机，遂未能如愿。最近小米终于发布一款智能手表，支持ESIM，使用Wear OS，果断入手。  &lt;/p&gt;&lt;p&gt;实际使用发现Bug不少，软件不多。Bug可以等系统更新来解决。不过软件不多是生态链的问题，等生态链慢慢建起来实在太慢。Wear OS是Android的一个分支，理论上应该支持安装安卓应用才对。翻了下小米手表的设置，也是有看到可以做ADB调试，因此理应可以用ADB安装Android应用。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="小米手表" scheme="http://l2h.site/tags/%E5%B0%8F%E7%B1%B3%E6%89%8B%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Zephyr线程管理 - 数据结构与API</title>
    <link href="http://l2h.site/2019/11/16/20191117-Zephyr-Thread-2/"/>
    <id>http://l2h.site/2019/11/16/20191117-Zephyr-Thread-2/</id>
    <published>2019-11-16T14:16:35.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍和Zephyr线程的数据结构，及相应的API。  </p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Zephyr数据结构使用k_thread定义，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_base</span> <span class="title">base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">callee_saved</span> <span class="title">callee_saved</span>;</span></span><br><span class="line"><span class="keyword">void</span> *init_data;</span><br><span class="line"><span class="keyword">void</span> (*fn_abort)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_MONITOR)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">thread_entry</span> <span class="title">entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">next_thread</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_NAME)</span></span><br><span class="line"><span class="keyword">char</span> name[CONFIG_THREAD_MAX_NAME_LEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_CUSTOM_DATA</span></span><br><span class="line"><span class="keyword">void</span> *custom_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_USERSPACE_LOCAL_DATA</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_userspace_local_data</span> *<span class="title">userspace_local_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ERRNO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_USERSPACE</span></span><br><span class="line"><span class="keyword">int</span> errno_var;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_STACK_INFO)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_stack_info</span> <span class="title">stack_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_THREAD_STACK_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USERSPACE)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">mem_domain_info</span> <span class="title">mem_domain_info</span>;</span></span><br><span class="line"><span class="keyword">k_thread_stack_t</span> *stack_obj;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_USERSPACE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USE_SWITCH)</span></span><br><span class="line"><span class="keyword">int</span> swap_retval;</span><br><span class="line"><span class="keyword">void</span> *switch_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_mem_pool</span> *<span class="title">resource_pool</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_arch</span> <span class="title">arch</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>参数说明：</p><ul><li><strong>base</strong>： 存储Thread的基础调度信息结构体。具体如下：<ul><li><strong>qnode_dlist/qnode_rb</strong>: 指向线程在等待/就绪队列的位置</li><li><strong>pended_on</strong>:指向线程所在的等待队列（仅对红黑树等待队列有效）</li><li><strong>user_options</strong>:线程参数</li><li><strong>thread_state</strong>:线程状态</li><li><strong>union(prio/sched_locked/preemt)</strong>: 线程的抢占优先级相关参数</li><li><strong>order_key</strong>:被调度器使用来比对优先级</li><li>SMP相关参数先忽略</li><li><strong>timeout</strong>:指向超时队列中该线程的位置</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_base</span> &#123;</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">sys_dnode_t</span> qnode_dlist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rbnode</span> <span class="title">qnode_rb</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">_wait_q_t</span> *pended_on;</span><br><span class="line"><span class="keyword">u8_t</span> user_options;</span><br><span class="line"><span class="keyword">u8_t</span> thread_state;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line"><span class="keyword">u8_t</span> sched_locked;</span><br><span class="line"><span class="keyword">s8_t</span> prio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* LITTLE and PDP */</span></span></span><br><span class="line"><span class="keyword">s8_t</span> prio;</span><br><span class="line"><span class="keyword">u8_t</span> sched_locked;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">u16_t</span> preempt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEADLINE</span></span><br><span class="line"><span class="keyword">int</span> prio_deadline;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">u32_t</span> order_key;</span><br><span class="line"><span class="comment">/*SMP 相关*/</span></span><br><span class="line"><span class="keyword">void</span> *swap_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_CLOCK_EXISTS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">timeout</span> <span class="title">timeout</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>_callee_saved</strong>: 与平台相关的一些参数，主要保存一些线程相关寄存器信息。</li><li><strong>init_data</strong>: 线程静态初始化数据</li><li><strong>fn_abort</strong>: 线程取消回调函数</li><li><strong>entry</strong>:Thread入口函数</li><li><strong>next_thread</strong>: Thread链表中下一个线程指针</li><li><strong>name</strong>: Thread名称</li><li><strong>custom_data</strong>: Thread自定义数据</li><li><strong>userspace_local_data</strong>:用户空间态数据</li><li><strong>errno_var</strong>: 错误编号（类似Linux的Errno）</li><li><strong>stack_info</strong>: 栈信息，主要记录栈的开始地址与大小</li><li><strong>mem_domain_info</strong>: 线程内存域信息（用户空间态线程使用）</li><li><strong>stack_obj</strong>: 线程栈地址</li><li><strong>swap_retval</strong>: TBD</li><li><strong>switch_handle</strong>: TBD</li><li><strong>resource_pool</strong>:线程所占用的资源池</li><li><strong>arch</strong>: 体系结构相关的线程数据。因为体系结构不同，所占大小也不相同，为保证其他参数的位置相同，Zephyr将此参数置于线程末尾</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Zephyr定义了一系列的API来使用线程：</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>线程创建的函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">K_THREAD_DEFINE(my_tid, MY_STACK_SIZE, my_entry_point, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MY_PRIORITY, <span class="number">0</span>, K_NO_WAIT);</span><br><span class="line"><span class="keyword">k_tid_t</span> k_thread_create(structk_thread *new_thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>, <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry, <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3, <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">s32_t</span> delay)</span><br></pre></td></tr></table></figure><p>前者主要用于静态定义线程，而后者主要用于运行时创建线程。线程的静态定义主要就是定义如下结构体（参数明确，不做一一解释）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">static_thread_data</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">init_thread</span>;</span></span><br><span class="line"><span class="keyword">k_thread_stack_t</span> *init_stack;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> init_stack_size;</span><br><span class="line"><span class="keyword">k_thread_entry_t</span> init_entry;</span><br><span class="line"><span class="keyword">void</span> *init_p1;</span><br><span class="line"><span class="keyword">void</span> *init_p2;</span><br><span class="line"><span class="keyword">void</span> *init_p3;</span><br><span class="line"><span class="keyword">int</span> init_prio;</span><br><span class="line"><span class="keyword">u32_t</span> init_options;</span><br><span class="line"><span class="keyword">s32_t</span> init_delay;</span><br><span class="line"><span class="keyword">void</span> (*init_abort)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *init_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>k_thread_create的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">k_tid_t</span> z_impl_k_thread_create(struct k_thread *new_thread,      <span class="comment">//代码注解1</span></span><br><span class="line">      <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>,</span><br><span class="line">      <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry,</span><br><span class="line">      <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3,</span><br><span class="line">      <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">s32_t</span> delay)</span><br><span class="line">&#123;</span><br><span class="line">__ASSERT(!z_arch_is_in_isr(), <span class="string">"Threads may not be created in ISRs"</span>); <span class="comment">//代码注解2</span></span><br><span class="line"></span><br><span class="line">z_setup_new_thread(new_thread, <span class="built_in">stack</span>, stack_size, entry, p1, p2, p3, prio, options, <span class="literal">NULL</span>); <span class="comment">//代码注解3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (delay != K_FOREVER) &#123;</span><br><span class="line">schedule_new_thread(new_thread, delay);  <span class="comment">//代码注解4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> new_thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>代码注解1</strong>： 这里函数名为何是z_impl_k_thread_create而不是k_thread_create。因为Zephyr在编译时使用了脚本来生成系统中API调用。所以在搜索源码时大部分时间只能搜索到z_impl_xxx形式的系统函数定义。不过编译连接前，是可以看得到不带<em>z_impl_</em>形式的API，最终调用的即是z_impl_k_thread_create</li><li><strong>代码注解2</strong>：中断上下文不能创建线程，因为创建线程会需要申请系统资源，也会引起重新调度，带来不可预料的后果</li><li><strong>代码注解3</strong>：创建新线程</li><li><strong>代码注解4</strong>：将线程加入调度</li></ul><p>z_setup_new_thread定义如下(为方便分析，代码做一定简化)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_setup_new_thread</span><span class="params">(struct k_thread *new_thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>, <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry, <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3, <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack_size = adjust_stack_size(stack_size); <span class="comment">//代码注解1</span></span><br><span class="line"></span><br><span class="line">z_arch_new_thread(new_thread, <span class="built_in">stack</span>, stack_size, entry, p1, p2, p3, prio, options); <span class="comment">//代码注解2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_MONITOR</span></span><br><span class="line">new_thread-&gt;entry.pEntry = entry;</span><br><span class="line">new_thread-&gt;entry.parameter1 = p1;</span><br><span class="line">new_thread-&gt;entry.parameter2 = p2;</span><br><span class="line">new_thread-&gt;entry.parameter3 = p3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">new_thread-&gt;next_thread = _kernel.threads;</span><br><span class="line">_kernel.threads = new_thread;</span><br><span class="line">k_spin_unlock(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_NAME</span></span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">strncpy</span>(new_thread-&gt;name, name,</span><br><span class="line">CONFIG_THREAD_MAX_NAME_LEN - <span class="number">1</span>);</span><br><span class="line">new_thread-&gt;name[CONFIG_THREAD_MAX_NAME_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">//代码注解4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN</span></span><br><span class="line"><span class="keyword">if</span> (!_current) &#123;</span><br><span class="line">new_thread-&gt;resource_pool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">new_thread-&gt;resource_pool = _current-&gt;resource_pool; <span class="comment">//代码注解5</span></span><br><span class="line">sys_trace_thread_create(new_thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码注解1</strong>: 修正栈大小，主要为线程栈地址随机化功能使用（算是简单的地址随机化方案，感兴趣大家可以搜索一下ASLR相关资料），目的为的是防止破解攻击</li><li><strong>代码注解2</strong>: 执行体系结构相关的线程创建过程（本文接下来以ARM Cortex-M为例介绍）</li><li><strong>代码注解3/代码注解4</strong>: 线程一些公共参数的初始化，用于系统监视器监视线程状态。</li><li><strong>代码注解5</strong>: 继承父线程的资源池。</li></ul><p>其中z_arch_new_thread代码如下(省去部分代码)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_arch_new_thread</span><span class="params">(struct k_thread *thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>,  <span class="keyword">size_t</span> stackSize, <span class="keyword">k_thread_entry_t</span> pEntry,  <span class="keyword">void</span> *parameter1, <span class="keyword">void</span> *parameter2, <span class="keyword">void</span> *parameter3, <span class="keyword">int</span> priority, <span class="keyword">unsigned</span> <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *pStackMem = Z_THREAD_STACK_BUFFER(<span class="built_in">stack</span>);</span><br><span class="line"><span class="keyword">char</span> *stackEnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">u32_t</span> top_of_stack_offset = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">Z_ASSERT_VALID_PRIO(priority, pEntry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT) \</span></span><br><span class="line">&amp;&amp; defined(CONFIG_USERSPACE)</span><br><span class="line">stackSize -= MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FLOAT) &amp;&amp; defined(CONFIG_FP_SHARING) \</span></span><br><span class="line">&amp;&amp; defined(CONFIG_MPU_STACK_GUARD)</span><br><span class="line"><span class="keyword">if</span> ((options &amp; K_FP_REGS) != <span class="number">0</span>) &#123;</span><br><span class="line">pStackMem += MPU_GUARD_ALIGN_AND_SIZE_FLOAT</span><br><span class="line">- MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line">stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT</span><br><span class="line">- MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">stackEnd = pStackMem + stackSize;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">esf</span> *<span class="title">pInitCtx</span>;</span></span><br><span class="line"></span><br><span class="line">z_new_thread_init(thread, pStackMem, stackSize, priority,  options);</span><br><span class="line"></span><br><span class="line">pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -</span><br><span class="line">(<span class="keyword">char</span> *)top_of_stack_offset - <span class="keyword">sizeof</span>(struct __basic_sf)));</span><br><span class="line">        </span><br><span class="line">pInitCtx-&gt;basic.pc = (<span class="keyword">u32_t</span>)z_thread_entry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CPU_CORTEX_M)</span></span><br><span class="line">pInitCtx-&gt;basic.pc &amp;= <span class="number">0xfffffffe</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">pInitCtx-&gt;basic.a1 = (<span class="keyword">u32_t</span>)pEntry;</span><br><span class="line">pInitCtx-&gt;basic.a2 = (<span class="keyword">u32_t</span>)parameter1;</span><br><span class="line">pInitCtx-&gt;basic.a3 = (<span class="keyword">u32_t</span>)parameter2;</span><br><span class="line">pInitCtx-&gt;basic.a4 = (<span class="keyword">u32_t</span>)parameter3;</span><br><span class="line">pInitCtx-&gt;basic.xpsr = <span class="number">0x01000000</span>UL; </span><br><span class="line"></span><br><span class="line">thread-&gt;callee_saved.psp = (<span class="keyword">u32_t</span>)pInitCtx;</span><br><span class="line">thread-&gt;arch.basepri = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USERSPACE) || defined(CONFIG_FP_SHARING)</span></span><br><span class="line">thread-&gt;arch.mode = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">void</span> <span class="title">z_new_thread_init</span><span class="params">(struct k_thread *thread, <span class="keyword">char</span> *pStack, <span class="keyword">size_t</span> stackSize, <span class="keyword">int</span> prio, <span class="keyword">unsigned</span> <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INIT_STACKS</span></span><br><span class="line"><span class="built_in">memset</span>(pStack, <span class="number">0xaa</span>, stackSize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_SENTINEL</span></span><br><span class="line">*((<span class="keyword">u32_t</span> *)pStack) = STACK_SENTINEL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_STACK_SENTINEL */</span></span></span><br><span class="line">z_init_thread_base(&amp;thread-&gt;base, prio, _THREAD_PRESTART, options);</span><br><span class="line">thread-&gt;init_data = <span class="literal">NULL</span>;</span><br><span class="line">thread-&gt;fn_abort = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_CUSTOM_DATA</span></span><br><span class="line">thread-&gt;custom_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_NAME</span></span><br><span class="line">thread-&gt;name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_STACK_INFO)</span></span><br><span class="line">thread-&gt;stack_info.start = (<span class="keyword">uintptr_t</span>)pStack;</span><br><span class="line">thread-&gt;stack_info.size = (<span class="keyword">u32_t</span>)stackSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_THREAD_STACK_INFO */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上初始化过程执行后，线程的栈空间如图所示：</p><p><img src="http://pic.l2h.site/QQMail_0.png" alt="http://pic.l2h.site/QQMail_0.png"></p><p>以上为线程的初始化过程</p><h3 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h3><p>线程开始执行调用<em>z_impl_k_thread_start</em>函数。该函数也会被k_thread_create–&gt;schedule_new_thread间接调用，其源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_start</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (z_has_thread_started(thread)) &#123;</span><br><span class="line">k_spin_unlock(&amp;lock, key);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z_mark_thread_as_started(thread); <span class="comment">//代码注解1</span></span><br><span class="line">z_ready_thread(thread);  <span class="comment">//代码注解2</span></span><br><span class="line">z_reschedule(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码注解1</strong>：仅仅将thread_state标记上_THREAD_PRESTART  </li><li><strong>代码注解2</strong>：将Thread加入调度的ready Q，关于线程调度之后文章进行介绍</li><li><strong>代码注解3</strong>：调用系统的reschedule函数触发系统调度。对Cortex-M3来讲，将会调用系统的PENDSV系统指令，悬起系统切换异常。下图为引用自《Cortex-M3权威指南》的一张PendSV使用的示例：</li></ul><p><img src="http://pic.l2h.site/PendSV.png" alt="PendSV"></p><h3 id="线程挂起"><a href="#线程挂起" class="headerlink" title="线程挂起"></a>线程挂起</h3><p>线程挂起使用<em>z_impl_k_thread_suspend</em>，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_suspend</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock);</span><br><span class="line">z_thread_single_suspend(thread);</span><br><span class="line">sys_trace_thread_suspend(thread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread == _current) &#123;</span><br><span class="line">z_reschedule(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k_spin_unlock(&amp;lock, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_thread_single_suspend</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (z_is_thread_ready(thread)) &#123;</span><br><span class="line">z_remove_thread_from_ready_q(thread); <span class="comment">//代码注解1</span></span><br><span class="line">&#125;</span><br><span class="line">z_mark_thread_as_suspended(thread); <span class="comment">//代码注解2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码注解3</strong>：若该线程正在运行，调用reschedule重新调度</li><li><strong>代码注解1</strong>：将Thread从调度的ready Q移除</li><li><strong>代码注解2</strong>：对线程状态做挂起标记</li></ul><h3 id="线程继续（resume）"><a href="#线程继续（resume）" class="headerlink" title="线程继续（resume）"></a>线程继续（resume）</h3><p>线程Resume仅做线程的标记，不再进行分析</p><h3 id="线程取消（Abort）"><a href="#线程取消（Abort）" class="headerlink" title="线程取消（Abort）"></a>线程取消（Abort）</h3><p>线程取消使用API <em>z_impl_k_thread_abort</em>,代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_abort</span><span class="params">(<span class="keyword">k_tid_t</span> thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">key = irq_lock();</span><br><span class="line">__ASSERT(!(thread-&gt;base.user_options &amp; K_ESSENTIAL),</span><br><span class="line"> <span class="string">"essential thread aborted"</span>);</span><br><span class="line"></span><br><span class="line">z_thread_single_abort(thread);</span><br><span class="line">z_thread_monitor_exit(thread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_current == thread) &#123;</span><br><span class="line"><span class="keyword">if</span> ((SCB-&gt;ICSR &amp; SCB_ICSR_VECTACTIVE_Msk) == <span class="number">0</span>) &#123;</span><br><span class="line">(<span class="keyword">void</span>)z_swap_irqlock(key);</span><br><span class="line">CODE_UNREACHABLE;   <span class="comment">//代码注解7</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk; <span class="comment">//代码注解7</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">z_reschedule_irqlock(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_thread_single_abort</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (thread-&gt;fn_abort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">thread-&gt;fn_abort();     <span class="comment">//代码注解1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SMP)) &#123;</span><br><span class="line">z_sched_abort(thread);  <span class="comment">//代码注解2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (z_is_thread_ready(thread)) &#123;</span><br><span class="line">z_remove_thread_from_ready_q(thread); <span class="comment">//代码注解3</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (z_is_thread_pending(thread)) &#123;</span><br><span class="line">z_unpend_thread_no_timeout(thread); <span class="comment">//代码注解4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (z_is_thread_timeout_active(thread)) &#123;</span><br><span class="line">(<span class="keyword">void</span>)z_abort_thread_timeout(thread); <span class="comment">//代码注解5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">thread-&gt;base.thread_state |= _THREAD_DEAD; <span class="comment">//代码注解6</span></span><br><span class="line">sys_trace_thread_abort(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>代码注解1</strong>：先执行该线程的退出回调函数（供应用程序做特殊处理）</li><li><strong>代码注解2</strong>：SMP相关通知，此处不做深入分析</li><li><strong>代码注解3</strong>：将Thread从调度的ready Q移除</li><li><strong>代码注解4</strong>：将Thread从Pending Q也移除</li><li><strong>代码注解5</strong>：若Thread正在等待一定超时后调度，也将其从超时列表中移除</li><li><strong>代码注解6</strong>：对线程状态做死亡（Dead）标记</li><li><strong>代码注解7</strong>：待添加</li><li><strong>代码注解8</strong>：置起PendSV，进行重新调度</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上为线程使用相关结构体、API及对应的分析。可以看出，线程相关函数的实现足够简洁明了，这也正应了Zephyr的设计思想。有任何问题，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍和Zephyr线程的数据结构，及相应的API。  &lt;/p&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;p&gt;Zephyr数据结构使用k_thread定义，如下所示：&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;k_thread&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;thread_base&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;base&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;callee_saved&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callee_saved&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *init_data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*fn_abort)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(CONFIG_THREAD_MONITOR)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;thread_entry&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;entry&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;k_thread&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;next_thread&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(CONFIG_THREAD_NAME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; name[CONFIG_THREAD_MAX_NAME_LEN];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; CONFIG_THREAD_CUSTOM_DATA&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *custom_data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; CONFIG_THREAD_USERSPACE_LOCAL_DATA&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;thread_userspace_local_data&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;userspace_local_data&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt; CONFIG_ERRNO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt; CONFIG_USERSPACE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; errno_var;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(CONFIG_THREAD_STACK_INFO)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;thread_stack_info&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stack_info&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* CONFIG_THREAD_STACK_INFO */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(CONFIG_USERSPACE)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;mem_domain_info&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mem_domain_info&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;k_thread_stack_t&lt;/span&gt; *stack_obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* CONFIG_USERSPACE */&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(CONFIG_USE_SWITCH)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; swap_retval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *switch_handle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;k_mem_pool&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;resource_pool&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;thread_arch&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;arch&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="RTOS" scheme="http://l2h.site/categories/RTOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Zephyr线程管理 - 概念</title>
    <link href="http://l2h.site/2019/11/16/20191106-Zephyr-Thread/"/>
    <id>http://l2h.site/2019/11/16/20191106-Zephyr-Thread/</id>
    <published>2019-11-16T12:56:38.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想写一些RTOS的技术资料，算作对自己之前一些相关技术调研的总结。无奈懒癌发作，一拖再拖。然今日灌上鸡血，笃定主意，从最基本的调度相关内容开始。  </p><p>简单讲，Zephyr是一个开源实时操作系统。相较Linux，其对系统资源的使用量更小，当然也牺牲了许多复杂且完善的功能（如，系统Debug易用性，线程的堆栈保护）。与此同时，因其是开源社区开发，也多少继承和保留了许多Linux系统的优秀思想和功能（例如，Workqueue、设备树等）。其定位为万物互联时代各种各样的嵌入式设备，目光长远。</p><a id="more"></a><p>Zephyr里没有管程、进程、线程之分。除了中断响应例程，其余所有可执行调度单位皆是线程。系统中应用程序可以定义一个或者多个线程，这种情况下，每个线程也都有自己独立的调度信息和线程ID。</p><p>虽然也有区分用户空间和内核空间态，Zephyr线程却没有自己独立的地址转换表，皆使用相同的地址空间，这是由Zephyr的内存管理方式决定的。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程状态即转换关系如下图所示：<br><img src="https://docs.zephyrproject.org/latest/_images/thread_states.svg" alt="https://docs.zephyrproject.org/latest/_images/thread_states.svg"><br>可以看出，线程分为如下状态：  </p><ul><li>New：表示线程新创建</li><li>Ready: 线程就绪状态</li><li>Waiting: 线程等待某种IO资源</li><li>Running: 线程执行中</li><li>Suspended: 线程挂起状态，非等待资源原因被停止执行</li><li>Terminated: 线程退出</li></ul><p>以上线程状态转换关系见图，后续进行代码分析将进一步介绍。</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程的优先级使用数字表示，数字越小，线程的优先级越高。Zephyr系统的线程可以分为两类:  </p><ul><li>Cooperative线程：一旦开始执行，除非中断或者线程自行让出CPU，将会一直执行</li><li>可抢占线程: 普通线程，可被更高优先级的线程抢占执行</li></ul><p>Zephyr默认给Cooperative线程分配小于0的优先级数值，而可抢占线程分配为正值。用户可修改编译选项来更改这两种线程的优先级区间，当然要保证Cooperative线程的优先级数值区间小于可抢占线程。线程运行过程中，其优先级可以被更改。一张图表示线程优先级关系：</p><p><img src="https://docs.zephyrproject.org/latest/_images/priorities.svg" alt="https://docs.zephyrproject.org/latest/_images/priorities.svg"></p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程有一列属性，根据这些不同的属性，线程的执行方式也会有相应的差异。一些主要的属性如下:  </p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>K_ESSENTIAL</td><td>表示线程是核心线程，该类线程若有退出或者取消是系统不允许的，系统会断言严重错误</td></tr><tr><td>K_SSE_REGS</td><td>X86独有属性，表示是否使用CPU的SSE功能</td></tr><tr><td>K_FP_REGS</td><td>表示是否使用CPU的浮点计算寄存器</td></tr><tr><td>K_USER</td><td>表示用户空间态线程，只有当系统编译选项CONFIG_USERSPACE打开时才有效</td></tr><tr><td>K_INHERIT_PERMS</td><td>对USERSPACE线程有效，表示是否继承父进程的权限属性</td></tr></tbody></table><h2 id="线程自定义数据"><a href="#线程自定义数据" class="headerlink" title="线程自定义数据"></a>线程自定义数据</h2><p>线程可以自定义数据，使得应用可以对线程功能做一定程度的扩展。</p><h2 id="特殊线程"><a href="#特殊线程" class="headerlink" title="特殊线程"></a>特殊线程</h2><h3 id="系统线程"><a href="#系统线程" class="headerlink" title="系统线程"></a>系统线程</h3><p>Zephyr内核初始化会创建的一些初始线程。主要分为主线程和空闲线程。</p><h3 id="Workqueue"><a href="#Workqueue" class="headerlink" title="Workqueue"></a>Workqueue</h3><p>与Linux系统的Workqueue相似，主要用于中断下半部使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为Zephyr系统，线程的基本概念。主要介绍了线程的状态、分类、优先级等基础思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想写一些RTOS的技术资料，算作对自己之前一些相关技术调研的总结。无奈懒癌发作，一拖再拖。然今日灌上鸡血，笃定主意，从最基本的调度相关内容开始。  &lt;/p&gt;&lt;p&gt;简单讲，Zephyr是一个开源实时操作系统。相较Linux，其对系统资源的使用量更小，当然也牺牲了许多复杂且完善的功能（如，系统Debug易用性，线程的堆栈保护）。与此同时，因其是开源社区开发，也多少继承和保留了许多Linux系统的优秀思想和功能（例如，Workqueue、设备树等）。其定位为万物互联时代各种各样的嵌入式设备，目光长远。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RTOS" scheme="http://l2h.site/categories/RTOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Zoc for Mac注册码收集</title>
    <link href="http://l2h.site/2019/11/03/zoc-for-mac/"/>
    <id>http://l2h.site/2019/11/03/zoc-for-mac/</id>
    <published>2019-11-03T05:15:19.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直使用ZoC做阿里云ECS管理，方便好用。不过经常会License过期。<br>收集几个备用，之后过期可以来这里拿：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Part A: 55834/01027/59600</span><br><span class="line">Part B: 43010</span><br><span class="line"></span><br><span class="line">Part A: 11370/01027/29134</span><br><span class="line">Part B: 51686</span><br><span class="line"></span><br><span class="line">Part A: 61298/01028/48550</span><br><span class="line">Part B: 00985</span><br><span class="line"></span><br><span class="line">Part A: 51698/01027/34713</span><br><span class="line">Part B: 00937</span><br><span class="line"></span><br><span class="line">Part A: 50866/01027/47775</span><br><span class="line">Part B: 57341</span><br><span class="line"></span><br><span class="line">Part A: 53866/01028/18861</span><br><span class="line">Part B: 45757</span><br><span class="line"></span><br><span class="line">Part A: 03754/01029/23239</span><br><span class="line">Part B: 50179</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直使用ZoC做阿里云ECS管理，方便好用。不过经常会License过期。&lt;br&gt;收集几个备用，之后过期可以来这里拿：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
    
      <category term="L&amp;amp;H Site" scheme="http://l2h.site/tags/L-amp-H-Site/"/>
    
  </entry>
  
  <entry>
    <title>随便感慨</title>
    <link href="http://l2h.site/2019/10/19/20191020-just-sigh-md/"/>
    <id>http://l2h.site/2019/10/19/20191020-just-sigh-md/</id>
    <published>2019-10-19T11:38:23.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>从长假回公司已经有一个月了，慢慢也进入到工作状态。<br>这次回来，还是有蛮多感触。看到晚几年进公司的同事，一步步承担更重的任务。深觉须时时努力，不断进步。方能担负得起自己所承担的任务。<br>今年运气欠佳，也希望努力可以带来更好的运气。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从长假回公司已经有一个月了，慢慢也进入到工作状态。&lt;br&gt;这次回来，还是有蛮多感触。看到晚几年进公司的同事，一步步承担更重的任务。深觉须时时努力，不断进步。方能担负得起自己所承担的任务。&lt;br&gt;今年运气欠佳，也希望努力可以带来更好的运气。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>博客程序更换成Hexo</title>
    <link href="http://l2h.site/2019/10/08/20191008-Change-to-hexo/"/>
    <id>http://l2h.site/2019/10/08/20191008-Change-to-hexo/</id>
    <published>2019-10-08T13:09:29.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直希望使用Markdown来写博客，无奈Wordpress对Markdown的原生支持太差。而且受不了Wordpress程序执行的龟速。  </p><p>因此趁着国庆把博客程序作了更换成了Hexo，托管网站也换成了Github。  </p><p>简单说明一下转移作了哪些事情：</p><ul><li>申请Github Pages 并绑定域名</li><li>安装Hexo，并下载相应所需插件。没想到有Wordpress转Hexo插件，真是帮了大忙</li><li>把之前上传在网站空间的图片，全部下载并转存到七牛云存储上（这里有点小技巧，用Notepad++的正则表达式查找替换，节省时间，事半功倍）</li><li>使用NeXT主题，自带很多需要的功能，包括可以显示属性公式的Mathjax，原Wordpress博客的数学公式，也并没有受到影响（当然也要做一些非常简单的文本替换，同样Notepad++搞定）</li><li>因为博客是使用Hexo生成静态页面上传到Github Pages。特意申请了一个Github私有项目保存保存源码，方便多机编辑（这也是Hexo唯一的不方便，每个机子都要重新建环境）</li><li>另外一些原博客需要的一些小修改，不表。</li></ul><a id="more"></a><p>之前买的阿里云空间还有整整两年，感觉不用可惜了。不知道除了远程使用下Linux，还有啥用途。开个自动采集小说站，会不会被请喝茶？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直希望使用Markdown来写博客，无奈Wordpress对Markdown的原生支持太差。而且受不了Wordpress程序执行的龟速。  &lt;/p&gt;&lt;p&gt;因此趁着国庆把博客程序作了更换成了Hexo，托管网站也换成了Github。  &lt;/p&gt;&lt;p&gt;简单说明一下转移作了哪些事情：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;申请Github Pages 并绑定域名&lt;/li&gt;
&lt;li&gt;安装Hexo，并下载相应所需插件。没想到有Wordpress转Hexo插件，真是帮了大忙&lt;/li&gt;
&lt;li&gt;把之前上传在网站空间的图片，全部下载并转存到七牛云存储上（这里有点小技巧，用Notepad++的正则表达式查找替换，节省时间，事半功倍）&lt;/li&gt;
&lt;li&gt;使用NeXT主题，自带很多需要的功能，包括可以显示属性公式的Mathjax，原Wordpress博客的数学公式，也并没有受到影响（当然也要做一些非常简单的文本替换，同样Notepad++搞定）&lt;/li&gt;
&lt;li&gt;因为博客是使用Hexo生成静态页面上传到Github Pages。特意申请了一个Github私有项目保存保存源码，方便多机编辑（这也是Hexo唯一的不方便，每个机子都要重新建环境）&lt;/li&gt;
&lt;li&gt;另外一些原博客需要的一些小修改，不表。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="建站" scheme="http://l2h.site/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://l2h.site/2019/09/15/linux-process-manage-1/"/>
    <id>http://l2h.site/2019/09/15/linux-process-manage-1/</id>
    <published>2019-09-15T01:01:02.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>回顾下操作系统概念：现代计算机往往都是“同时”运行多个任务。系统若只有一个处理器，那么给定时刻只可能有一个任务在执行。而操作系统通过进程管理和调度，切换正在执行的任务，是用户在感官上认为计算机是并行执行多个任务。当然，若是多处理器系统，真正同时执行的任务可以达到处理器的数目。</p><p>内核进行进程管理的主要解决的问题：</p><a id="more"></a><ul><li>任务有轻重缓急之分，需要可以根据任务的紧急程度给予任务不同的执行优先级和时间。同时尽可能保证任务执行的公平性。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在Linux系统中，我们所讲的任务即进程。进程调度，就是根据当前系统的运行状况，对进程状态的切换。</p><p>Linux中进程主要有如下状态：</p><ul><li><strong>运行</strong>：该进程此刻正在执行。</li><li><strong>等待</strong>：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。</li><li><strong>睡眠</strong>：进程正在睡眠无法运行，因为它在等待一个外部事件（或某种资源）。调度器无法在下一次任务切换时选择该进程。</li></ul><p>以上状态可以相互转换（等待–&gt;睡眠转换除外），转换的条件主要有：</p><ul><li>进程时间片用完或轮转到该进程</li><li>进程阻塞等待某种资源/某种资源准备好了</li></ul><h3 id="进程表示"><a href="#进程表示" class="headerlink" title="进程表示"></a>进程表示</h3><p>进程用task_struct结构体来表示，定义在include/linux/sched.h如下（省略部分成员）。重点结构体成员意义注释在代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*进程当前状态，由sched.h中的宏定义TASK_RUNNING~TASK_STATE_MAX表示。</span></span><br><span class="line"><span class="comment"> TASK_RUNNING意味着进程处于可运行状态。这并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件。</span></span><br><span class="line"><span class="comment"> TASK_INTERRUPTIBLE是针对等待某事件或其他资源的睡眠进程设置的。在内核发送信号给该进程表明事件已经发生时，进程状态变为TASK_RUNNING，它只要调度器选中该进程即可恢复执行。</span></span><br><span class="line"><span class="comment"> TASK_UNINTERRUPTIBLE用于因内核指示而停用的睡眠进程。它们不能由外部信号唤醒，只能由内核亲自唤醒。</span></span><br><span class="line"><span class="comment"> TASK_STOPPED表示进程特意停止运行，例如，由调试器暂停。</span></span><br><span class="line"><span class="comment"> TASK_TRACED本来不是进程状态，用于从停止的进程中，将当前被调试的那些（使用ptrace机制）与常规的进程区分开来。</span></span><br><span class="line"><span class="comment"> EXIT_ZOMBIE为僵尸状态，表示进程结束时父进程未调用wait调用的进程</span></span><br><span class="line"><span class="comment"> EXIT_DEAD状态则是指wait系统调用已经发出，而进程完全从系统移除之前的状态。只有多个线程对同一个进程发出wait调用时，该状态才有意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">//进程栈指针</span></span><br><span class="line"><span class="keyword">atomic_t</span> usage; <span class="comment">//进程描述符使用计数，被置为2时，表示进程描述符正在被使用而且其相应的进程处于活动状态</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags; <span class="comment">//进程标志</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;<span class="comment">//进程调试跟踪相关标记</span></span><br><span class="line"><span class="keyword">int</span> on_rq; <span class="comment">//CPU可能有多个运行队列，可能会在运行队列中移动。标记表示进程目前在运行队列位置状态。</span></span><br><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;<span class="comment">//静态优先级动态优先级和一般优先级，调度器使用</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority; <span class="comment">//实时进程运行优先级</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">//指向进程的调度器(完全公平调度器？实时调度器等)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">//调度实体，每个进程就是一个调度实体。调度实体也可以是用户进程组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span> <span class="comment">//实时进程调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span> <span class="comment">//Deadline调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">preempt_notifiers</span>;</span><span class="comment">//存放进程被抢占的通知函数链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy; <span class="comment">//调度策略</span></span><br><span class="line"><span class="keyword">int</span> nr_cpus_allowed; <span class="comment">//允许调度的CPU数量</span></span><br><span class="line"><span class="keyword">cpumask_t</span> cpus_allowed;<span class="comment">//掩码图表示允许调度的CPU</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span><span class="comment">//进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span><span class="comment">//进程内存管理结构体</span></span><br><span class="line">u64 vmacache_seqnum;<span class="comment">//虚拟地址区间缓存序列号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vmacache</span>[<span class="title">VMACACHE_SIZE</span>];</span><span class="comment">//虚拟地址区间缓存</span></span><br><span class="line"><span class="keyword">int</span> exit_state; <span class="comment">//以下记录进程的退出状态信息</span></span><br><span class="line"><span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"><span class="comment">/* 调度器相关标记 */</span></span><br><span class="line"><span class="keyword">unsigned</span> sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_migrated:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> :<span class="number">0</span>; <span class="comment">/* force alignment to the next boundary */</span></span><br><span class="line"><span class="keyword">unsigned</span> in_execve:<span class="number">1</span>; <span class="comment">/* bit to tell LSMs we're in execve */</span></span><br><span class="line"><span class="keyword">unsigned</span> in_iowait:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(TIF_RESTORE_SIGMASK)</span></span><br><span class="line"><span class="keyword">unsigned</span> restore_sigmask:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> memcg_may_oom:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="keyword">unsigned</span> memcg_kmem_skip_account:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line"><span class="keyword">unsigned</span> brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid; <span class="comment">//进程全局PID</span></span><br><span class="line"><span class="keyword">pid_t</span> tgid; <span class="comment">//进程组内PID</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">//真正父进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">//父进程（为什么会有real_parent和parent，因为线程的存在，其父进程应为创建它的进程的父进程）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span><span class="comment">//子进程列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span><span class="comment">//兄弟进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">//对多线程程序有用，指向线程组组长</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptraced</span>;</span> <span class="comment">//ptrace跟踪的进程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_entry</span>;</span> <span class="comment">//所在父进程的ptrace链表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span> <span class="comment">//线程组链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_node</span>;</span> <span class="comment">//线程节点链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span><span class="comment">/* for vfork() */</span></span><br><span class="line"><span class="keyword">int</span> __user *set_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line"><span class="keyword">int</span> __user *clear_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line"><span class="comment">//进程运行时间相关参数</span></span><br><span class="line"><span class="keyword">cputime_t</span> utime, stime, utimescaled, stimescaled;</span><br><span class="line"><span class="keyword">cputime_t</span> gtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span> <span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line"><span class="keyword">seqcount_t</span> vtime_seqcount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtime_snap;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">VTIME_INACTIVE = <span class="number">0</span>,</span><br><span class="line">VTIME_USER,</span><br><span class="line">VTIME_SYS,</span><br><span class="line">&#125; vtime_snap_whence;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line"><span class="keyword">atomic_t</span> tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">u64 start_time;</span><br><span class="line">u64 real_start_time;<span class="comment">//启动时间</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_cputime</span> <span class="title">cputime_expires</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程身份相关参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer's credentials at attach */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task credentials (COW) */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span></span><br><span class="line"><span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">     \- access with [gs]et_task_comm (which lockit with task_lock())</span></span><br><span class="line"><span class="comment">     \- initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span> <span class="comment">//路径相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">//IPC参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span><span class="comment">//信号量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span><span class="comment">//共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count; <span class="comment">//切换次数，用于检验进程挂起</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">// 进程文件系统信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 打开文件的信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span> <span class="comment">// 命名空间 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> <span class="comment">//信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span> <span class="comment">//信号处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line"><span class="keyword">sigset_t</span> saved_sigmask;<span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line"><span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line"><span class="keyword">unsigned</span> sas_ss_flags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">task_works</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line"><span class="keyword">kuid_t</span> loginuid;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sessionid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span> <span class="title">seccomp</span>;</span></span><br><span class="line"><span class="comment">//线程组信息</span></span><br><span class="line">   u32 parent_exec_id;</span><br><span class="line">   u32 self_exec_id;</span><br><span class="line"><span class="comment">//进程资源锁</span></span><br><span class="line"><span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"><span class="keyword">raw_spinlock_t</span> pi_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> <span class="title">wake_q</span>;</span></span><br><span class="line"><span class="comment">//虚拟内存状态信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span> *<span class="title">reclaim_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line"><span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span> <span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">u64 acct_rss_mem1;<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">u64 acct_vm_mem1;<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line"><span class="keyword">cputime_t</span> acct_timexpd;<span class="comment">/* stime + utime since last update */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line"><span class="keyword">nodemask_t</span> mems_allowed;<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line"><span class="keyword">seqcount_t</span> mems_allowed_seq;<span class="comment">/* Seqence no to catch updates */</span></span><br><span class="line"><span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line"><span class="keyword">int</span> cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line"><span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line"><span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span> *<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pi_state_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span> *<span class="title">pi_state_cache</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">perf_event_ctxp</span>[<span class="title">perf_nr_task_contexts</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">perf_event_mutex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为要支持各种各样的功能，task_struct已经变得非常大。不过总体上，结构体可以被划分为如下部分：</p><ul><li>状态和执行信息，如待决信号、使用的二进制格式（和其他系统二进制格式的任何仿真信息）、进程ID号（ pid）、到父进程及其他有关进程的指针、优先级和程序执行有关的时间信息（例如CPU时间）。</li><li>有关已经分配的虚拟内存的信息。</li><li>进程身份凭据，如用户ID、组ID以及权限①等。可使用系统调用查询（或修改）这些数据。</li><li>使用的文件包含程序代码的二进制文件，以及进程所处理的所有文件的文件系统信息，这些都必须保存下来。</li><li>进程信息记录该进程特定于CPU的运行时间数据（该结构的其余字段与所使用的硬件无关）。</li><li>在与其他应用程序协作时所需的进程间通信有关的信息。</li><li>该进程所用的信号处理程序，用于响应到来的信号。</li></ul><h3 id="进程ID号"><a href="#进程ID号" class="headerlink" title="进程ID号"></a>进程ID号</h3><p>在task_struct结构体里，我们看到了很多进程ID相关字段，初看会很容易混淆。本节介绍Linux进程ID管理相关思想，帮助理解这些字段的含义。</p><p>乍一看进程ID管理应该比较简单：内核只需要保证分配的id不唯一，释放掉的id可以被其他新创建的进程id使用即可。但是事实并非如此，内核需要做如下考量：</p><ul><li>内核有<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">命名空间</a>的概念，一个进程可以出现在多个命名空间，它在不同的命名空间的id是不同的。</li><li>同一个进程可以有多个线程，这些线程（其实也是task_struct）共享同一个线程组id (TGID)</li><li>进程可以合并为进程组，而进程组又可以合并为会话（Session）。组或者会话里的进程共享相同的组id或会话id。</li></ul><p>PID分配需要在特定的命名空间内保证id的唯一性。用来表示PID的命名空间定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pid_allocated;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span> <span class="comment">//对应命名空间0号进程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//该命名空间的层级</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span> <span class="comment">//命名空间上级的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">proc_mnt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_self</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_thread_self</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_pin</span> *<span class="title">bacct</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">proc_work</span>;</span></span><br><span class="line"><span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line"><span class="keyword">int</span> hide_pid;</span><br><span class="line"><span class="keyword">int</span> reboot;<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125; __randomize_layout</span><br></pre></td></tr></table></figure><p>而内核管理命名空间内的pid也主要围绕两个数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nr; <span class="comment">//id</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span> <span class="comment">//指向所在命名空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;  <span class="comment">//pid使用数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//层级数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span> <span class="comment">//对应每种类别命名空间进程的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span> <span class="comment">//每级的pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中PIDTYPE_MAX为pid类别的枚举类型最大值，具体该枚举类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">PIDTYPE_PID,</span><br><span class="line">PIDTYPE_TGID,</span><br><span class="line">PIDTYPE_PGID,</span><br><span class="line">PIDTYPE_SID,</span><br><span class="line">PIDTYPE_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，task_struct还保留了两个pid，分别为：</p><ul><li>pid: 初使命名空间（即init进程所在空间）中该进程的全局ID号</li><li>tgid：初使命名空间中该进程的线程组ID号，若该进程非多线程进程，则值与pid相同。</li></ul><p>一张图表示task_struct中进程id的相互关联：</p><p><img src="https://i0.wp.com/www.l2h.site/wp-content/uploads/2019/09/1.png?fit=810%2C467&ssl=1" alt></p><p>pid数据结构关系图（引用自《深入理解linux内核架构》）</p><p>注意，上图结构为2.6版内核中数据结构。新版内核（截至目前应该是5.）对结构会有部分调整，但总体管理方式和数据结构间关联未变。</p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>进程可以有子进程，其子进程链表用task_struct的children元素表示。一个子进程和父进程的其他子进程互为兄弟进程，通过task_struct的sibling元素相互关联。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了linux内核管理的基本概念，以及相应的数据结构。后续介绍会包含进程调度基本架构和思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾下操作系统概念：现代计算机往往都是“同时”运行多个任务。系统若只有一个处理器，那么给定时刻只可能有一个任务在执行。而操作系统通过进程管理和调度，切换正在执行的任务，是用户在感官上认为计算机是并行执行多个任务。当然，若是多处理器系统，真正同时执行的任务可以达到处理器的数目。&lt;/p&gt;&lt;p&gt;内核进行进程管理的主要解决的问题：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux进程管理" scheme="http://l2h.site/categories/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac Mojave修改屏幕主题色</title>
    <link href="http://l2h.site/2019/08/13/mac-mojave-e4-bf-ae-e6-94-b9-e5-b1-8f-e5-b9-95-e4-b8-bb-e9-a2-98-e8-89-b2/"/>
    <id>http://l2h.site/2019/08/13/mac-mojave-e4-bf-ae-e6-94-b9-e5-b1-8f-e5-b9-95-e4-b8-bb-e9-a2-98-e8-89-b2/</id>
    <published>2019-08-13T09:18:39.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚给Mac更新了系统，发现多了一项功能，即修改屏幕主题色。有浅色和深色两种选择。深色的还蛮酷的。修改方法：</p><blockquote><p>系统偏好设置-&gt;通用-&gt;外观</p></blockquote><p>选择你喜欢的主题色即可</p><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8B%E5%8D%884.57.03.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚给Mac更新了系统，发现多了一项功能，即修改屏幕主题色。有浅色和深色两种选择。深色的还蛮酷的。修改方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;系统偏好设置-&amp;gt;通用-&amp;gt;外观&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择你喜欢的主题色即可&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="L&amp;amp;H Site" scheme="http://l2h.site/categories/L-amp-H-Site/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux内核内存管理简析(1)</title>
    <link href="http://l2h.site/2019/08/13/linux-mm-1/"/>
    <id>http://l2h.site/2019/08/13/linux-mm-1/</id>
    <published>2019-08-13T00:49:07.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存管理是Linux内核最为复杂且最为重要的部分，本文从原理及代码角度对Linux内存管理机制进行分析。</p><h2 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h2><p>Linux将内存从大到小依次划分为Node（节点）-&gt;Zone（内存域）-&gt;Page（页）：</p><ul><li>节点：在大型结算及系统中，内存有不同的簇，依据对处理器距离的不同，访问这些簇有不同的代价。而这些簇就可以成为节点。例：在PC系统中可以理解为实际挂载的物理内存；在嵌入式系统中，有两块内存芯片A和B，分别代表一个节点。</li><li>内存域：内存域并不是物理存在的概念，是Linux系统对每个内存节点进行管理的单位，每个节点的内存域表示的是对该节点不同地址范围的划分。一般内存域有三种，分别为Normal、DMA和HighMem。</li><li>页：在每个内存域中，内存被划分为大小固定的块（32位系统一般为4K大小），为内核进行内存分配的基本单位（当然内核内存管理机制其实更为复杂，“基本单位”不代表每次分配内存最小就要分到4K。后边可以看到，当需要获取小于4K大小的内存时，内核有Slab分配器来满足要求）</li></ul><a id="more"></a><p>一张图说明Node、Zone和Page的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                  Node 1            Node 2           Node 3</span><br><span class="line">                       +----------+     +----------+     +----------+</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |Zone_High |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       +----------+     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |Zone_Norm |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       +----------+     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">     page  page        |Zone_DMA  |     |          |     |          |</span><br><span class="line">+-+--+--+--+--+        |          |     |          |     |          |</span><br><span class="line">| |  |  |  |  |  &lt;--------+       |     |          |     |          |</span><br><span class="line">+-+--+--+--+--+        +----------+     +----------+     +----------+</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>构成上述三个内存划分的数据结构如下：</p><h3 id="内存节点"><a href="#内存节点" class="headerlink" title="内存节点"></a>内存节点</h3><p>Node对应的结构为pglist_data_t，定义如下（为方便理解，省略部分结构体成员）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones_MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists_MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page  range, including holes */</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span> <span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="keyword">int</span> kswapd_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line">    <span class="keyword">int</span> kswapd_failures;        <span class="comment">/* Number of 'reclaimed == 0' runs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kcompactd_classzone_idx;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_next_window;</span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       totalreserve_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line">    <span class="comment">/* Number of non-deferred pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> static_init_pgcnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/* Per-node vmstats */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>node_zones</strong>: 内存节点上的内存域，分别为 ZONE_HIGHMEM, ZONE_NORMAL, ZONE_DMA。新版Linux还增加了ZONE_MOVABLE和ZONE_DEVICE。</li><li><strong>node_zonelists:</strong> 对内存域进行类别指定的优先级顺序。例，当ZONE_HIGHMEM分配失败时，会u退到ZONE_DMA类型后ZONE_NORMAL类型</li><li><strong>nr_zones:</strong> 该节点上的内存域数量</li><li><strong>node_mem_map:</strong> 节点中页面的映射图</li><li><strong>bdata:</strong> 与内核初始化内存分配器相关数据</li><li><strong>node_size_lock</strong>： 与内存热拔插相关</li><li><strong>node_start_pfn:</strong> 内存节点的起始页。</li><li><strong>node_present_pages:</strong> 物理页面数量<strong>.</strong></li><li><strong>node_spanned_pages:</strong> 内存节点物理页面的大小</li><li><strong>node_id:</strong> 节点编号</li><li><strong>kswapd_wait</strong>/<strong>pfmemalloc_wait</strong>/<strong>kswapd</strong>/<strong>kswapd_order</strong>/<strong>kswapd_classzone_idx/kswapd_failures:</strong> kswapd内核线程相关参数</li><li><strong>……..</strong></li></ul><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域对应的结构体为struct zone，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_NR_WMARK];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line">    <span class="keyword">long</span> lowmem_reserve_MAX_NR_ZONES];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>  *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       zone_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       managed_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       spanned_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       present_pages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">seqlock_t</span>       span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> initialized;</span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area_MAX_ORDER</span>];</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><ul><li><strong>watermark</strong>: 内存域的水位</li><li><strong>nr_reserved_highatomic:</strong> 紧急内存大小，</li><li><strong>lowmem_reserve</strong>:内存域最少保留内存</li><li><strong>zone_pgdat</strong>: 所在内存节点指针</li><li><strong>pageset</strong>: 每个CPU维护的页面列表</li><li><strong>zone_start_pfn</strong>:内存域第一个页的索引</li><li><strong>managed_pages</strong>: 伙伴系统管理的所有页面数量</li><li><strong>spanned_pages</strong>: 内存域所跨越所有内存页数量</li><li><strong>present_pages</strong>: 内存域物理内存所有页数量(除去内存空洞后的部分)present_pages=spanned_pages-absent_pages</li><li><strong>name</strong>: 区域名</li><li><strong>free_area</strong>:所有空闲页面的数组</li><li><strong>flags</strong>:内存域标识</li><li><strong>lock</strong>:保护free_area的锁</li><li><strong>vm_stat</strong>:虚拟内存统计信息</li></ul><p>特别说明一下内存域的水位（Watermark），它表示几个阈值，用来管理内核线程kswapd唤起与休眠的。当域内可用内存水位较高时，kswapd不用起来工作，而水位较低时，kswapd需要唤起来回收内存。如下图（来自深入理解Linux虚拟内存管理）：</p><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.40.53.png" alt></p><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>系统中每个物理页面都有数据结构struct page与其关联，用于管理页面的使用。结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">truct page &#123;</span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;       </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span> </span><br><span class="line">        <span class="keyword">void</span> *s_mem;            <span class="comment">/* slab first object */</span></span><br><span class="line">        <span class="keyword">atomic_t</span> compound_mapcount; <span class="comment">/* first tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;     <span class="comment">/* sl_aou]b first free object */</span></span><br><span class="line">        <span class="comment">/* page_deferred_list().prev    -- second tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">        <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> active;        <span class="comment">/* SLAB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">int</span> units;          <span class="comment">/* SLOB */</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">atomic_t</span> _refcount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Third double word block */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>  <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">int</span> pages;  <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="keyword">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">            <span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> __pad;    </span><br><span class="line">            <span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SL_AU]B: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;          <span class="comment">/* Kernel virtual address (NULL if  not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面结构体使用双字块来划分：</p><ul><li><p>第一个双字</p><ul><li><p>flags: 页面状态，脏页、上锁等院子标记</p></li><li><p>联合体</p><ul><li><p>mapping：指向inode address_space</p></li><li><p>s_mem：slab首对象</p></li><li><p>compound_mapcount：</p></li></ul></li></ul></li><li><p>第二个双字：</p><ul><li><p>联合体</p><ul><li><p>index：页面偏移</p></li><li><p>freelist：slab/slob的首个可用对象</p></li></ul></li><li><p>联合体：slab/slub/slob相关的记数（取决于编译内核时选择的管理方式）</p></li></ul></li><li><p>第三个双字：</p><ul><li><p>lru：换出页列表</p></li><li><p>pgmap:</p></li><li><p>rcu_head</p></li><li><p>结构体，用于slub管理</p></li><li><p>结构体，用于复合页管理</p></li></ul></li><li><p>联合体(ptl/slab_cache): slab指针，或者PTE自旋锁</p></li><li><p>virtual: 内核虚拟地址。用于高端内存中的页，即无法直接映射到内核内存中的页</p></li></ul><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux进行内存寻址时，往往不会直接内存物理地址，需要经过虚拟地址到物理地址的转化。使用虚拟地址的好处是可以避免进程与进程间互踩内存（除非特别指定共享内存），同时虚拟内存的换出换入使得进程使用超过物理内存大小的内存范围。</p><p>CPU中内存管理单元（MMU）作用就是根据内存中特定的转化表格（不错，页表本身也是需要内存存储的），将虚拟地址转化为真正的物理地址。而这个表格就是我们所讲的页表。</p><p>取决于体系结构，Linux采用三级或者四级页表机制：</p><ul><li>PGD：Page Global Directory，全局页表目录</li><li>PUD：Page Upper Directory，上级页表目录</li><li>PMD：Page Middle Directory，中级页表目录</li><li>PTE：Page Table Entry，页表表项</li></ul><p>每级表项所占位数，取决于我们编译内核时的选择。一般情况下，取决于寻址宽度，以及CPU体系结构每级页表所占位数是有约定俗成的。</p><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.56.58.png" alt></p><p>内核在arch/xxx/include/asm/page.h（其中xxx表示CPU体系结构）定义了一系列的类型、函数和宏来方便对每级页表进行操作。</p><p>如上图我们看到的几个SHIFT宏定义，是为了方便通过位移操作来快速获取对应等级页表。</p><p>在IA64中用来表示以上各级页表目录的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pud; &#125; <span class="keyword">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br></pre></td></tr></table></figure><p>与页表相关的宏或者函数定义有<a href="https://elixir.bootlin.com/linux/latest/ident/pmd_alloc" target="_blank" rel="noopener">pmd/pte/pgd_alloc</a>/free()等等，具体可以参考include/linux/mm.h。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了Linux内核内存管理的基本单位划分Node、Zone和Page及对应的数据结构，同时对页表的基本概念进行了介绍。将在下一文分析Linux初始化流程中对内存的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存管理是Linux内核最为复杂且最为重要的部分，本文从原理及代码角度对Linux内存管理机制进行分析。&lt;/p&gt;&lt;h2 id=&quot;内存的划分&quot;&gt;&lt;a href=&quot;#内存的划分&quot; class=&quot;headerlink&quot; title=&quot;内存的划分&quot;&gt;&lt;/a&gt;内存的划分&lt;/h2&gt;&lt;p&gt;Linux将内存从大到小依次划分为Node（节点）-&amp;gt;Zone（内存域）-&amp;gt;Page（页）：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;节点：在大型结算及系统中，内存有不同的簇，依据对处理器距离的不同，访问这些簇有不同的代价。而这些簇就可以成为节点。例：在PC系统中可以理解为实际挂载的物理内存；在嵌入式系统中，有两块内存芯片A和B，分别代表一个节点。&lt;/li&gt;
&lt;li&gt;内存域：内存域并不是物理存在的概念，是Linux系统对每个内存节点进行管理的单位，每个节点的内存域表示的是对该节点不同地址范围的划分。一般内存域有三种，分别为Normal、DMA和HighMem。&lt;/li&gt;
&lt;li&gt;页：在每个内存域中，内存被划分为大小固定的块（32位系统一般为4K大小），为内核进行内存分配的基本单位（当然内核内存管理机制其实更为复杂，“基本单位”不代表每次分配内存最小就要分到4K。后边可以看到，当需要获取小于4K大小的内存时，内核有Slab分配器来满足要求）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux内存管理" scheme="http://l2h.site/categories/Linux/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="内存管理" scheme="http://l2h.site/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux MTD子系统</title>
    <link href="http://l2h.site/2019/08/02/linux-mtd-e5-ad-90-e7-b3-bb-e7-bb-9f/"/>
    <id>http://l2h.site/2019/08/02/linux-mtd-e5-ad-90-e7-b3-bb-e7-bb-9f/</id>
    <published>2019-08-02T11:27:46.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要MTD子系统"><a href="#为什么需要MTD子系统" class="headerlink" title="为什么需要MTD子系统"></a>为什么需要MTD子系统</h3><p>嵌入式系统使用Flash作为存储设备，Flash类别有Nand、Nor等。Flash的上层是文件系统。直觉上，系统中使用这些Flash时，我们需要为每种Flash编写驱动。同时在调用Flash的文件系统做接口对接。这样，每使用一种新的Flash类型甚至型号，都得修改文件系统的编码来做适配。显然，这会造成代码的爆炸，同时也不方便大家各司其职（例如：厂商A做Flash，添加一个新的Flash需要厂商A的驱动开发人员去改写所有文件系统的接口，这显然不现实）。</p><a id="more"></a><p>几乎所有的现代操作系统都不会允许以上事情的发生。通用的做法是，抽象出上下层对接的方式，厂商驱动开发人员只需要按照接口进行匹配节课。</p><p>MTD（Memory Technology Devices）便是Linux系统下处理以上问题的方式。</p><h3 id="架构与代码目录"><a href="#架构与代码目录" class="headerlink" title="架构与代码目录"></a>架构与代码目录</h3><p>MTD在系统中的结构如下图。</p><ul><li>构成MTD的部分有MTD核心、MTD字符设备和MTD块设备层。成为文件系统和底层硬件驱动的沟通桥梁</li><li>MTD核心建立在Flash驱动（位于drivers/mtd/）之上，为Flash驱动提供一系列的API抽象</li><li>MTD为上层提供统一的操作抽象接口如<code>dev/mtd0</code>, <code>/dev/mtd1</code>（例如擦除、读写等），同时提供 <code>/proc/mtd</code>供上层读取MTD系统相关信息</li><li>MTD提供一系列的API，为基于Flash的文件系统提供控制操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   +-----------------+</span><br><span class="line">  | 使用文件系统的应用 |</span><br><span class="line">   +-----------------+</span><br><span class="line">   +------------+ +------------+</span><br><span class="line">   |Char Dev节点 | |Block Dev节点| 用户空间层</span><br><span class="line">   +------------+ +------------+</span><br><span class="line">+---------------------------------+</span><br><span class="line">   +---------------+-----------+</span><br><span class="line">   |  MTD字 符 设 备| MTD块 设 备|</span><br><span class="line">   +---------------+-----------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |      MTD Core             | 内核层</span><br><span class="line">   +---------------------------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |       Flash驱 动           |</span><br><span class="line">   +---------------------------+</span><br><span class="line">+---------------------------------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |       各 种 Flash          | 硬件层</span><br><span class="line">   +---------------------------+</span><br></pre></td></tr></table></figure></li></ul><p>MTD代码在Linux内核源码树的位置：</p><ul><li>_include/linux/mtd/_：定义所有MTD相关头文件</li><li><em>drivers/mtd</em>: 定义MTD核心，以及Flash驱动</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>MTD的核心结构定义在内核源码树的_include/linux/mtd/mtd.h_。先看核心数据结构mtd_info：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> &#123;</span></span><br><span class="line">u_char type;</span><br><span class="line"><span class="keyword">uint32_t</span> flags;</span><br><span class="line"><span class="keyword">uint64_t</span> size; <span class="comment">// MTD总大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> erasesize; <span class="comment">//擦除大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> writesize; <span class="comment">//最小写单位</span></span><br><span class="line"><span class="keyword">uint32_t</span> writebufsize; <span class="comment">//写缓冲大小，提升写效率</span></span><br><span class="line"><span class="keyword">uint32_t</span> oobsize;   <span class="comment">// 每个Flash 块的OOB数量</span></span><br><span class="line"><span class="keyword">uint32_t</span> oobavail;  <span class="comment">// 每个Flash块的OOB大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_shift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_shift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_mask;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_mask; <span class="comment">//shift和mask在Linux源码中常见，主要用于MTD大小相关的位运算</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bitflip_threshold; <span class="comment">//位翻转阈值，即最大允许位翻转个数，超出后，读写返回“-EUCLEAN”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//MTD名称</span></span><br><span class="line"><span class="keyword">int</span> index;  <span class="comment">//MTD索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_ooblayout_ops</span> *<span class="title">ooblayout</span>;</span> <span class="comment">//OOB layout操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_pairing_scheme</span> *<span class="title">pairing</span>;</span><span class="comment">//MLC/TLC NANDs Flash 颗粒的配对策略</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_step_size; <span class="comment">//ecc步长</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_strength; <span class="comment">//ecc最大可纠正错误bit数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numeraseregions;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_erase_region_info</span> *<span class="title">eraseregions</span>;</span> <span class="comment">//擦除区域信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为Flash操作的回调函数，不同flash有不同实现</span></span><br><span class="line"><span class="keyword">int</span> (*_erase) (struct mtd_info *mtd, struct erase_info *instr);</span><br><span class="line"><span class="keyword">int</span> (*_point) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">void</span> **virt, <span class="keyword">resource_size_t</span> *phys);</span><br><span class="line"><span class="keyword">int</span> (*_unpoint) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*_get_unmapped_area)</span> <span class="params">(struct mtd_info *mtd,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*_read) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len,</span><br><span class="line">      <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len,</span><br><span class="line">       <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_panic_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">  struct mtd_oob_ops *ops);</span><br><span class="line"><span class="keyword">int</span> (*_write_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to,</span><br><span class="line">   struct mtd_oob_ops *ops);</span><br><span class="line"><span class="keyword">int</span> (*_get_fact_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_fact_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_get_user_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len,  <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line"><span class="keyword">int</span> (*_read_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_write_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line"><span class="keyword">int</span> (*_lock_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,  <span class="keyword">size_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_writev) (struct mtd_info *mtd, <span class="keyword">const</span> struct kvec *vecs, <span class="keyword">unsigned</span> <span class="keyword">long</span> count, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> *retlen);</span><br><span class="line"><span class="keyword">void</span> (*_sync) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">int</span> (*_lock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_unlock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_is_locked) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line"><span class="keyword">int</span> (*_block_isreserved) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_block_isbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_block_markbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line"><span class="keyword">int</span> (*_suspend) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_resume) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_reboot) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">int</span> (*_get_device) (struct mtd_info *mtd);</span><br><span class="line"><span class="keyword">void</span> (*_put_device) (struct mtd_info *mtd);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">reboot_notifier</span>;</span>  <span class="comment">//重启通知</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_ecc_stats</span> <span class="title">ecc_stats</span>;</span> <span class="comment">//ECC统计数据</span></span><br><span class="line"><span class="keyword">int</span> subpage_sft;</span><br><span class="line"><span class="keyword">void</span> *priv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="keyword">int</span> usecount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外一个比较重要的数据结构为mtd_partition，顾名思义，对一块flash进行分区:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//分区名称</span></span><br><span class="line"><span class="keyword">uint64_t</span> size;<span class="comment">//大小</span></span><br><span class="line"><span class="keyword">uint64_t</span> offset; <span class="comment">//在MTD设备的偏移</span></span><br><span class="line"><span class="keyword">uint32_t</span> mask_flags; <span class="comment">//MTD主设备的掩码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常每种类型的Flash芯片定义了这样一个数据结构，用于对Flash进行操作。可参考drivers/mtd/devices下相关使用（例如lpddr2_nvm.c）</p><p>mtdcore.h/mtdcore.c下定义了一系列使用MTD设备的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *__<span class="title">mtd_next_device</span>(<span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注册MTD设备</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注销</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *, <span class="keyword">const</span> struct mtd_partition *, <span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_partitions</span><span class="params">(struct mtd_info *)</span></span>; <span class="comment">//添加、删除MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span>; <span class="comment">//从MTD设备查找MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mtd_part_parser_cleanup</span><span class="params">(struct mtd_partitions *parts)</span></span>;<span class="comment">//清除parse_mtd_partitions得到的MTD分区数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">init_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">cleanup_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//注册、清除MTD字符设备</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_mtd_user</span> <span class="params">(struct mtd_notifier *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unregister_mtd_user</span> <span class="params">(struct mtd_notifier *old)</span> <span class="comment">//注册、去注册MTD使用者（当有MTD变动时通知）</span></span></span><br></pre></td></tr></table></figure><h3 id="MTD字符设备"><a href="#MTD字符设备" class="headerlink" title="MTD字符设备"></a>MTD字符设备</h3><p>MTD字符设备定义在mtdchar.c，其中定义了字符设备的相关操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mtd_fops</span> = &#123;</span></span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.llseek= mtdchar_lseek,</span><br><span class="line">.read= mtdchar_read,</span><br><span class="line">.write= mtdchar_write,</span><br><span class="line">.unlocked_ioctl= mtdchar_unlocked_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">.compat_ioctl= mtdchar_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">.open= mtdchar_open,</span><br><span class="line">.release= mtdchar_close,</span><br><span class="line">.mmap= mtdchar_mmap,</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">.get_unmapped_area = mtdchar_get_unmapped_area,</span><br><span class="line">.mmap_capabilities = mtdchar_mmap_capabilities,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MTD块设备"><a href="#MTD块设备" class="headerlink" title="MTD块设备"></a>MTD块设备</h3><p>MTD块设备定义在mtdblock.c/mtdblock_ro.c，定义了块设备相关操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"mtdblock"</span>,</span><br><span class="line">.major= MTD_BLOCK_MAJOR,</span><br><span class="line">.part_bits= <span class="number">0</span>,</span><br><span class="line">.blksize = <span class="number">512</span>,</span><br><span class="line">.open= mtdblock_open,</span><br><span class="line">.flush= mtdblock_flush,</span><br><span class="line">.release= mtdblock_release,</span><br><span class="line">.readsect= mtdblock_readsect,</span><br><span class="line">.writesect= mtdblock_writesect,</span><br><span class="line">.add_mtd= mtdblock_add_mtd,</span><br><span class="line">.remove_dev= mtdblock_remove_dev,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">.name= <span class="string">"mtdblock"</span>,</span><br><span class="line">.major= MTD_BLOCK_MAJOR,</span><br><span class="line">.part_bits= <span class="number">0</span>,</span><br><span class="line">.blksize = <span class="number">512</span>,</span><br><span class="line">.readsect= mtdblock_readsect,</span><br><span class="line">.writesect= mtdblock_writesect,</span><br><span class="line">.add_mtd= mtdblock_add_mtd,</span><br><span class="line">.remove_dev= mtdblock_remove_dev,</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>在嵌入式设备，一个flash往往会被划分做不同的功能分区。例如，升级分区、文件系统分区、bootloader分区、配置分区、备份分区等等。代码树中的drivers/mtd/mtdpart.c实现了分区的相关操作：</p><p>以下全局变量定义了MTD分区的链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(mtd_partitions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(mtd_partitions_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>链表元素为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_part</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> <span class="title">mtd</span>;</span>      <span class="comment">//MTD信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">master</span>;</span>  <span class="comment">//MTD 设备指针</span></span><br><span class="line"><span class="keyword">uint64_t</span> offset;          <span class="comment">//主设备偏移</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相关操作为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mtd_part *<span class="title">allocate_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *part, <span class="keyword">int</span> partno, <span class="keyword">uint64_t</span> cur_offset)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分配分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtd_add_partition_attrs</span><span class="params">(struct mtd_part *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_add_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">long</span> <span class="keyword">long</span> offset, <span class="keyword">long</span> <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_del_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">int</span> partno)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加删除分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *parts, <span class="keyword">int</span> nbparts)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据分区表添加分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __<span class="title">register_mtd_parser</span><span class="params">(struct mtd_part_parser *p, struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister_mtd_parser</span><span class="params">(struct mtd_part_parser *p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//向内核注册和去注册回调函数用于MTD分区时执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span></span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li>《<a href="http://www.linux-mtd.infradead.org/doc/general.html" target="_blank" rel="noopener">General MTD documentation</a>》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么需要MTD子系统&quot;&gt;&lt;a href=&quot;#为什么需要MTD子系统&quot; class=&quot;headerlink&quot; title=&quot;为什么需要MTD子系统&quot;&gt;&lt;/a&gt;为什么需要MTD子系统&lt;/h3&gt;&lt;p&gt;嵌入式系统使用Flash作为存储设备，Flash类别有Nand、Nor等。Flash的上层是文件系统。直觉上，系统中使用这些Flash时，我们需要为每种Flash编写驱动。同时在调用Flash的文件系统做接口对接。这样，每使用一种新的Flash类型甚至型号，都得修改文件系统的编码来做适配。显然，这会造成代码的爆炸，同时也不方便大家各司其职（例如：厂商A做Flash，添加一个新的Flash需要厂商A的驱动开发人员去改写所有文件系统的接口，这显然不现实）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://l2h.site/categories/Linux/"/>
    
      <category term="Linux文件系统" scheme="http://l2h.site/categories/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://l2h.site/tags/Linux/"/>
    
      <category term="MTD" scheme="http://l2h.site/tags/MTD/"/>
    
  </entry>
  
  <entry>
    <title>教你关闭微信朋友圈的广告</title>
    <link href="http://l2h.site/2019/08/02/e6-95-99-e4-bd-a0-e5-85-b3-e9-97-ad-e5-be-ae-e4-bf-a1-e6-9c-8b-e5-8f-8b-e5-9c-88-e7-9a-84-e5-b9-bf-e5-91-8a/"/>
    <id>http://l2h.site/2019/08/02/e6-95-99-e4-bd-a0-e5-85-b3-e9-97-ad-e5-be-ae-e4-bf-a1-e6-9c-8b-e5-8f-8b-e5-9c-88-e7-9a-84-e5-b9-bf-e5-91-8a/</id>
    <published>2019-08-02T00:18:23.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>刷微信朋友圈时，是不是经常看到一些广告，有时还不小心点到上边？可以使用以下步骤关闭：</p><ul><li>电脑打开<a href="https://privacy.qq.com/advertisement.htm" target="_blank" rel="noopener">https://privacy.qq.com/advertisement.htm</a></li><li>在“二、如何管理您看到的广告”点击“<strong><em>管理</em></strong>”</li><li>此时会让您用微信扫码登录，按照提示登录即可</li><li>在“个性化服务设置”关闭“_<strong>根据您的信息展示广告</strong>_”即可</li></ul><a id="more"></a><p>注意，以上方法有效期半年，半年后需重新操作。不过不得不说微信对比其他社交软件满人性化，至少提供了可以关闭广告的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷微信朋友圈时，是不是经常看到一些广告，有时还不小心点到上边？可以使用以下步骤关闭：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;电脑打开&lt;a href=&quot;https://privacy.qq.com/advertisement.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://privacy.qq.com/advertisement.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在“二、如何管理您看到的广告”点击“&lt;strong&gt;&lt;em&gt;管理&lt;/em&gt;&lt;/strong&gt;”&lt;/li&gt;
&lt;li&gt;此时会让您用微信扫码登录，按照提示登录即可&lt;/li&gt;
&lt;li&gt;在“个性化服务设置”关闭“_&lt;strong&gt;根据您的信息展示广告&lt;/strong&gt;_”即可&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="L&amp;amp;H生活" scheme="http://l2h.site/categories/L-amp-H%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始爬草榴成人文学 (3) – 聚类和PCA</title>
    <link href="http://l2h.site/2019/07/19/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-3-e8-81-9a-e7-b1-bb-e5-92-8cpca/"/>
    <id>http://l2h.site/2019/07/19/e4-bb-8e-e9-9b-b6-e5-bc-80-e5-a7-8b-e7-88-ac-e8-8d-89-e6-a6-b4-e6-88-90-e4-ba-ba-e6-96-87-e5-ad-a6-3-e8-81-9a-e7-b1-bb-e5-92-8cpca/</id>
    <published>2019-07-19T07:58:11.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文继续上一章对爬到的数据按照文章标题进行分析。</p><p>首先使用结巴分词对爬到的标题进行分词，得到分词过后的带空格的标题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg <span class="comment">#引入词性标注接口 </span></span><br><span class="line"><span class="keyword">import</span> codecs,sys</span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_titles</span><span class="params">(df)</span>:</span></span><br><span class="line">    strs = <span class="string">' '</span>.join(jieba.cut(df[<span class="string">'lit_title'</span>&#125;,cut_all=<span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> strs</span><br><span class="line">  </span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = items.apply(<span class="keyword">lambda</span> r: split_titles(r), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>接着使用TF-IDF按照标题产生每个标题对应的TFIDF向量（因为字典并不大，可以用来作为该标题的嵌入，参考<a href="https://www.l2h.site/2019/07/19/word-embedding-model/" target="_blank" rel="noopener">本博文章</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_extraction  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer  </span><br><span class="line"></span><br><span class="line">corpus = items[<span class="string">'split_title'</span>&#125;.tolist()<span class="comment">#将文章标题视作TF-IDF的语料</span></span><br><span class="line">vectorizer=CountVectorizer()<span class="comment">#该类会将文本中的词语转换为词频矩阵，矩阵元素a[i&#125;[j&#125; 表示j词在i类文本下的词频  </span></span><br><span class="line">transformer=TfidfTransformer()<span class="comment">#该类会统计每个词语的tf-idf权值  </span></span><br><span class="line">tfidf=transformer.fit_transform(vectorizer.fit_transform(corpus))<span class="comment">#第一个fit_transform是计算tf-idf，第二个fit_transform是将文本转为词频矩阵  </span></span><br><span class="line">weight=tfidf.toarray()<span class="comment">#将tf-idf矩阵抽取出来，元素a[i&#125;[j&#125;表示j词在i类文本中的tf-idf权重</span></span><br></pre></td></tr></table></figure><p>对TFIDF嵌入处理后的向量进行PCA降维（降至2维，方便绘图）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">new_df = pd.DataFrame(weight)</span><br><span class="line">cls=KMeans(n_clusters=<span class="number">2</span>).fit(new_df)</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">new_pca = pd.DataFrame(pca.fit_transform(new_df), columns=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.scatter(new_pca[<span class="string">'A'</span>&#125;, new_pca[<span class="string">'B'</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-19-%E4%B8%8B%E5%8D%883.49.09.png" alt></p><p>按标题聚类并PCA降维后的文章分布</p><p>上图可以看出，有两类文章偏离较远，我们可以看看是什么文章：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(new_pca[new_pca[<span class="string">'B'</span>&#125;&gt;<span class="number">0.6</span>&#125;.index):</span><br><span class="line">    new_items = items.reset_index()</span><br><span class="line">    print(new_items[<span class="string">'lit_title'</span>&#125;[i&#125;)</span><br></pre></td></tr></table></figure><p>打印这些一类文章的标题后我们发现，这是两篇文章被按照章节写成多篇了。</p><p>除此之外，还可以做什么？</p><ul><li>我们的语料库是文章标题本身，内容有限，分类其实是按照标题自身进行分类的。若我们的语料库是更大的词典，经过对大语料库进行训练后，人工提供分类“武侠类”、“现代类”等等，能否将相应文章准确分类？</li><li>能否抓取文章完整内容进行分词和聚类？避免教坏小朋友，留待大家讨论</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文继续上一章对爬到的数据按照文章标题进行分析。&lt;/p&gt;&lt;p&gt;首先使用结巴分词对爬到的标题进行分词，得到分词过后的带空格的标题&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba.analyse&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; jieba.posseg &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pseg &lt;span class=&quot;comment&quot;&gt;#引入词性标注接口 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; codecs,sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;items[&lt;span class=&quot;string&quot;&gt;&#39;split_title&#39;&lt;/span&gt;&amp;#125; = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;split_titles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(df)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    strs = &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;.join(jieba.cut(df[&lt;span class=&quot;string&quot;&gt;&#39;lit_title&#39;&lt;/span&gt;&amp;#125;,cut_all=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; strs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;items[&lt;span class=&quot;string&quot;&gt;&#39;split_title&#39;&lt;/span&gt;&amp;#125; = items.apply(&lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; r: split_titles(r), axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://l2h.site/categories/Python/"/>
    
    
      <category term="草榴" scheme="http://l2h.site/tags/%E8%8D%89%E6%A6%B4/"/>
    
      <category term="PCA" scheme="http://l2h.site/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>Word Embedding（词嵌入）模型介绍</title>
    <link href="http://l2h.site/2019/07/19/word-embedding-model/"/>
    <id>http://l2h.site/2019/07/19/word-embedding-model/</id>
    <published>2019-07-19T02:08:13.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>词嵌入可以算是无监督机器学习最成功的应用之一。它不要求对数据标注，就可以从未标注预料里产生标注。单词嵌入可以从输入的字符产生量更小的向量标签，可以使得被使用到后续的其他学习任务中。</p><h2 id="词嵌入的概念"><a href="#词嵌入的概念" class="headerlink" title="词嵌入的概念"></a>词嵌入的概念</h2><p>简言之，词嵌入是指将文本转化为数字表示的方法。为什么需要词嵌入呢？</p><p>众所周知，许多机器学习算法，甚至几乎所有的深度学习算法，是无法直接处理字符串或者纯文本形式的输入。相反，他们需要数字作为各种任务的输入（例如分类、回归等）。不过，通常任务（例，网站评论中的情感分析）中大量的数据字段都是文本格式的，因此在需要学习前必须从这些文本输入中提取出数字表示的信息。因此，我们可以给词嵌入一个正式的定义：</p><a id="more"></a><blockquote><p>词嵌入方法，是将字典中的单词转化为向量的方法。</p></blockquote><p>例如，我们对如下句子做词嵌入：</p><blockquote><p>Word Embeddings are Word converted into numbers</p></blockquote><p>“词”指的是类似句子中的“Embedding”、“numbers”等</p><p>“字典”指的是句子中所有不重复单词的列表。所以，上述句子的词典是[‘Word’,’Embeddings’,’are’,’Converted’,’into’,’numbers’]</p><h2 id="词嵌入的不同方法"><a href="#词嵌入的不同方法" class="headerlink" title="词嵌入的不同方法"></a>词嵌入的不同方法</h2><p>我们当然可以使用本博客&lt;<a href="https://www.l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/" target="_blank" rel="noopener">机器学习为什么使用独热(ONE-HOT ENCODING)编码</a>&gt;介绍的独热编码进行词嵌入，这是一种较为简单的处理方式。除此之外，还有许多不同的词嵌入方法。这些词嵌入方法可以大概分为如下两类：</p><ul><li>基于频率的嵌入（简称“词频嵌入”）</li><li>基于预测的嵌入</li></ul><p>我们本节会深入介绍这两类方法。</p><h3 id="词频嵌入"><a href="#词频嵌入" class="headerlink" title="词频嵌入"></a>词频嵌入</h3><p>现行流行的词频嵌入方法包括如下几类的嵌入向量：</p><ul><li>Count Vector</li><li>TF_IDF Vector</li><li>Co-Occurence Vector</li></ul><h4 id="Count-Vector"><a href="#Count-Vector" class="headerlink" title="Count Vector"></a>Count Vector</h4><p>考虑包括如下D个文档$${d_1,d_2,…..,d_D}$$的语料库及从C中提取的N个唯一单词。这N个唯一单词组成我们的字典，对应Count Vector矩阵M的大小为$$D*N$$。矩阵M的每一行为$$d_i$$文档中的单词频率。</p><p>举个简单的例子：</p><ul><li>$$d_1$$: He is a lazy boy. She is also lazy</li><li>$$d_2$$: Neeraj is a lazy person</li></ul><p>这两个文档形成字典：[‘He’,’She’,’lazy’,’boy’,’Neeraj’,’person’]，这里D=2，N=6，则该2*6矩阵M可作如下表示：</p><p>He</p><p>She</p><p>lazy</p><p>boy</p><p>Neeraj</p><p>person</p><p>$$d_1$$</p><p>1</p><p>1</p><p>2</p><p>1</p><p>0</p><p>0</p><p>$$d_2$$</p><p>0</p><p>0</p><p>1</p><p>0</p><p>1</p><p>1</p><p>这里，每一行代表的是文档集合中的一个文档，每一列代表的是单词。这样，矩阵中的一列就代表对应单词的词向量。例如，“lazy”的词向量为[2,1]。</p><p>很简单不是吗。不过这里有很多不同的形成矩阵M的变种方法。主要有两大类：</p><ul><li>字典的形成方式。以上为一个理想的例子，但一个现实问题往往有成千上万个文本作为语料。所以向量往往是成千上万列。而一种替代的表示方法是取其中10000个单词作为字典。</li><li>每个单词数量的表示方式。我们可以用单词出现的数量或者是单词是否出现来表示（一般是采用前者）。</li></ul><p>下图帮忙理解矩阵M的形式：</p><p><img src="http://pic.l2h.site/count-vector.png" alt></p><h4 id="TF-IDF-Vector"><a href="#TF-IDF-Vector" class="headerlink" title="TF-IDF Vector"></a>TF-IDF Vector</h4><p>TF-IDF是另外一种基于词频的方法，但是计算词频时不仅仅考虑单个文档而是整个预料。这其中的原理是什么呢？</p><p>常用词‘is’、‘the’、‘a’等词在英文文档中通常出现的频率超过文档的主要词汇。例如，描述梅西的文档中会比其他文档更常出现‘Messi’一词。但是诸如‘the’一词在所有文档（当然是英文文档）都以很高频率出现。</p><p>理想状态下，我们更希望降低这些在所有文档中都会出现的词，相反提升其他文档相关性更高单词的频率。TF-IDF的工作原理，便是给这些常现词一些惩罚，赋予更低的权重。我们以如下两个文档范例看TF-IDF的工作方式：</p><p><img src="http://pic.l2h.site/Tf-IDF.png" alt></p><p>与TF-IDF相关的定义有如下：</p><p>$$f()=TF =\frac{t单词出现在文档的次数}{文档中单词的总数量}$$</p><p>因此 TF(This, Document1) = 1/8, TF(This, Document2) = 1/5</p><p>TF代表了单词对文档的“贡献”。即，与文档相关的单词应该出现频率更高。例，关于梅西的文档里，“梅西”单词出现的频率一定很高。</p><p>$$IDF=log(N/n)$$</p><p>其中N代表文档的数量，n代表t单词有出现的文档的数量。因此IDF(This)=log(2/2)=0</p><p>因此如何解释IDF背后的原理？一般情况下，如果一个单词在所有的单词中都出现，那么很有可能这个单词与某一个特定的文档关联不大。如果单词只在一部分文档中出现，那么该单词与其所出现的文档关联的可能性就较大。我们可以计算上例中“Messi”一词的IDF为：</p><p>$$IDF(Messi)=log(2/1)=0.301$$</p><p>现在，让我们来对比“This”和“Messi”对Document1的关联性。</p><blockquote><p>TF-IDF(This, Document1) = (1/8)*(0)=0</p><p>TF-IDF(This, Document2)=(1/5)*(0)=0</p><p>TF-IDF(Messi, Document1) = (4/8)*0.301 = 0.15  </p></blockquote><p>因此我们可以看到，对Document1，TF-IDF方法对“This”赋予较小的权重，远小于单词“Messi”。因此在整个语料库里，“Messi”对Document1是非常重要的单词。</p><h4 id="固定上下文窗口的Co-Occurence矩阵"><a href="#固定上下文窗口的Co-Occurence矩阵" class="headerlink" title="固定上下文窗口的Co-Occurence矩阵"></a>固定上下文窗口的Co-Occurence矩阵</h4><p>该方法主要思想为：类似的单词有一起出现的倾向，也有相同的上下文。例，苹果是一种水果，芒果也是一种水果。苹果和芒果倾向于有相同的上下文。即，水果。</p><p>我们先理解一下Co-Occurence和上下文窗口的含义，再具体介绍该方法。</p><p>Co-Occurence：给定语料，一对单词W1和W2的Co-Occurence指的是他们在一个上下文窗口一起出现的次数。</p><p>Context Window: 上下文窗口由一个数字和方向指定。让我们看如下例子：</p><p>Quick</p><p>Brown</p><p>Fox</p><p>Jump</p><p>Over</p><p>The</p><p>Lazy</p><p>Dog</p><p>紫色框字体是“Fox”的大小为2的上下文窗口，当计算co-occurence时，只有这些单词会算在内。同理，对单词“Over”的上下文窗口为：</p><p>Quick</p><p>Brown</p><p>Fox</p><p>Jump</p><p>Over</p><p>The</p><p>Lazy</p><p>Dog</p><p>因此，让我们使用一个范例语料来描述Co-Occurence矩阵。语料为： He is not lazy. He is intelligent. He is smart。则语料矩阵为：</p><p><strong>He</strong></p><p><strong>is</strong></p><p><strong>not</strong></p><p><strong>lazy</strong></p><p><strong>intelligent</strong></p><p><strong>smart</strong></p><p><strong>He</strong></p><p>0</p><p>4</p><p>2</p><p>1</p><p>2</p><p>1</p><p><strong>is</strong></p><p>4</p><p>0</p><p>1</p><p>2</p><p>2</p><p>1</p><p><strong>not</strong></p><p>2</p><p>1</p><p>0</p><p>1</p><p>0</p><p>0</p><p><strong>lazy</strong></p><p>1</p><p>2</p><p>1</p><p>0</p><p>0</p><p>0</p><p><strong>intelligent</strong></p><p>2</p><p>2</p><p>0</p><p>0</p><p>0</p><p>0</p><p><strong>smart</strong></p><p>1</p><p>1</p><p>0</p><p>0</p><p>0</p><p>0</p><p>上图中红色的单元表示”He”和”is”在2长度的上下文窗口的值为4，而“lazy”和“intelligent”的上下文窗口值为0。</p><p>但是真实的语料库往往有很多单词，如果构建像上表一样的N*N矩阵，对计算机处理起来复杂度过高。因此这个矩阵往往是N*M大小的矩阵，其中M为N的子集。即选择字典中的最重要的一些单词作为矩阵的其一维度。选择的方法有SVD，PCA分析等方法。</p><p>Co-Occurence矩阵的优势：</p><ul><li>保留了单词间的语义关系。例如“男人”和“女人”的距离近过“男人”和“苹果”</li><li>使用SVD作为其核心，比现有其他方法来输出更为精确的单词向量。</li><li>只需要做一次计算，之后可直接使用。</li></ul><p>Co-Occurence矩阵的缺点：</p><ul><li>使用大量的内存来存储Co-Occurence矩阵。当然，有一些现有的方法可以减轻该问题。</li></ul><h3 id="基于预测的嵌入"><a href="#基于预测的嵌入" class="headerlink" title="基于预测的嵌入"></a>基于预测的嵌入</h3><p>上述基于词频的计算单词嵌入方法的应用范围有限。直到word2vec这种基于预测的嵌入方法被提出并广泛应用到现有的各种场景中。而Wordvec并不是一个单独的算法，而是两种算法模型：CBOW（Continuous bag of words）和Skip-gram的组合。这两种方法均是浅神经网络，可以接受单词作为输入，同样使用单词作为输出，并映射为向量。下面分别进行介绍。</p><h4 id="CBOW-Continuous-Bag-of-words"><a href="#CBOW-Continuous-Bag-of-words" class="headerlink" title="CBOW(Continuous Bag of words)"></a>CBOW(Continuous Bag of words)</h4><p>CBOW模型工作的原理是根据输入的上下文来预测输出单词的概率。上下文可能为一个单词，或者是一组单词。为了描述方便，我们以一个单词作为输入来预测一个单词输出。</p><p>假设我们的语料为 C = “Hey, this is sample corpus using only one context word.”同时定义上下文窗口为1。输入语料可以以如下<a href="https://www.l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/" target="_blank" rel="noopener">独热编码</a>方式呈现：</p><p><img src="http://pic.l2h.site/cbow1-1024x289.png" alt></p><p>上述矩阵被送到一个三层神经网络来训练：包含输入层，隐层和输出层。其中输出层是一个softmax层，用来呈现输出层为某个单词的可能性。</p><p>下图呈现了CBOW的网络模型：</p><p><img src="http://pic.l2h.site/Screenshot-from-2017-06-04-22-40-29.png" alt></p><p>上面架构的矩阵表示如下图：</p><p><img src="http://pic.l2h.site/Screenshot-from-2017-06-04-22-19-202-1024x154.png" alt></p><p>计算方法如下：</p><ul><li>输入层和输出均为[1*V]的独热向量，V表示上述语料的字典大小</li><li>输入层和隐层，以及隐层和输出层分别有节点间权重矩阵大小为[V*N]，以及[N*V]。N为隐层神经元的数量，这里N=4</li><li>层与层之间没有激活函数</li><li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）</li><li>隐藏输出乘以隐层-输出层权重得到输出</li><li>根据输出使用逆传播算法来调整权重</li><li>隐藏-输出层权重被用作最后的词向量</li></ul><p>以上为一个输入的例子，假如是多个输入呢？</p><p><img src="http://pic.l2h.site/1-1.png" alt></p><p>上述为多个输入的神经网络架构，而下图为其矩阵表示：</p><p><img src="http://pic.l2h.site/2-3-1024x150.png" alt></p><p>输入三个上下文单词预测一个目标单词。输入可以用三个独热向量表示。上述输入层有3个[1*V]向量作为输入，以及一个[1*V]向量作为输出。</p><p>以上计算方法与单输入的CBOW模型类似。只不过最终的输出为多个权重矩阵的算术平均值</p><p>上述算法与一般神经网络类似，主要差异在于：</p><ul><li>不同于计算算术平方误差作为损失，CBOW是计算最小化选中单词的负对数似然</li><li>CBOW每层神经元未使用激活函数做非线性化激活</li></ul><h4 id="Skip-–-Gram模型"><a href="#Skip-–-Gram模型" class="headerlink" title="Skip – Gram模型"></a>Skip – Gram模型</h4><p>Skip-gram模型与CBOW架构类似。不过其核心思想与CBOW正好相反，是给定单词预测期上下文。架构如图：</p><p><img src="http://pic.l2h.site/3-1.png" alt></p><p>其矩阵形式架构如图：</p><p><img src="http://pic.l2h.site/4-1024x223.png" alt></p><p>输入层大小为[1*V]，输入-隐层权重矩阵大小[V*N]，输出-权重矩阵[N*V]，输出层大小[1*V]</p><p>计算方法如下：</p><ul><li>上图红色输入为独热编码</li><li>中间桔黄色矩阵为隐层-输出层权重矩阵。</li><li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）， 桔黄色矩阵乘以 “隐层激活(Hidden Activation)” 得到蓝色矩阵</li><li>图右蓝色矩阵的每行使用Softmax进行计算得到图右绿色矩阵。</li><li>图右灰色矩阵为输入单词上下文的2两个单词的独热编码。使用绿色矩阵逐行减去灰色矩阵，得到误差向量</li><li>对所有的输入计算误差向量后求和得到损失，并进行逆传播优化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了基于词频和基于预测的两种嵌入方式，并对其中的常用模型进行了介绍。其中基于预测的嵌入方式是现行较为常用且有效的方式。其模型CBOW和Skip-Gram分别为使用上下文预测单词和使用单词预测上下文的两种不同模型，均为广泛使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;词嵌入可以算是无监督机器学习最成功的应用之一。它不要求对数据标注，就可以从未标注预料里产生标注。单词嵌入可以从输入的字符产生量更小的向量标签，可以使得被使用到后续的其他学习任务中。&lt;/p&gt;&lt;h2 id=&quot;词嵌入的概念&quot;&gt;&lt;a href=&quot;#词嵌入的概念&quot; class=&quot;headerlink&quot; title=&quot;词嵌入的概念&quot;&gt;&lt;/a&gt;词嵌入的概念&lt;/h2&gt;&lt;p&gt;简言之，词嵌入是指将文本转化为数字表示的方法。为什么需要词嵌入呢？&lt;/p&gt;&lt;p&gt;众所周知，许多机器学习算法，甚至几乎所有的深度学习算法，是无法直接处理字符串或者纯文本形式的输入。相反，他们需要数字作为各种任务的输入（例如分类、回归等）。不过，通常任务（例，网站评论中的情感分析）中大量的数据字段都是文本格式的，因此在需要学习前必须从这些文本输入中提取出数字表示的信息。因此，我们可以给词嵌入一个正式的定义：&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Embedding" scheme="http://l2h.site/tags/Embedding/"/>
    
      <category term="嵌入" scheme="http://l2h.site/tags/%E5%B5%8C%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>机器学习术语归纳</title>
    <link href="http://l2h.site/2019/07/15/machine-learning-terms/"/>
    <id>http://l2h.site/2019/07/15/machine-learning-terms/</id>
    <published>2019-07-15T07:30:50.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>初学机器学习，往往容易淹没在浩瀚的属于中，本文归纳总结一下机器学习相关的术语，帮您更好理解神经网络</p><p>本文大部分翻译自<a href="http://www.wildml.com/deep-learning-glossary/" target="_blank" rel="noopener">wildml.com</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="Activation-Function（激活函数）"><a href="#Activation-Function（激活函数）" class="headerlink" title="Activation Function（激活函数）"></a>Activation Function（激活函数）</h4><p>使用非线性函数对训练模型中的输出（当然不限于最终输出）进行非线性化处理，这样神经网络可以学习到复杂的决策边界。常用的激活函数包括  <a href="https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank" rel="noopener">sigmoid</a>, <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" target="_blank" rel="noopener">tanh</a>, <a href="http://www.wildml.com/deep-learning-glossary/#relu" target="_blank" rel="noopener">ReLU (Rectified Linear Unit)</a>以及众多的变种.</p><a id="more"></a><h4 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h4><p>一直基于梯度下降的学习算法，可以自适应调整参数的学习速率。作为<br> <a href="http://www.wildml.com/deep-learning-glossary/#adagrad" target="_blank" rel="noopener">Adagrad</a> 的变种，对超参数敏感，容易造成学习速率过快下降。可以作为标准<br> <a href="http://www.wildml.com/deep-learning-glossary/#sgd" target="_blank" rel="noopener">SGD</a>替代。相关文献：</p><ul><li><p><a href="http://arxiv.org/abs/1212.5701" target="_blank" rel="noopener">ADADELTA: An Adaptive Learning Rate Method</a></p></li><li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p></li><li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p></li></ul><h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><p>Adagrad是一种自适应调整学习速率的算法，它会追踪梯度平方的变化，并对学习速率做自适应调整。对稀疏数据处理非常有效（会对不常更新的参数加快学习速率）。</p><ul><li><p><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a>  </p></li><li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p></li><li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p></li></ul><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><p>类似于 <a href="http://www.wildml.com/deep-learning-glossary/#rmsprop" target="_blank" rel="noopener">rmsprop</a> 的学习速率更新算法，更新主要采取即时的第一和第二时刻平均值。另外算法也包括了bias纠正单元，相关文献：</p><ul><li><a href="http://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam: A Method for Stochastic Optimization</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h4 id="Affine-Layer"><a href="#Affine-Layer" class="headerlink" title="Affine Layer"></a>Affine Layer</h4><p>神经网络的一种全连接层。Affine的含义是：每个上层的神经元链接当前层的神经元，即这是标准的神经网络层。Affine层通常会与 <a href="http://www.wildml.com/deep-learning-glossary/#cnn" target="_blank" rel="noopener">Convolutional Neural Networks</a> 或者 <a href="http://www.wildml.com/deep-learning-glossary/#rnn" target="_blank" rel="noopener">Recurrent Neural Networks</a>  一起使用，用于最终产生一个决策。函数形式通常是$$y=f(Wx+b)$$。W,X,b分别是权值，输入和偏移向量。f通常为非线性函数</p><h4 id="Attention-Mechanism"><a href="#Attention-Mechanism" class="headerlink" title="Attention Mechanism"></a>Attention Mechanism</h4><p>Attention Mechanisms（注意力机制）灵感的源于人类视觉注意力特点 ：可以关注图片上的特定某个区域。注意力机制可以与自然语言处理或者图片识别结构一起工作，帮助神经网络学习到进行决策时该“注意”到哪些部分。相关文献：</p><ul><li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">Attention and Memory in Deep Learning and NLP</a></li></ul><h4 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h4><p>Alexnet是大优势赢得2012年ILSVRC竞赛使用的CNN架构，它使大家重新对使用_<strong>CNN网络</strong>_识别图片的产生兴趣。它由5层卷积层组成，部分卷积层后跟随池化层，最后的全连接层是1000路的softmax分类。Alexnet的介绍见<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a>.</p><h4 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h4><p>Autoencoder是一种神经网络模型，目标为通过网络中的一些“瓶颈”来预测网络的输入。通过引入瓶颈，强制网络学习到输入的低维度映射，从而有效地压缩输入维度。Autoencoders与PCA即一些其他降维技术有关，因为其本质上的非线性化特点，可以处理更复杂的映射。现有大量的autoencoder架构，包括<a href="http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf" target="_blank" rel="noopener">Denoising Autoencoders</a>,、<a href="http://arxiv.org/abs/1312.6114" target="_blank" rel="noopener">Variational Autoencoders</a>,或者<a href="http://arxiv.org/abs/1511.01432" target="_blank" rel="noopener">Sequence Autoencoders</a></p><h4 id="Average-Pooling"><a href="#Average-Pooling" class="headerlink" title="Average-Pooling"></a>Average-Pooling</h4><p>Average-Pooling是<strong><em>卷积神经网络</em></strong>识别图片采用的一种池化技术。工作原理为使用小于图片的窗口在图片特征上进行滑动，取得滑动位置上数值的平均值。从而降低数据特征的维度，同时有效保持数据的特征。与之类似的有最大值池化等方法。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="Backpropagation（逆传播，后向传播）"><a href="#Backpropagation（逆传播，后向传播）" class="headerlink" title="Backpropagation（逆传播，后向传播）"></a>Backpropagation（逆传播，后向传播）</h4><p>Backpropagation是有效计算神经网络梯度的方法。它通过微分运算，有效地将误差从输出位置传递到输入位置。它与上世纪70年代开始被使用。文献：</p><ul><li><a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="noopener">Calculus on Computational Graphs: Backpropagation</a></li></ul><h4 id="Backpropagation-Through-Time-BPTT"><a href="#Backpropagation-Through-Time-BPTT" class="headerlink" title="Backpropagation Through Time (BPTT)"></a>Backpropagation Through Time (BPTT)</h4><p>Backpropagation Through Time (<a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">paper</a>)是<strong><em>循环神经网络</em></strong>使用的逆传播算法。RNN的网络结构与传统的网络结构不同（每个阶段的神经单元共享参数），因此采用的逆传播也稍后差异。相关介绍见</p><ul><li><a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">Backpropagation Through Time: What It Does and How to Do It</a></li></ul><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><p>Batch Normalization是对神经网络层输入数据进行小批量分组使用的技术。使用小批量数据分组而非完整数据包可以加速训练速度。其在<strong><em>卷积神经网络</em></strong>或者_<strong>前向神经网络</strong>_使用中被证明非常有效，不过其目前在<strong>循环神经网络</strong>的使用中，效果有限</p><ul><li><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="noopener">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li><li><a href="http://arxiv.org/abs/1510.01378" target="_blank" rel="noopener">Batch Normalized Recurrent Neural Networks</a></li></ul><h4 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h4><p>双向循环神经网络是包含两个不同走向循环神经网络的网络。正向RNN从前向后读取输入序列，逆向RNN反之。两个RNN互相交叠，输出由这两个RNN的隐藏层的状态决定。双向RNN主要被用于自然语言处理问题（例，处理一个单词需要考虑单词前后的单词）。相关文献</p><ul><li><a href="http://www.di.ufpe.br/~fnj/RNA/bibliografia/BRNN.pdf" target="_blank" rel="noopener">Bidirectional Recurrent Neural Networks</a></li></ul><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h4><p><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a> 是 Berkeley Vision和Learning Center开发的深度学习框架，在处理视觉处理问题和CNN模型方面非常有用。</p><h4 id="Categorical-Cross-Entropy-Loss"><a href="#Categorical-Cross-Entropy-Loss" class="headerlink" title="Categorical Cross-Entropy Loss"></a>Categorical Cross-Entropy Loss</h4><p>分类交叉熵损失也被称作负对数似然，它是处理分类问题或者评估概率分布相似性的方法，特别是用于评估真值标签。其公式为$$L = -sum(y * log(y_prediction))$$，其中y是真标签的概率分布（独热向量），$$y_prediction$$是已预测标签的概率分布（一般使用softmax函数）</p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>深度学习模型的输入数据可以有多个通道。例如，图片有RGB三个通道。因此图片可以被一个3维张量表示，分别是通道、高度和宽度。自然语言处理数据也有多个通道的概念。例如，数据有不同类别的_<strong>嵌入</strong>_表示。</p><h4 id="Convolutional-Neural-Network-CNN-ConvNet"><a href="#Convolutional-Neural-Network-CNN-ConvNet" class="headerlink" title="Convolutional Neural Network (CNN, ConvNet)"></a>Convolutional Neural Network (CNN, ConvNet)</h4><p>卷积神经网络使用卷积层从输入数据中提取有效特征。通常卷积神经网络由卷积、池化和全连接层组成。因为其在视觉处理任务的出色表现，卷积神经网络近年来一直非常流行。相关文章：</p><ul><li><a href="http://cs231n.github.io/" target="_blank" rel="noopener">Stanford CS231n class – Convolutional Neural Networks for Visual Recognition</a></li><li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">Understanding Convolutional Neural Networks for NLP</a></li></ul><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="Deep-Belief-Network-DBN"><a href="#Deep-Belief-Network-DBN" class="headerlink" title="Deep Belief Network (DBN)"></a>Deep Belief Network (DBN)</h4><p>深度信念网络，通过无监督的概率图模型来学习数据特征。DBN由多个隐层组成，前后隐层的神经元间相互连接。每层神经网络由受限玻尔兹曼机组成，分别进行训练层。</p><ul><li><a href="https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf" target="_blank" rel="noopener">A fast learning algorithm for deep belief nets</a></li></ul><h4 id="Deep-Dream"><a href="#Deep-Dream" class="headerlink" title="Deep Dream"></a>Deep Dream</h4><p>Google发明的一项技术，对深度卷积神经网络学习到的数据进行提取，并用于生成新图片、修改图片甚至给图片加入梦幻般的效果。相关资料：</p><ul><li><a href="https://github.com/google/deepdream" target="_blank" rel="noopener">Deep Dream on Github</a></li><li><a href="http://googleresearch.blogspot.ch/2015/06/inceptionism-going-deeper-into-neural.html" target="_blank" rel="noopener">Inceptionism: Going Deeper into Neural Networks</a></li></ul><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>随机失活是神经网络中用于避免过拟合的一种方法。最早被用于CNN网络，目前被广泛使用到其他神经网络中。相关资料：</p><ul><li><a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf" target="_blank" rel="noopener">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li><li><a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="noopener">Recurrent Neural Network Regularization</a></li></ul><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="Embedding（嵌入）"><a href="#Embedding（嵌入）" class="headerlink" title="Embedding（嵌入）"></a>Embedding（嵌入）</h4><p>嵌入指的是将单词或者句子映射成向量形式。比较流行的嵌入是单词嵌入（例如，<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a> 或 <a href="http://www.wildml.com/deep-learning-glossary/#glove" target="_blank" rel="noopener">GloVe</a>）。我们也可以嵌入句子、段落或者图片。比如说，通过映射图片和他们的文字描述到嵌入空间来减少他们之间的距离，来将图片和对应的标签进行关联。嵌入可以单独进行（如采用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>），也可以作为某个机器学习任务的一部分，例如情感分析。通常，神经网络的输入均是已经训练和优化过的数据。</p><h4 id="Exploding-Gradient-Problem（梯度爆炸问题）"><a href="#Exploding-Gradient-Problem（梯度爆炸问题）" class="headerlink" title="Exploding Gradient Problem（梯度爆炸问题）"></a>Exploding Gradient Problem（梯度爆炸问题）</h4><p>梯度爆炸问题与梯度消失问题正好相反。在深度神经网络中，逆传播过程可能会造成梯度爆炸从而产生数字溢出。一种解决梯度爆炸的方式是<a href="http://www.wildml.com/deep-learning-glossary/#gradient-clipping" target="_blank" rel="noopener">梯度修剪</a></p><ul><li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><h4 id="Fine-Tuning"><a href="#Fine-Tuning" class="headerlink" title="Fine-Tuning"></a>Fine-Tuning</h4><p>优化调节指的是从另外的任务得到优化过的初始化学习参数。例如，使用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>对自然语言处理任务的单词做预处理</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h4 id="Gradient-Clipping"><a href="#Gradient-Clipping" class="headerlink" title="Gradient Clipping"></a>Gradient Clipping</h4><p>梯度修剪主要用于避免深度神经网络（特别是循环神经网络）的梯度爆炸问题。进行梯度修剪的方式有多种，一种常用的方式是对梯度进行L2正则化（new_gradients = gradients * threshold / l2_norm(gradients)），参考：</p><ul><li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h4 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h4><p>Glove是一种用于单词嵌入的无监督学习算法。Glove向量和wordvec用途相同，但是表示有差异，这是由于用于嵌入方式不同</p><ul><li><a href="http://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="noopener">GloVe: Global Vectors for Word Representation</a></li></ul><h4 id="GoogleLeNet"><a href="#GoogleLeNet" class="headerlink" title="GoogleLeNet"></a>GoogleLeNet</h4><p>赢得2014年ILSVRC挑战的卷积神经网络框架。它使用记忆模块减少参数，同时提升对计算资源的有效利用率。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li></ul><h4 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h4><p>GRU( Gated Recurrent Unit ,门循环单元)是LSTM单元的简化形式，有更少的参数。类似于LSTM神经元，它使用门策略来避免梯度消失问题，使得RNN有效地学习长范围的关联。GRU内部有重置和更新门来决定旧的记忆是否需要保留还是要用当前时间的新值进行更新。参考：</p><ul><li><a href="http://arxiv.org/abs/1406.1078v3" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ul><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><h4 id="Highway-Layer"><a href="#Highway-Layer" class="headerlink" title="Highway Layer"></a>Highway Layer</h4><p>Highway Layer (<a href="http://arxiv.org/abs/1505.00387" target="_blank" rel="noopener">论文参考</a>)是使用门策略来控制神经网络层信息流的机制。叠加使用多个Highway层可以训练非常深层次的神经网络。Highway通过门函数选择输入的那个部分通过以及那个部分需要通过变化函数处理。Highway层的基本公式为$$T * h(x) + (1 - T) * x$$，其中T是学习门函数，值位于0和1之间，h(x)是任意输入变化函数，x为输入数据。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><h4 id="ICML"><a href="#ICML" class="headerlink" title="ICML"></a>ICML</h4><p> <a href="http://icml.cc/" target="_blank" rel="noopener">International Conference for Machine Learning</a>, 机器学习领域顶级会议</p><h4 id="ILSVRC"><a href="#ILSVRC" class="headerlink" title="ILSVRC"></a>ILSVRC</h4><p><a href="http://www.image-net.org/challenges/LSVRC/" target="_blank" rel="noopener">ImageNet Large Scale Visual Recognition Challenge</a> 是图像识别分类领域最热门的竞赛。</p><h4 id="Inception-Module"><a href="#Inception-Module" class="headerlink" title="Inception Module"></a>Inception Module</h4><p>记忆单元用于卷积神经网络，提升网络的计算性能。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li></ul><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><h4 id="KerasK"><a href="#KerasK" class="headerlink" title="KerasK"></a>Keras<a href="http://keras.io/" target="_blank" rel="noopener">K</a></h4><p><a href="http://keras.io/" target="_blank" rel="noopener">Keras</a>是包含对深度学习进行深度封装的Python库。可以在<a href="http://www.wildml.com/deep-learning-glossary/#tensorflow" target="_blank" rel="noopener">TensorFlow</a>, <a href="http://www.wildml.com/deep-learning-glossary/#theano" target="_blank" rel="noopener">Theano</a>, 或 <a href="https://github.com/Microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>上层使用</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>长期短记忆网络主要用记忆门来避免RNN网络的梯度消失问题。利用LSTM单元计算RNN隐层，可以有效的传递梯度以及学习长范围关联。参考：</p><ul><li><a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Long Short-Term Memory</a></li><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li><li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li></ul><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><h4 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max-Pooling"></a>Max-Pooling</h4><p>最大池化是卷积神经网络的一种池化操作，池化时选择特征片段里的最大值，是卷积神经网络的常用池化操作。</p><h3 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h3><h4 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h4><p> MNIST 数据集 是最常使用的图像识别数据集了。基本上也是许多机器学习课程的范例数据集，更多介绍直接参考<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">官网</a>即可。</p><h4 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h4><p>Momentum是梯度下降算法的扩展，加速和优化了参数更新过程。实际使用中，加入momentum到梯度下降中，可以使深度网络得到更好的收敛 。参考：</p><ul><li><a href="http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html" target="_blank" rel="noopener">Learning representations by back-propagating errors</a></li></ul><h4 id="Multilayer-Perceptron-MLP"><a href="#Multilayer-Perceptron-MLP" class="headerlink" title="Multilayer Perceptron (MLP)"></a>Multilayer Perceptron (MLP)</h4><p>多层感知是一种多全连接层的前馈神经网络，使用<strong>激活函数</strong>处理数据做非线性化。MLP是多层神经网络或深度神经网络的最基本形式。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><h4 id="Negative-Log-Likelihood-NLL"><a href="#Negative-Log-Likelihood-NLL" class="headerlink" title="Negative Log Likelihood (NLL)"></a>Negative Log Likelihood (NLL)</h4><p>见 <a href="http://www.wildml.com/deep-learning-glossary/#ce-loss" target="_blank" rel="noopener">Categorical Cross Entropy Loss</a>.</p><h4 id="Neural-Machine-Translation-NMT"><a href="#Neural-Machine-Translation-NMT" class="headerlink" title="Neural Machine Translation (NMT)"></a>Neural Machine Translation (NMT)</h4><p>神经机器翻译指的是使用神经网络来翻译语言。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to sequence learning with neural networks</a></li><li><a href="http://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li></ul><h4 id="Neural-Turing-Machine-NTM"><a href="#Neural-Turing-Machine-NTM" class="headerlink" title="Neural Turing Machine (NTM)"></a>Neural Turing Machine (NTM)</h4><p>神经图灵机可以从范例中推导简单的算法。例如，NTM可以从输入输出范例中学习分类算法。在程序运行时神经图灵机通常可以学习到一些处理状态的记忆方法</p><ul><li><a href="http://arxiv.org/abs/1410.5401" target="_blank" rel="noopener">Neural Turing Machines</a></li></ul><h4 id="Nonlinearity（去线性化）"><a href="#Nonlinearity（去线性化）" class="headerlink" title="Nonlinearity（去线性化）"></a>Nonlinearity（去线性化）</h4><p>见<strong><em>激活函数</em></strong>.</p><h4 id="Noise-contrastive-estimation-NCE"><a href="#Noise-contrastive-estimation-NCE" class="headerlink" title="Noise-contrastive estimation (NCE)"></a>Noise-contrastive estimation (NCE)</h4><p>噪声对比评估是一种在大量词汇表输出常见用来训练分类器的损失抽样方法。通过计算所有可能分类的Softmax是代价昂贵的。而使用NCE，可以有效减少二分类问题的代价，而只需要通过从“真”分布和人工产生的噪声分布区来训练分类器。例如：</p><ul><li><a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf" target="_blank" rel="noopener">Noise-contrastive estimation: A new estimation principle for unnormalized statistical models</a></li><li><a href="http://papers.nips.cc/paper/5165-learning-word-embeddings-efficiently-with-noise-contrastive-estimation.pdf" target="_blank" rel="noopener">Learning word embeddings efficiently with noise-contrastive estimation</a></li></ul><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><h4 id="Pooling"><a href="#Pooling" class="headerlink" title="Pooling"></a>Pooling</h4><p>见<strong><em>最大池化</em></strong>和<strong><em>平均池化</em></strong>.</p><h4 id="Restricted-Boltzmann-Machine-RBN"><a href="#Restricted-Boltzmann-Machine-RBN" class="headerlink" title="Restricted Boltzmann Machine (RBN)"></a>Restricted Boltzmann Machine (RBN)</h4><p>受限玻尔兹曼机是深度信念网络使用的一种概率图模型。参考：</p><ul><li><a href="http://www-psych.stanford.edu/~jlm/papers/PDP/Volume%201/Chap6_PDP86.pdf" target="_blank" rel="noopener">Chapter 6: Information Processing in Dynamical Systems: Foundations of Harmony Theory</a></li><li><a href="http://image.diku.dk/igel/paper/AItRBM-proof.pdf" target="_blank" rel="noopener">An Introduction to Restricted Boltzmann Machines</a></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><h4 id="Recurrent-Neural-Network-RNN"><a href="#Recurrent-Neural-Network-RNN" class="headerlink" title="Recurrent Neural Network (RNN)"></a>Recurrent Neural Network (RNN)</h4><p>RNN代表循环神经网络，参考<a href="https://www.l2h.site/2019/07/13/%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9crnn%e7%ae%80%e5%8d%95%e7%90%86%e8%a7%a3/" target="_blank" rel="noopener">本站文章</a>，或者：</p><ul><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li><li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></li></ul><h4 id="Recursive-Neural-Network"><a href="#Recursive-Neural-Network" class="headerlink" title="Recursive Neural Network"></a>Recursive Neural Network</h4><p>递归神经网络是循环神经网络的一种树状形式。详情参见：</p><ul><li><a href="http://ai.stanford.edu/~ang/papers/icml11-ParsingWithRecursiveNeuralNetworks.pdf" target="_blank" rel="noopener">Parsing Natural Scenes and Natural Language with Recursive Neural Networks</a></li></ul><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>线性整流函数（Rectified Linear Unit）是一种激活函数，深度学习中做去线性化处理。参考：</p><ul><li><a href="http://arxiv.org/abs/1502.01852" target="_blank" rel="noopener">Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification</a></li><li><a href="http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf" target="_blank" rel="noopener">Rectifier Nonlinearities Improve Neural Network Acoustic Models</a></li><li><a href="http://www.cs.toronto.edu/~fritz/absps/reluICML.pdf" target="_blank" rel="noopener">Rectified Linear Units Improve Restricted Boltzmann Machines</a></li></ul><h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>深度残差网络（Deep Residual Network），赢得了ILSVRC 2015挑战赛，参考。</p><ul><li><a href="http://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">Deep Residual Learning for Image Recognition</a></li></ul><h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>RMSProp是一种基于梯度的优化算法。具体算法介绍见 ：</p><ul><li><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="noopener">Neural Networks for Machine Learning Lecture 6a</a></li><li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><h4 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h4><p>序列到序列模型读取血量作为输入，产生另外一个序列作为输出。与RNN不同的地方是，在产生输出之前，输入序列被一次性完整的输入。一般使用两个RNN实现，经典应用为机器翻译、编解码等，参考：</p><ul><li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></li></ul><h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><p>随机梯度下降是一种有效的梯度优化算法(<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="noopener">Wikipedia</a>)，其扩展算法包括 <strong>Momentum</strong>, <strong>Adagrad</strong>, <strong>rmsprop</strong>, <strong>Adadelta</strong> 以及 <strong>Adam</strong>.参考：</p><ul><li><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a></li><li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li><li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li></ul><h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p><a href="https://baike.baidu.com/item/Softmax%E5%87%BD%E6%95%B0/22772270?fr=aladdin" target="_blank" rel="noopener">Softmax函数</a>，它能将一个含任意实数的K维向量 “压缩”到另一个K维实向量 中，使得每一个元素的范围都在 （0,1）之间，并且所有元素的和为1。主要作为处理分类问题的输出</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><h4 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a> 是Google提供的开源深度学习框架，可以对数据流图做计算，也封装了现行主要的神经网络运算。支持C++/Python.</p><h4 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h4><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a> 是一个封装深度神经网络算法的Python库</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><h4 id="Vanishing-Gradient-Problem"><a href="#Vanishing-Gradient-Problem" class="headerlink" title="Vanishing Gradient Problem"></a>Vanishing Gradient Problem</h4><p>梯度消失问题在深度神经网络学习中越来越常见，特别是循环神经网络，使用较小的梯度（位于0和1直接）。因为梯度在逆传播过程中会相乘，所以会在层与层传递间逐渐“消失”，导致长范围的关联消失。解决方法主要有使用<strong>ReLU</strong>激活，或者使用改进网络<strong><em>LSTM</em></strong>等。参考：</p><ul><li><a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li></ul><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p>VGG是赢得2014 ImageNet定位和分类跟踪问题第一二名的卷积神经网络。它由16到19个权重层和1*1或3*3的小卷积过滤器组成。参考：</p><ul><li><a href="http://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">Very Deep Convolutional Networks for Large-Scale Image Recognition</a></li></ul><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><p>word2vec用于单词嵌入的算法，参考：</p><ul><li><a href="http://arxiv.org/abs/1301.3781" target="_blank" rel="noopener">Efficient Estimation of Word Representations in Vector Space</a></li><li><a href="http://arxiv.org/abs/1310.4546" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality</a></li><li><a href="http://arxiv.org/abs/1411.2738" target="_blank" rel="noopener">word2vec Parameter Learning Explained</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学机器学习，往往容易淹没在浩瀚的属于中，本文归纳总结一下机器学习相关的术语，帮您更好理解神经网络&lt;/p&gt;&lt;p&gt;本文大部分翻译自&lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wildml.com&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;h4 id=&quot;Activation-Function（激活函数）&quot;&gt;&lt;a href=&quot;#Activation-Function（激活函数）&quot; class=&quot;headerlink&quot; title=&quot;Activation Function（激活函数）&quot;&gt;&lt;/a&gt;Activation Function（激活函数）&lt;/h4&gt;&lt;p&gt;使用非线性函数对训练模型中的输出（当然不限于最终输出）进行非线性化处理，这样神经网络可以学习到复杂的决策边界。常用的激活函数包括  &lt;a href=&quot;https://en.wikipedia.org/wiki/Sigmoid_function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sigmoid&lt;/a&gt;, &lt;a href=&quot;http://mathworld.wolfram.com/HyperbolicTangent.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tanh&lt;/a&gt;, &lt;a href=&quot;http://www.wildml.com/deep-learning-glossary/#relu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReLU (Rectified Linear Unit)&lt;/a&gt;以及众多的变种.&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习几个要素</title>
    <link href="http://l2h.site/2019/07/14/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e5-87-a0-e4-b8-aa-e8-a6-81-e7-b4-a0/"/>
    <id>http://l2h.site/2019/07/14/e6-9c-ba-e5-99-a8-e5-ad-a6-e4-b9-a0-e5-87-a0-e4-b8-aa-e8-a6-81-e7-b4-a0/</id>
    <published>2019-07-14T14:41:18.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为个人学习机器学习的一些入门级总结，若您是机器学习大神，可以直接留言点赞就好，嘿嘿。</p></blockquote><p>要实现一个机器学习功能，以下要素必不可少：</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是机器学习的灵魂，万物的基石，女娲造人的泥土。可以说，所有的机器学习都是围绕着数据来进行的。数据的作用：</p><ul><li>训练模型</li><li>验证模型有效性</li><li>分析模型</li></ul><p>Tensorflow在学习是，需要先为数据站位（Placeholder），主要作用是预留出学习过程中数据所需要占用的系统资源（内存）。例如下边代码tensorflow处理<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MINIST数据集</a>的预先占位：</p><a id="more"></a><p>mnist = read_data_sets(‘./‘,one_hot=True)</p><p>sess = tf.InteractiveSession()</p><p>x = tf.placeholder(“float”, [None, 784])<br>##省略与placeholder无关部分<br>for i in range(1000):<br>  batch_xs, batch_ys = mnist.train.next_batch(100)<br>  sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型表示采用什么样的模式训练数据，是神经网络（深度神经网络又分CNN、RNN等）、决策树算法、贝叶斯分类或者线性回归等等。这些模型在成熟的机器学习框架如Tensorflow或者Pytorch中都有实现（直接API调用）。例如下面例子是Tensorflow使用CNN训练的网络模型：</p><p>def cov2d(x, W):<br>  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=’SAME’)<br>def max_pool_2x2(x):<br>  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],<br>                        strides=[1, 2, 2, 1], padding=’SAME’)<br>#第一层卷积层<br>W_conv1 = weight_variable([5, 5, 1, 32])<br>b_conv1 = bias_variable([32])<br>x_image = tf.reshape(x, [-1,28,28,1])<br>h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)<br>h_pool1 = max_pool_2x2(h_conv1)</p><p>#第二层<br>W_conv2 = weight_variable([5, 5, 32, 64])<br>b_conv2 = bias_variable([64])<br>h_conv2= tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)<br>h_pool2 = max_pool_2x2(h_conv2)<br>#全连接层<br>W_fc1 = weight_variable([7 * 7 * 64, 1024])<br>b_fc1 = bias_variable([1024])<br>h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])<br>h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</p><p>#Dropout<br>keep_prob = tf.placeholder(“float”)<br>h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</p><p>#输出层<br>W_fc2 = weight_variable([1024, 10])<br>b_fc2 = bias_variable([10])</p><h3 id="优化算法（Optimizer）"><a href="#优化算法（Optimizer）" class="headerlink" title="优化算法（Optimizer）"></a>优化算法（Optimizer）</h3><p>优化算法体现的是学习的方法。例如一个学生，你是希望他死记硬背还是寓教于乐。当然，这个比喻可能不是很恰当。其实就是告诉整个训练模型，每一步采用什么算法更新权值。一些常用的优化算法如梯度下降法、Adam、SGD等等，在处理不同的数据时各有优劣。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>主要用于对输出进行非线性化处理。一些比较复杂的数据，不是简单一条线，或者多次方程就能拟合出来的。而模型的形式往往是(F=wT+b)这种线性方程，所以需要使用激活函数对输出做非线性化处理。一些常见的非线性化函数包括Sigmoid、tanh、RELU、Softmax等等</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上为机器学习的必不可少的构成单元，直接计算会涉及到非常多的公式推导。还好现成的机器学习框架帮大家封装好了以上实现，大家直接使用即可。说到底、回头看，机器学习其实就是数据工程。如何选择和预处理数据，并使用合理的模型进行训练，是机器学习成败的关键</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为个人学习机器学习的一些入门级总结，若您是机器学习大神，可以直接留言点赞就好，嘿嘿。&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;要实现一个机器学习功能，以下要素必不可少：&lt;/p&gt;&lt;h3 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h3&gt;&lt;p&gt;数据是机器学习的灵魂，万物的基石，女娲造人的泥土。可以说，所有的机器学习都是围绕着数据来进行的。数据的作用：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;训练模型&lt;/li&gt;
&lt;li&gt;验证模型有效性&lt;/li&gt;
&lt;li&gt;分析模型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Tensorflow在学习是，需要先为数据站位（Placeholder），主要作用是预留出学习过程中数据所需要占用的系统资源（内存）。例如下边代码tensorflow处理&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MINIST数据集&lt;/a&gt;的预先占位：&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://l2h.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环神经网络(RNN)简单理解</title>
    <link href="http://l2h.site/2019/07/13/e5-be-aa-e7-8e-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9crnn-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3/"/>
    <id>http://l2h.site/2019/07/13/e5-be-aa-e7-8e-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9crnn-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3/</id>
    <published>2019-07-13T08:55:32.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>循环神经网络(Recurrent Nerual Networks,简称RNN)近年来被业界视作处理序列数据以及做自然语言处理的灵丹妙药。其变种LSTM仍是当今最先进的数据处理模型之一。</p><p>理解RNN的工作原理，可帮助机器学习人员建立起有效的模型，更好地对数据进行有效的处理。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是RNN？首先让我们比较下传统前向神经网络与RNN的网络架构。</p><a id="more"></a><p><img src="https://blog.floydhub.com/content/images/2019/04/Slide3-1.jpg" alt></p><p>左：传统神经网络架构 右：RNN架构</p><p>从图中可以看出，两者的差异主要在于网络是如何接收输入数据的。</p><ul><li><strong>传统前向神经网络</strong>：接受固定数量（所有数据量）的输入，进行定量的输出</li><li><strong>RNN</strong>：并非一次性使用所有的数据作为输入。反之，RNN有多个步骤，每个步骤将一部分数据序列化输入，经过一系列计算产生输出，直到所有的序列结束。</li></ul><p>这样讲可能仍然难以理解，下把这张序列化的动图可以辅助大家更好地理解。</p><p><img src="https://blog.floydhub.com/content/images/2019/04/rnn-2.gif" alt></p><p>上图可以看到，每一步的计算会将上一步的计算输出对应的隐藏状态（Hidden State）作为一部分输入。由此看出，RNN对处理序列化相关的数据有天生的优势。</p><p>另外我们可以看到，RNN每一步的神经元计算，是采用相同的网络结构，这是RNN的另外一个重要特点。</p><h3 id="RNN网络的输入输出"><a href="#RNN网络的输入输出" class="headerlink" title="RNN网络的输入输出"></a>RNN网络的输入输出</h3><p>您可能会有疑问了：RNN输出来自于网络的哪一步？答案是，这取决于您要解决的问题是什么。例如，如果您用RNN做分类任务，那么您所需要的是从所有输入得到的最终输出；或者您要做单词预测任务，那么您会需要RNN网络序列的每一步都作出输出。</p><p><img src="https://blog.floydhub.com/content/images/2019/04/karpathy.jpeg" alt></p><p>RNN输出数据多种形式</p><p>上图可以看出，RNN是非常灵活的，可以根据您的需要制定RNN的网络模型，喂给网络不同类型的输入，得到不同的输出。</p><p><img src="https://blog.floydhub.com/content/images/2019/04/Slide6.jpg" alt></p><p>RNN多对一输出</p><p>上图示例中，所有时刻的输入，经过RNN网络，得到最后的输出结果。</p><p><img src="https://blog.floydhub.com/content/images/2019/04/Slide7.jpg" alt></p><p>RNN多对多输出</p><p>而本示例中（上图），RNN序列的每一步输出都是我们需要的。除此之外，在例如翻译任务中，我们可能在会先接受多个输入序列，产生一个输出。再根据这个输出，最后产生多个输出序列。如下图英语翻译为法语的示例：</p><p><img src="https://blog.floydhub.com/content/images/2019/04/Slide8.jpg" alt></p><p>RNN 翻译示例</p><h3 id="RNN单元内部工作原理"><a href="#RNN单元内部工作原理" class="headerlink" title="RNN单元内部工作原理"></a>RNN单元内部工作原理</h3><p>到这里，您可能对RNN网络的框架有个基本了解。不过具体每一个RNN单元是如何工作的呢？</p><p>首先我们看传给RNN序列下一步的隐藏状态是如何产生的。有如下公式：</p><p>$$<br>hidden_t = F(hidden_{t-1}, input_t)<br>$$</p><p>即当前步的隐藏状态，由上一步的隐藏状态加上这部分的输入经过函数F处理后产生。而第一步的隐藏状态，一般会在整个RNN初始化时人为设置为0。在最简单的RNN中，函数F一般为每个输入乘以对应的权重再用激活函数做非线性处理。激活函数一般有RELU、Sigmoid或tanh。下边公式为采用tanh作为激活函数：</p><p>$$ hidden_t = tanh(W_{hiddent}*hidden_{t-1},W_{input} * input_t) $$</p><p>而我们若需要在RNN单元每一步产生一个输出，那么这个输出一般由该步的隐藏单元做一个线性处理产生，例如：</p><p>$$ output_t = W_{output}* hidden_t $$</p><p>可以看出，上一个RNN单元的隐藏状态会被传递给下一个RNN单元，如此重复，直到运行到我们设定的停止条件。</p><p>当然，这是一个最简单的RNN网络形式。RNN网络还有许多相对复杂的变种（当然是为了针对性解决其他网络形式的一些问题而提出），例如LSTM、GRU等。</p><h3 id="RNN网络的训练"><a href="#RNN网络的训练" class="headerlink" title="RNN网络的训练"></a>RNN网络的训练</h3><p>RNN需要经过训练才能学习“”到更精准的拟合，从而得到我们想要的数据。</p><p><img src="https://blog.floydhub.com/content/images/2019/04/rnn-bptt-with-gradients.png" alt></p><p>RNN网络的权重更新</p><p>我们知道，神经网络通过学习和更新网络中的权重来接近最优解（见<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/" target="_blank" rel="noopener">本站文章</a>），RNN也不例外。通过一步步后传播算法来减小损失函数（Cost Function）最终得到最小值，RNN的后传播会需要前面RNN单元的数据，本文不作推导。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对循环神经网络(RNN)的基本框架和原理做了介绍。为方便理解，略去的数学推导。接下来，计划对RNN网络的变形LSTM、GRU等做介绍，并增加Tensorflow代码实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;循环神经网络(Recurrent Nerual Networks,简称RNN)近年来被业界视作处理序列数据以及做自然语言处理的灵丹妙药。其变种LSTM仍是当今最先进的数据处理模型之一。&lt;/p&gt;&lt;p&gt;理解RNN的工作原理，可帮助机器学习人员建立起有效的模型，更好地对数据进行有效的处理。&lt;/p&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;什么是RNN？首先让我们比较下传统前向神经网络与RNN的网络架构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="RNN" scheme="http://l2h.site/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow在线资源汇总</title>
    <link href="http://l2h.site/2019/07/12/tensorflow-e5-9c-a8-e7-ba-bf-e8-b5-84-e6-ba-90-e6-b1-87-e6-80-bb/"/>
    <id>http://l2h.site/2019/07/12/tensorflow-e5-9c-a8-e7-ba-bf-e8-b5-84-e6-ba-90-e6-b1-87-e6-80-bb/</id>
    <published>2019-07-12T07:01:46.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>Tensorflow API在线文档</p><p><a href="https://www.l2h.site/docs/tf-api/" target="_blank" rel="noopener">https://www.l2h.site/docs/tf-api/﻿</a></p><p>TensorFlow官方文档中文版-v1.2</p><p><a href="https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ</a><br>提取码: qykw</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h3&gt;&lt;p&gt;Tensorflow API在线文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.l2h.site/docs/tf-api/&quot; 
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorflow" scheme="http://l2h.site/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络(CNN)的理解</title>
    <link href="http://l2h.site/2019/07/10/e5-8d-b7-e7-a7-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9ccnn-e7-9a-84-e7-90-86-e8-a7-a3/"/>
    <id>http://l2h.site/2019/07/10/e5-8d-b7-e7-a7-af-e7-a5-9e-e7-bb-8f-e7-bd-91-e7-bb-9ccnn-e7-9a-84-e7-90-86-e8-a7-a3/</id>
    <published>2019-07-10T07:54:26.000Z</published>
    <updated>2020-08-23T05:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习的目标是可以让计算机像人一样对事物进行理解，近些年深度学习得到了深入的发展，并有了广泛地产业化应用。一些常见的机器学习应用包括音视频识别、音视频分类、自然语言处理（NPL）等。</p><p>卷积神经网络（<strong>Convolutional Neural Network，CNN</strong>）最早提出于1979年，于今时在机器学习领域得到了广泛地应用，特别是在执行图片分类、识别等任务时，有着绝佳的效果。这是因为其在处理大量数据集时，计算复杂度上有着很大的优势。</p><a id="more"></a><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="http://pic.l2h.site/1.jpg" alt></p><p>神经网络的框架如图所示，它主要由以下几个部分组成：</p><ul><li>卷积</li><li>(ReLU)非线性化</li><li>池化</li><li>分类</li></ul><p>以上为卷积神经网络必不可少的部分，接下来我们试着对以上步骤分别进行理解（本文不涉及数学公式部分）。</p><h2 id="CNN深入理解"><a href="#CNN深入理解" class="headerlink" title="CNN深入理解"></a>CNN深入理解</h2><p>在对以上步骤进行介绍之前，我们先看一下计算机对视觉图像是如何进行理解的。如下图，对计算机来讲，每个图像都是以像素值作为元素的一组向量。每个像素点有RGB三种不同的<strong><em>通道</em></strong>，每个通道的取值为0-255的数字。而<strong>灰度</strong>图像，往往是只有一个通道的图像。为介绍的简便性，本文考虑只有一个通道的灰度图像。</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>CNN的名称即来自于“卷积”这一步骤。后者的主要目标是从输入中提取出可以用于分类的特征，同时保留像素间的空间距离。</p><p>考虑如下图左5<em>5像素大小的灰度图像，其中像素值为0或1（注意，这只是为了说明问题的一个特殊例子。灰度图像的像素点取值范围仍是0-255），以及图右的3</em>3矩阵</p><ul><li><p><img src="http://pic.l2h.site/2-2.png" alt></p><p>图像像素点</p></li><li><p><img src="http://pic.l2h.site/3.png" alt></p><p>过滤矩阵</p></li></ul><p>卷积操作即是类似如下动图对5<em>5图像和3</em>3矩阵的操作。橘色的矩阵在绿色原始图像像素矩阵上进行1像素大小滑动（Stride），每次对叠加元素间的积求和到新的向量矩阵元素（下图粉色矩阵）。</p><p><img src="http://pic.l2h.site/4.gif" alt></p><p>在卷积神经网络概念中，橘色的3*3矩阵被成为“过滤器”或“核函数”，而滑动过滤器并计算粉色向量的过程成为“特征卷积”或者“特征映射”。即，我们使用橘色的矩阵作为了原始图像的特征映射器。</p><p>很明显，从动图可以看出，对同一个图像不同的过滤矩阵值会产品不同的特征映射矩阵。考虑下图输入图像，我们可以从下表中看出，不同的过滤矩阵，如何影响到卷积的效果：</p><p><img src="http://pic.l2h.site/5.png" alt></p><ul><li><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-10-%E4%B8%8B%E5%8D%882.21.42.png" alt></p><p>不同卷积操作对原始图的影响</p></li></ul><p>从下图也可以很清楚地看到卷积操作的过程及产生的结果（两个不同的过滤矩阵，过滤出了同一图像的不同特征矩阵。）：</p><p><img src="https://wx2.sinaimg.cn/mw690/62d92af0ly1g4uq9zl5isg20dc07k7wm.gif" alt></p><p>在实际应用，CNN的训练过程会对过滤矩阵中的参数值进行学习（当然在这之前“我们”要负责选择过滤矩阵的数量、矩阵的大小以及网络的结构）。我们选择越多的过滤矩阵，卷积过程便得到越多的图像特征，这样网络识别图像的效果也越好。</p><p>卷积层的大小主要由以下三个参数来决定（学习开始前“我们”需要决定这些参数）：</p><ul><li>深度(Depth): 即卷积矩阵的数量，例如上图狗狗相片我们采取的Edge Detection、Box Blur矩阵等。不同的矩阵维度表示不同的特征。</li><li>步长(Stride)：卷积矩阵每次在原始图像像素矩阵上的滑动距离。例，2代表每次滑动2个像素的宽度</li><li>0填充(Zero-Padding)：有时需要在原始数据边界填充0作为被卷积的对象。此时称为宽卷积（Wide Convolution），反之称为窄卷积（Narrow Convolution）。0填充的一个作用是，当移动步长超过1时，有时移动会超出数据边界，此时适当做一些0填充来让移动可以顺利进行</li></ul><h3 id="非线性化-ReLU"><a href="#非线性化-ReLU" class="headerlink" title="非线性化(ReLU)"></a>非线性化(ReLU)</h3><p>卷积操作之后，会对数据进行非线性化。ReLU为常用非线性化函数（Rectified Linear Uni），下图为该函数的坐标轴表示：</p><p><img src="http://pic.l2h.site/screen-shot-2016-08-10-at-2-23-48-am.png" alt></p><p>ReLU对卷积化后的输出矩阵元素的负值进行处理，替换成0，主要目标便是将数据非线性化（因为真实世界中的数据往往也是非线性化的，而卷积是一个线性过程，需要对卷积后的数据做非线性处理）。</p><p>下图描述了ReLU操作对卷积操作后的特征矩阵的影响：</p><p><img src="http://pic.l2h.site/screen-shot-2016-08-07-at-6-18-19-pm.png" alt></p><p>也有一些其他非线性函数如Sigmoid和tanh（最朴素的神经网络里也会用到这些函数），ReLU在实际使用中性能优于这两个函数。</p><h3 id="池化过程-Polling"><a href="#池化过程-Polling" class="headerlink" title="池化过程(Polling)"></a>池化过程(Polling)</h3><p>空间池化（也成为“子抽样”）可以对卷积和非线性化的特征矩阵做有效降维，同时保持了矩阵的重要信息。池化主要用到的函数包括最大值(Max)、平均值(Average)、求和(Sum)等。</p><p>以最大值池化为例，我们在特征矩阵上定义空间近邻（如下图，2*2的窗口），取出其中每个窗口的最大元素，重新组成特征矩阵。若该层卷积选择了多个过滤窗口，那么我们对每个卷积化特征矩阵做池化处理得到池化后的特征矩阵。</p><p><img src="http://pic.l2h.site/screen-shot-2016-08-10-at-3-38-39-am.png" alt></p><p>下图显示了图片被池化后的效果：</p><p><img src="http://pic.l2h.site/screen-shot-2016-08-07-at-6-11-53-pm.png" alt></p><p>池化的主要作用就是有效降低输入数据的空间大小，节省计算量。其优势总结如下：</p><ul><li>不损失信息前提下，减小特征数据</li><li>减少神经网络需要计算的参数数量和计算量，因此可以有效抑制过拟合</li><li>减少输入数据因为转化变形等操作带来的影响</li></ul><p>以上过程介绍了构建CNN的基础成分卷积、非线性化和池化。这些过程的最终目的是得到与图片相关的、小数据量的、且能有效表达图像特征的特征矩阵。而这个特征矩阵的目的则是为最后一步，全连接神经网络的计算做准备，即我们提到的“分类”步骤</p><p>全连接神经网络的主要原理可以参考本站&lt;<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/" target="_blank" rel="noopener">神经网络和深度学习</a>&gt;一文的介绍，此处不做过多阐述。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结使用卷积神经网络进行机器学习的主要过程为：</p><ol><li>选择卷积神经网络的卷积、非线性化、池化等参数。同时初始化各个过程权值的初始值（可以随机化处理）</li><li>输入图像，并得到图片输出。</li><li>计算图片输出和实际输出的损失。</li><li>使用BP算法来优化神经网络，降低损失。</li></ol><p>欢迎留言探讨</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习的目标是可以让计算机像人一样对事物进行理解，近些年深度学习得到了深入的发展，并有了广泛地产业化应用。一些常见的机器学习应用包括音视频识别、音视频分类、自然语言处理（NPL）等。&lt;/p&gt;&lt;p&gt;卷积神经网络（&lt;strong&gt;Convolutional Neural Network，CNN&lt;/strong&gt;）最早提出于1979年，于今时在机器学习领域得到了广泛地应用，特别是在执行图片分类、识别等任务时，有着绝佳的效果。这是因为其在处理大量数据集时，计算复杂度上有着很大的优势。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://l2h.site/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CNN" scheme="http://l2h.site/tags/CNN/"/>
    
      <category term="机器学习" scheme="http://l2h.site/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="神经网络" scheme="http://l2h.site/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
