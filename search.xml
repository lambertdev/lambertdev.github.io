<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>L&amp;H的宝兴神木垒.达瓦更扎之行</title>
    <url>/p/c349f596.html</url>
    <content><![CDATA[<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/153088.html" target="_blank" rel="noopener">达瓦更扎</a>是<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63461.html" target="_blank" rel="noopener">宝兴</a>附的一个360度观日出云海景平台，近两年刚刚被开发出来。一直计划要去，终于在上个月底成行。</p><p>出行是在马蜂窝定的，两天一夜自由行包车费住宿和两顿餐食。不<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/143325.html" target="_blank" rel="noopener">含山</a>顶的交通车费120以及<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/64031.html" target="_blank" rel="noopener">神木</a>垒的门票</p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/307533654.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s11/M00/D3/A3/wKgBEFrFxhWAJDk6AACn1o-OfzU879.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63461.html" target="_blank" rel="noopener">宝兴</a>县城，距离<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a>3个小时车程</p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297692.html" target="_blank" rel="noopener"><img src="http://p4-q.mafengwo.net/s11/M00/5B/F6/wKgBEFrA1WGAR0TXAA1QFkrmB8A29.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306296760.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s11/M00/5B/6F/wKgBEFrA1NOAVrQJABeI2bvNXpI80.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63461.html" target="_blank" rel="noopener">宝兴</a>.县城好吃的无骨鸡爪，临走还打包了一份回家</p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297332.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/5B/BA/wKgBEFrA1SKABaq0AAsKE9NP-C404.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63461.html" target="_blank" rel="noopener">宝兴</a>.红军长征纪念馆</p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306296229.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/5B/31/wKgBEFrA1JGAGcbAABfJIDHUCLI38.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306296242.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s11/M00/5B/33/wKgBEFrA1JKAFkHpAAol4C9vrho39.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306296248.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s11/M00/5B/35/wKgBEFrA1JWAEotpABrvij5Zhg486.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306296268.html" target="_blank" rel="noopener"><img src="http://n4-q.mafengwo.net/s11/M00/5B/39/wKgBEFrA1JiAWDkKABzqPQJ3rSw98.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p>当天入住硗碛乡，距离<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63461.html" target="_blank" rel="noopener">宝兴</a>县城一个多小时车程</p><a id="more"></a>













<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297272.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/5B/B0/wKgBEFrA1RSAOMuaABETE1ciBaU78.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>硗碛藏寨门口</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306302497.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s11/M00/5E/EC/wKgBEFrA2LeAehv9AAbZoh8hIvM01.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>硗碛乡步行往返<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/64031.html" target="_blank" rel="noopener">神木</a>垒（门票40费用自理），</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297281.html" target="_blank" rel="noopener"><img src="http://b4-q.mafengwo.net/s11/M00/5B/B2/wKgBEFrA1RiAJqWTAB687y6ubsA94.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>花苞</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297284.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/5B/B3/wKgBEFrA1RqACyypABfdCaByZk017.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297302.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s11/M00/5B/B5/wKgBEFrA1R6AHiTpABt_pvK-wuA04.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297324.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s11/M00/5B/B8/wKgBEFrA1SGAN_o-AB4mx5Hp6gs95.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>第二天早晨，等待<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/153088.html" target="_blank" rel="noopener">达瓦更扎</a>日出中（5点出发，约6点40到达山顶观景平台）</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297644.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/5B/ED/wKgBEFrA1VeAekWWAAPtImP06Yw07.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297652.html" target="_blank" rel="noopener"><img src="http://p3-q.mafengwo.net/s11/M00/5B/EF/wKgBEFrA1ViAUnQ-AAUWcgTVAAY89.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>日出</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297716.html" target="_blank" rel="noopener"><img src="http://p4-q.mafengwo.net/s11/M00/5B/FA/wKgBEFrA1WaAFwiDABVxrDpY5EE21.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297773.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/5C/02/wKgBEFrA1WyAE_iIABPF3ZCmZ8U35.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297783.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s11/M00/5C/05/wKgBEFrA1W-AZPk1ABRNJYFVdVc72.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306302500.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/5E/EC/wKgBEFrA2LeAP45gAAH62i44Wg029.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306308972.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s11/M00/62/33/wKgBEFrA29mAXdvhAAJNzvsG8t091.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297660.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/5B/F0/wKgBEFrA1VmATiQ0AAc4C1e3rPk05.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306302505.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/5E/ED/wKgBEFrA2LiAXF_VAAG4JBMhKBo78.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297705.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s11/M00/5B/F8/wKgBEFrA1WOAZXWNABbSLmUW5tk52.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>硗碛水坝上所照</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297675.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s11/M00/5B/F2/wKgBEFrA1VyASX7QABxfzIlekPI14.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>硗碛水库</p>
<p><a href="http://www.mafengwo.cn/photo/153088/scenery_8820562/306297686.html" target="_blank" rel="noopener"><img src="http://p4-q.mafengwo.net/s11/M00/5B/F4/wKgBEFrA1V-AN-R2ABfWLGeBHmQ85.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>宝兴</tag>
        <tag>日出</tag>
        <tag>神木垒</tag>
        <tag>达瓦更扎</tag>
        <tag>雅安</tag>
      </tags>
  </entry>
  <entry>
    <title>Crazy</title>
    <url>/p/ad5b4460.html</url>
    <content><![CDATA[<p>最近亮哥说我老是说梦话 周二上了英语口语课，跟外教对话比较多，第二天亮哥说我在梦中说英语，呵呵 周三课多，晚上却把试验逃了 周四，周五，我唯独这周没有去踢球：原因是降温了，懒得动。 天知道今天天晴了，太阳还很大，马上我得参加拔河去，要知道高中这种项目怎么也轮不到我的。 在老姐博客上看到”爱一个人，是因着在他的身上能够映照出自我”,有道理吧？ 朋友，你知道我在说什么吗？ 连我自己都不知道，因为我还不知道自己在做什么～！ 跟二舅说自己对考研的看法：真的，假的？ 比较乱，得整理下。 嘴上又出口腔溃疡了，疼 晚上总是关机很早，然后无所事事 完…………</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>恭喜上港夺冠！</title>
    <url>/p/5be9ba82.html</url>
    <content><![CDATA[<p>作为资深伪球迷，繁荣的中超联赛怎能错过关注？上港赛季双杀7冠王恒大，武磊打破本土球员进球记录，冠军实至名归。 希望这个班底让中国国家队重新立足亚洲舞台，希望不只是奢望。 <img src="http://pic.l2h.site/l2hsite2018-Chinese-League-A-0.jpg" alt="恭喜上港夺冠！" title="恭喜上港夺冠！"> 更为可喜的是，20多年坚持的家乡球队建业继续留在中超。老婆的家乡球队重庆击败赛前还有争冠可能的恒大队，希望也可以在最后一轮成功保级。 看看积分榜，4个32分、一个33分都不保险，下一轮会相当精彩！斗胆预测一下，长春亚泰降级可能性最大 <img src="http://pic.l2h.site/l2hsite2018-Chinese-League-A-1.png" alt="恭喜上港夺冠！" title="恭喜上港夺冠！"></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
      <tags>
        <tag>中超</tag>
      </tags>
  </entry>
  <entry>
    <title>拜个晚年</title>
    <url>/p/4aece71f.html</url>
    <content><![CDATA[<p>祝大家新年快乐，万事如意！ 希望自己可以坚持，所有的愿望都能实现！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>L&amp;H-最强3天两夜西湖乌镇游记</title>
    <url>/p/1102a76e.html</url>
    <content><![CDATA[<p>旅行到过国内20+城市，却一直心念念没有到过的东南沿海–江浙沪包邮地区。7月份趁着南航会员日机票打折，全程只要860/人，便订好了重庆往返杭州的机票等待出发。</p><p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383251107.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/EF/6A/wKgED1u4DBGACCdOAABKmbJgous39.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p><p>出门怎么能少的了住宿呢，推荐一家西湖边上清波门旁边的民宿，装修地理位置俱佳也是我们住宿所在地： <a href="https://abnb.me/VMyIlGzwMQ" target="_blank" rel="noopener">https://abnb.me/VMyIlGzwMQ</a></p><a id="more"></a>


<p>Day 1 出发当日，晴空万里。飞机上俯瞰：一条河蜿蜒曲折，时有一块块水塘、田地，好一派江南模样。</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904304.html" target="_blank" rel="noopener"><img src="https://n2-q.mafengwo.net/s12/M00/87/BC/wKgED1u3B9WAG98fABH-aOrhzi080.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904330.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/3B/1A/wKgED1u1T8iAXjEzABmeQrbbl5471.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a> 下了飞机，乘坐机场大巴武林门线到武林广场已经12点半。大众点评搜索到当地一家苍蝇馆子杭帮菜-23号墙门菜，门口早已坐上了等待的客人，排号约40分钟后吃上饭。三菜两饭人均50.</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904412.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/87/D3/wKgED1u3B-OAZKA2AB3RW9JwJ1863.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>尖椒大肠-- 类似成都的卤肠子的味道，尖椒做成虎皮尖椒了，不辣，味道不错。</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904385.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/87/CD/wKgED1u3B96AX3x7AB5v9Ai1CRA36.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>炒臭豆腐—臭，H吃不惯</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904397.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/87/CF/wKgED1u3B-CAdDAeAAqFLD7ilxw85.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>饭馆隔壁是另外一家点评网上排名很高的饭馆–老头儿油爆虾（可惜时间关系，这次没有吃到）</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904434.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/87/D7/wKgED1u3B-aAYayZABun7zBo0wQ23.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>吃完到民宿休整后，出发到灵隐寺，在西湖边上坐游2路直达。 这里要特别提下， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10156.html" target="_blank" rel="noopener">杭州</a> 的公交系统几乎都关联了支付宝，可以扫码支付。建议到支付宝办理 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10156.html" target="_blank" rel="noopener">杭州</a> 公交电子一卡通，无需费用，还可以领1元钱十次的半价乘车，基本上三天的出行都可以涵盖了。办理办法：支付宝-城市服务-切换到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10156.html" target="_blank" rel="noopener">杭州</a> - <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10156.html" target="_blank" rel="noopener">杭州</a> 通-按照说明开通，使用办法：支付宝-付款-乘车码</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383265433.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/FD/E1/wKgED1u4Fh-AHlAdAAJ0e2-kvfI88.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>灵隐寺（照片下边全是人头）。门票45（飞来峰价格）+30（入寺价格）</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904442.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/87/D9/wKgED1u3B-eAdAEnAA3QD21tAtA17.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904453.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/87/DB/wKgED1u3B-mADMPyAA2kF_K6TPU45.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904466.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/87/DD/wKgED1u3B-uASN2YAA5NLYVCntQ89.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>济公店</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904503.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/87/E4/wKgED1u3B_CALDsXABQSw_XSnTY51.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>旁边的万福寺，进入飞来峰景区后免费</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904520.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/87/E8/wKgED1u3B_KACrVMAAtuWTCWQ0s13.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904538.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/87/EE/wKgED1u3B_SAD-IZAB1OfvZxd3Y08.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>游过灵隐寺后回来已然晚上，在当地面馆吃了一碗当地著名的片儿川面，味道过于清淡，有点像清水的酸菜肉丝面</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382908762.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/8C/48/wKgED1u3CjqARzgJABxGCQtRmnE26.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>吃完饭休整后，夜游西湖</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906344.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/89/C6/wKgED1u3CNeAfzqmAAv06YAANJI54.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906365.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/89/CC/wKgED1u3CNyAZ6OrAApg-Ml8uZg12.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906417.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/89/DE/wKgED1u3COiAXp8xABhoN65wtEo48.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906463.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/89/EC/wKgED1u3CPCADxwVABsngC1mqIE54.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>西湖边公园的智慧服务亭（ <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10156.html" target="_blank" rel="noopener">杭州</a> 不愧为支付宝总部，移动支付便捷）</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906481.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/89/F0/wKgED1u3CPWABw_HABvcgaq_H-E58.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>随拍</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906503.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/89/F5/wKgED1u3CPmAPbWhABgxMcfcIU852.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>对岸看到的雷峰塔，实则为新雷峰塔</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906521.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/89/F8/wKgED1u3CPyAIAXcAAwvSSrvsoM36.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906567.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/8A/02/wKgED1u3CQKASlZ-ABqC_Oi_KEM67.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382906645.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/8A/0E/wKgED1u3CQeAV7KrABjW-7-DsEk72.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>Day 2 由于时间紧迫，自由行不好安排，订了马蜂窝的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10434.html" target="_blank" rel="noopener">乌镇</a> 一日游路线。预订地址：<a href="https://m.mafengwo.cn/sales/2075842.html" target="_blank" rel="noopener">https://m.mafengwo.cn/sales/2075842.html</a></p>
<p>图为东栅</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383151949.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/7C/E3/wKgED1u3fqSASvICABbVXpbHQTg57.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383151974.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/7C/E9/wKgED1u3fqaAaYcrAA1c8MRbwz878.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>东栅酿酒坊</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152021.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/7C/F2/wKgED1u3fqqAKJjsABzy231bG6E02.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152049.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/7C/F8/wKgED1u3fqyAG8JOABG-03loDtY79.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>东栅桥上</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152073.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/7C/FD/wKgED1u3fq6AKnbQAAoC2qtVpHE26.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>染布坊</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152107.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/7D/04/wKgED1u3frKALv_fABrL07Us5lI74.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152145.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/7D/0C/wKgED1u3fraALksbAB1A68aseuw46.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152244.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/7D/13/wKgED1u3frmADjC_ABimNTezhd456.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152263.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/7D/18/wKgED1u3frqAEsNVAAx2AXYdYHo23.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152298.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/7D/25/wKgED1u3fr6AJJ3EABuOjzlUwbQ00.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>西栅 东栅游人太多，过于拥挤。匆匆逛完后到西栅，同样拥挤。为了避免降低旅行体验，选择往返均游船来往（单程25分钟60/人）。强烈推荐坐船！</p>
<p>图为京杭大运河</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152623.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/7D/67/wKgED1u3ftiASueZABzuLXgLUII61.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152647.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/7D/6D/wKgED1u3ftyACySzABkG3Z_5wFY11.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>落日随拍</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152727.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/7D/83/wKgED1u3fuKAMhADABtHjrHclGE92.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>夜幕，华灯初上</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152758.html" target="_blank" rel="noopener"><img src="https://p4-q.mafengwo.net/s12/M00/7D/88/wKgED1u3fuWAC_ArABLHXHG_HrQ06.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>每一副都是美丽的油画</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152804.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/7D/92/wKgED1u3fuiAdI-rAB4rXPb1xfs85.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152853.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/7D/9C/wKgED1u3fuyAf56LAB_QMarzT9w02.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152890.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/7D/A2/wKgED1u3fu-AeFYkABSMvemjlaI18.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152910.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/7D/AA/wKgED1u3fvKAeIzuABnysJdjgqA64.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10434.html" target="_blank" rel="noopener">乌镇</a> 大剧场</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152937.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/7D/B3/wKgED1u3fvWARrvdABmJSTaxLWA59.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>Day 3 因为下午需要赶飞机，同样预订马蜂窝的一日团。 <a href="https://m.mafengwo.cn/sales/order/detail?id=26418642018100310758026" target="_blank" rel="noopener">https://m.mafengwo.cn/sales/order/detail?id=26418642018100310758026</a></p>
<p>西湖早景随拍</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383152992.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/7D/C0/wKgED1u3fvyAI3GqABNVfo2s70w88.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153010.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/7D/CA/wKgED1u3fwCAK5rZAB9avxzxXFA50.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>雷峰 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/135911.html" target="_blank" rel="noopener">塔塔</a> 基，每块砖都有经文</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153017.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/7D/D3/wKgED1u3fwOAH41RAB9gk-dI4NE60.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>新雷峰塔</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153032.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/7D/DD/wKgED1u3fweAC-9zAB35pKzJmdA04.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>新塔的金箔顶</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153039.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/7D/E4/wKgED1u3fwmAFqNYAA9quEa_73E21.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>三潭映月</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383276047.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/08/74/wKgED1u4HLCAPTIHABi0J7Mbp_U33.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>跟团结束后街边随拍</p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/382904348.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/87/C7/wKgED1u3B9uAI2cKABrwQ5OUxCM27.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153056.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/7D/EB/wKgED1u3fw2AB6eFABvuBE0Ja7w68.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153098.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/7D/F6/wKgED1u3fxGAeOsDAByu0Nh83cE35.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153113.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/7D/FB/wKgED1u3fxOAHaXzAA4yILnv0uI76.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153131.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/7D/FE/wKgED1u3fxWAHyYsAA_fAqHtmMY46.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10156/scenery_10795686/383153140.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/7E/01/wKgED1u3fxeANP_lAAuY1EYQbQI83.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>乌镇</tag>
        <tag>杭州</tag>
        <tag>江南</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>L&amp;H的折腾昆明丽江行(2018.6）</title>
    <url>/p/b771876d.html</url>
    <content><![CDATA[<p>之前和公司计划去从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> 飞去 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10121.html" target="_blank" rel="noopener">泸沽湖</a> ，没想到预期中的一趟完美休闲之旅变成了折腾之行。</p><p>去程 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> –&gt; <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10121.html" target="_blank" rel="noopener">泸沽湖</a> ： 祥鹏航空因为天气原因备降 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10807.html" target="_blank" rel="noopener">昆明</a> ，折腾到11点，最后干脆取消不去 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10121.html" target="_blank" rel="noopener">泸沽湖</a> 。 航空公司负责当天的住宿，大家匆匆忙忙决定第二天晚上改去 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10186.html" target="_blank" rel="noopener">丽江</a> 。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10186.html" target="_blank" rel="noopener">丽江</a> –&gt; <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> ： 因为天气原因航班（还是祥鹏航空）直接取消。只好改第二天早上川航的飞机到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13663.html" target="_blank" rel="noopener">绵阳</a> 再高铁回 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> 。 从此祥鹏航空一生黑</p><a id="more"></a>

<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337639154.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s11/M00/75/70/wKgBEFs0L4WAPGLFAAITkHr8Iys79.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337639144.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/75/6F/wKgBEFs0L4OAEuDNAAGpSm52qhQ54.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337639140.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s11/M00/75/6F/wKgBEFs0L4OAMcttAAMqh8zYDOg21.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337639135.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s11/M00/75/6E/wKgBEFs0L4KAbmsIAAK_3iCbz8E90.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>Day 1 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10807.html" target="_blank" rel="noopener">昆明</a> 决定去 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10186.html" target="_blank" rel="noopener">丽江</a> 后第一天就在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10807.html" target="_blank" rel="noopener">昆明</a> 简单逛逛。</p>
<p>中午在昆百大看起来吃起来都蛮爽的傣餐手抓饭</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/338433008.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s11/M00/79/33/wKgBEFs297qAPW5sAAy9HeTU3Ks51.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>饭后公交到滇池路上</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337256386.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/49/AA/wKgBEFsy676AEmVGAAmOm6IIwKE56.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>滇池边，富氧化程度非常高</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337256453.html" target="_blank" rel="noopener"><img src="http://n3-q.mafengwo.net/s11/M00/49/C3/wKgBEFsy68yAQuibAAwZ6hCR4Yw86.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337256852.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/49/ED/wKgBEFsy6_WAAQw1AAv1nYjGYm449.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337262866.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s11/M00/4E/CA/wKgBEFsy8C6AYooMAAsToCevKMU92.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337262888.html" target="_blank" rel="noopener"><img src="http://p3-q.mafengwo.net/s11/M00/4E/D2/wKgBEFsy8DiABLnFAAkQgGlzHOs63.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337258509.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s11/M00/4A/E7/wKgBEFsy7N-ABFb8ABhpGParvU086.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>Day 2 还好顺利赶到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10186.html" target="_blank" rel="noopener">丽江</a> ，在拉市海的欢快划船行</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337257258.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s11/M00/4A/50/wKgBEFsy7FWAATnDAAvWXsSHCKw92.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337257368.html" target="_blank" rel="noopener"><img src="http://n4-q.mafengwo.net/s11/M00/4A/5C/wKgBEFsy7GGAC6pYAAptO2wQSvk48.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337258327.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/4A/C0/wKgBEFsy7MOASNtyABzfREyHkuc99.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337256342.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/49/99/wKgBEFsy67KACCMxAAjhDYuBZAA10.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10186.html" target="_blank" rel="noopener">丽江</a> 古城</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337258157.html" target="_blank" rel="noopener"><img src="http://b2-q.mafengwo.net/s11/M00/4A/A0/wKgBEFsy7KKAI246AA3rrBNRAjM37.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>古城四方街小酒吧（调酒，消费人均50）</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337258095.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/4A/93/wKgBEFsy7JKANAlEAARbNq4JjKw31.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>传说中的文青网红店，门口看了看，一个漆黑的小屋子，一群人听一个人说话</p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337257080.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s11/M00/4A/35/wKgBEFsy7DmABsluAAtgPKqYe2041.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>Day 3. <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10481.html" target="_blank" rel="noopener">虎跳峡</a></p>
<p><a href="http://www.mafengwo.cn/photo/10186/scenery_9665997/337258085.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s11/M00/4A/90/wKgBEFsy7I2Adnq0AA6YrjdPpa453.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>丽江</tag>
        <tag>云南</tag>
        <tag>昆明</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress如何关联熊掌号</title>
    <url>/p/a311a7b4.html</url>
    <content><![CDATA[<h1 id="Wordpress关联熊掌号"><a href="#Wordpress关联熊掌号" class="headerlink" title="Wordpress关联熊掌号"></a>Wordpress关联熊掌号</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="http://pic.l2h.site/l2hsiteXiongZhangHao-0.jpg" alt="熊掌号"></p><p>做站还是希望能得到大家的关注，百度作为国内最大的搜索引擎，给站长提供了熊掌号平台。绑定网站后，百度搜索会倾向于优先展现熊掌号的内容，可以为网站引入一定搜索流量。</p><p>通过摸索，得到建立熊掌号的流程如下：</p><ul>
<li>建立熊掌号</li>
<li>Wordpress页面改造</li>
<li>提交页面</li>
</ul><h2 id="建立熊掌号"><a href="#建立熊掌号" class="headerlink" title="建立熊掌号"></a>建立熊掌号</h2><h3 id="申请熊掌号"><a href="#申请熊掌号" class="headerlink" title="申请熊掌号"></a>申请熊掌号</h3><p>到<a href="https://xiongzhang.baidu.com/" title="https://xiongzhang.baidu.com/" target="_blank" rel="noopener">熊掌号官网</a>按照百度的要求进行提交审核即可，一般5个工作日左右，需要耐心等待。</p><a id="more"></a>




<h3 id="熊掌号装潢"><a href="#熊掌号装潢" class="headerlink" title="熊掌号装潢"></a>熊掌号装潢</h3><p>装饰页面可以提升熊掌号指数。 可以到“熊掌号后台–&gt;主页管理–&gt;主页装修”进行主页的装饰。如下图，运营位设置为网址链接：</p>
<p><img src="http://pic.l2h.site/l2hsiteXiongzhanghao-decorate-1.png" alt="主页装饰">“熊掌号后台–&gt;主页管理–&gt;自定义栏目”可以添加专栏文章，专栏名可以自定义：</p>
<p><img src="http://pic.l2h.site/l2hsiteXiongzhanghao-decorate-2.png" alt="主页装饰">“熊掌号后台–&gt;主页管理–&gt;自定义菜单”可以根据实际需求增加首页菜单，菜单可以定义到二级：</p>
<p><img src="http://pic.l2h.site/l2hsiteXiongzhanghao-decorate-3.png" alt="主页装饰"></p>
<h3 id="提升熊掌号指数"><a href="#提升熊掌号指数" class="headerlink" title="提升熊掌号指数"></a>提升熊掌号指数</h3><h4 id="绑定网站"><a href="#绑定网站" class="headerlink" title="绑定网站"></a>绑定网站</h4><p>“熊掌号后台–&gt;内容源设置–&gt;绑定设置”来绑定您的网站</p>
<h4 id="提升指数"><a href="#提升指数" class="headerlink" title="提升指数"></a>提升指数</h4><p>这里到“熊掌号后台–&gt;熊掌号成长–&gt;熊掌号指数”里可以看到您的熊掌号指数成长。点击“去优化指数”，可以根据后台提示来提升指数。一些提升指数的方法：</p>
<ul>
<li>绑定微信公众号、微博、今日头条等</li>
<li>装饰主页</li>
<li>用百度APP发表动态（类似发微信朋友圈）</li>
<li>开放平台接口调用（用API等方式提交资源）</li>
<li><strong>最直接方法</strong>：提交资源并成功收录</li>
</ul>
<p><img src="http://pic.l2h.site/l2hsiteXiongZhangHao-1.png" alt="优化指数"><br><img src="http://pic.l2h.site/l2hsiteXiongZhangHao-2.png" alt="优化指数"><br><img src="http://pic.l2h.site/l2hsiteXiongZhangHao-3.png" alt="优化指数"></p>
<p>指数在100分以下时，许多后台操作是无法进行的。而超过100分后，后台操作权限相应就会放开。</p>
<h2 id="Wordpress熊掌号H5页面改造"><a href="#Wordpress熊掌号H5页面改造" class="headerlink" title="Wordpress熊掌号H5页面改造"></a>Wordpress熊掌号H5页面改造</h2><p>若要Wordpress页面能够被正常收录，需要改造您的Wordpress文章页面。Wordpress后台–&gt;外观–&gt;编辑–&gt;修改主题的header.php。在header标签前增加如下熊掌号ID声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://xiongzhang.baidu.com/sdk/c.js?appid=xxxxxx"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时增加如下页面改造代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">if</span>( is_single() || is_page() ): <span class="meta">?&gt;</span></span><br><span class="line">&lt;script type=<span class="string">"application/ld+json"</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"@context"</span>: <span class="string">"https://ziyuan.baidu.com/contexts/cambrian.jsonld"</span>,</span><br><span class="line">        <span class="string">"@id"</span>: <span class="string">"&lt;?php the_permalink(); ?&gt;"</span>,</span><br><span class="line">        <span class="string">"appid"</span>: <span class="string">"您的熊掌号APP ID"</span>,</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"&lt;?php the_title(); ?&gt;"</span>,</span><br><span class="line">        <span class="string">"images"</span>: [</span><br><span class="line">            <span class="string">"&lt;?php echo zillah_catch_that_image(); ?&gt;"</span></span><br><span class="line">            ],</span><br><span class="line">        <span class="string">"description"</span>: <span class="string">"&lt;?php if ($post-&gt;post_excerpt) </span></span><br><span class="line"><span class="string">        &#123;$printDescription = $post-&gt;post_excerpt;&#125; </span></span><br><span class="line"><span class="string">              else&#123;</span></span><br><span class="line"><span class="string">      $printDescription = preg_replace('/\s+/','',mb_strimwidth(strip_tags($post-&gt;post_content),0,145,''));</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            echo $printDescription;?&gt;"</span>,</span><br><span class="line">        <span class="string">"pubDate"</span>: <span class="string">"&lt;?php echo get_the_time('Y-m-d\TG:i:s'); ?&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;	</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">endif</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="提交页面"><a href="#提交页面" class="headerlink" title="提交页面"></a>提交页面</h2><h3 id="历史数据提交"><a href="#历史数据提交" class="headerlink" title="历史数据提交"></a>历史数据提交</h3><p>到<a href="https://curl.haxx.se/windows/" title="https://curl.haxx.se/windows/" target="_blank" rel="noopener">Curl官网</a>下载Curl For Windows并解压（注意根据您的Windows版本下载）。</p>
<p>准备好urls.txt，里边为您希望提交的历史数据URL，每行一个网址。到解压的Curl的bin目录执行如下命令：</p>
<blockquote>
<p>curl -H ‘Content-Type:text/plain’ –data-binary @urls.txt “<a href="http://data.zz.baidu.com/urls?appid%3Dxxxxxx%26token%3Dxxxxxxxx" title="http://data.zz.baidu.com/urls?appid%3Dxxxxxx%26token%3Dxxxxxxxx" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?appid=xxxxxx&amp;token=xxxxxxxx</a>“</p>
</blockquote>
<p>其中appid和token需要更换成您自己熊掌号的id和token。以上命令也可以在”熊掌号后台–&gt;资源提交–&gt;API提交–&gt;历史内容接口–&gt;推送示例”中找到。 历史数据提交上限为50000，对个人站长绰绰有余了。</p>
<h3 id="新增数据提交"><a href="#新增数据提交" class="headerlink" title="新增数据提交"></a>新增数据提交</h3><p>新增数据也可用Curl进行提交，提交方法与历史数据提交类似，差别只是在于调用时的参数增加 <em><strong>type=realtime。</strong></em></p>
<blockquote>
<p>curl -H ‘Content-Type:text/plain’ –data-binary @urls.txt “<a href="http://data.zz.baidu.com/urls?appid%3Dzxxxxxxx%26token%3Dxxxxxxxxxxx%26type%3Drealtime" title="http://data.zz.baidu.com/urls?appid%3Dzxxxxxxx%26token%3Dxxxxxxxxxxx%26type%3Drealtime" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?appid=zxxxxxxx&amp;token=xxxxxxxxxxx&amp;type=realtime</a>“</p>
</blockquote>
<p>每天提交上限为10条</p>
<h3 id="增加Wordpress插件做数据提交"><a href="#增加Wordpress插件做数据提交" class="headerlink" title="增加Wordpress插件做数据提交"></a>增加Wordpress插件做数据提交</h3><p>总是使用Curl提交难免复杂，要是Wordpress后台添加文章的时候自动提交则比较简单。</p>
<ul>
<li><ul>
<li>Wordpress后台–&gt;插件–&gt;搜索”BaiduXZH Submit”，添加并安装</li>
</ul>
</li>
<li><ul>
<li>转到插件设置页面</li>
</ul>
</li>
<li><p>添加熊掌号的APP ID及Token（可以在百度熊掌号后台查看）并保存</p>
</li>
</ul>
<p><img src="http://pic.l2h.site/l2hsiteXiongzhanghao-Plugin-0.png" alt="熊掌号插件配置"></p>
<h3 id="网站自动源同步"><a href="#网站自动源同步" class="headerlink" title="网站自动源同步"></a>网站自动源同步</h3><p>熊掌号支持网站自动抓取，参照”绑定网站”一节绑定网站并添加同步源。添加过后，一般一天之内即可抓取完网站内容。之后百度也会定期自动抓取。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上为Wordpress绑定熊掌号的一些基础设置，更多内容待继续摸索和发掘。</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>熊掌号</tag>
        <tag>百度</tag>
      </tags>
  </entry>
  <entry>
    <title>博客程序更换成Hexo</title>
    <url>/p/a5977a53.html</url>
    <content><![CDATA[<p>一直希望使用Markdown来写博客，无奈Wordpress对Markdown的原生支持太差。而且受不了Wordpress程序执行的龟速。  </p><p>因此趁着国庆把博客程序作了更换成了Hexo，托管网站也换成了Github。  </p><p>简单说明一下转移作了哪些事情：</p><ul>
<li>申请Github Pages 并绑定域名</li>
<li>安装Hexo，并下载相应所需插件。没想到有Wordpress转Hexo插件，真是帮了大忙</li>
<li>把之前上传在网站空间的图片，全部下载并转存到七牛云存储上（这里有点小技巧，用Notepad++的正则表达式查找替换，节省时间，事半功倍）</li>
<li>使用NeXT主题，自带很多需要的功能，包括可以显示属性公式的Mathjax，原Wordpress博客的数学公式，也并没有受到影响（当然也要做一些非常简单的文本替换，同样Notepad++搞定）</li>
<li>因为博客是使用Hexo生成静态页面上传到Github Pages。特意申请了一个Github私有项目保存保存源码，方便多机编辑（这也是Hexo唯一的不方便，每个机子都要重新建环境）</li>
<li>另外一些原博客需要的一些小修改，不表。</li>
</ul><a id="more"></a>



<p>之前买的阿里云空间还有整整两年，感觉不用可惜了。不知道除了远程使用下Linux，还有啥用途。开个自动采集小说站，会不会被请喝茶？</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>随便感慨</title>
    <url>/p/a20adb88.html</url>
    <content><![CDATA[<p>从长假回公司已经有一个月了，慢慢也进入到工作状态。<br>这次回来，还是有蛮多感触。看到晚几年进公司的同事，一步步承担更重的任务。深觉须时时努力，不断进步。方能担负得起自己所承担的任务。<br>今年运气欠佳，也希望努力可以带来更好的运气。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>Zephyr线程管理 - 概念</title>
    <url>/p/42e2c2a3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想写一些RTOS的技术资料，算作对自己之前一些相关技术调研的总结。无奈懒癌发作，一拖再拖。然今日灌上鸡血，笃定主意，从最基本的调度相关内容开始。  </p><p>简单讲，Zephyr是一个开源实时操作系统。相较Linux，其对系统资源的使用量更小，当然也牺牲了许多复杂且完善的功能（如，系统Debug易用性，线程的堆栈保护）。与此同时，因其是开源社区开发，也多少继承和保留了许多Linux系统的优秀思想和功能（例如，Workqueue、设备树等）。其定位为万物互联时代各种各样的嵌入式设备，目光长远。</p><a id="more"></a>

<p>Zephyr里没有管程、进程、线程之分。除了中断响应例程，其余所有可执行调度单位皆是线程。系统中应用程序可以定义一个或者多个线程，这种情况下，每个线程也都有自己独立的调度信息和线程ID。</p>
<p>虽然也有区分用户空间和内核空间态，Zephyr线程却没有自己独立的地址转换表，皆使用相同的地址空间，这是由Zephyr的内存管理方式决定的。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>线程状态即转换关系如下图所示：<br><img src="https://docs.zephyrproject.org/latest/_images/thread_states.svg" alt="https://docs.zephyrproject.org/latest/_images/thread_states.svg"><br>可以看出，线程分为如下状态：  </p>
<ul>
<li>New：表示线程新创建</li>
<li>Ready: 线程就绪状态</li>
<li>Waiting: 线程等待某种IO资源</li>
<li>Running: 线程执行中</li>
<li>Suspended: 线程挂起状态，非等待资源原因被停止执行</li>
<li>Terminated: 线程退出</li>
</ul>
<p>以上线程状态转换关系见图，后续进行代码分析将进一步介绍。</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程的优先级使用数字表示，数字越小，线程的优先级越高。Zephyr系统的线程可以分为两类:  </p>
<ul>
<li>Cooperative线程：一旦开始执行，除非中断或者线程自行让出CPU，将会一直执行</li>
<li>可抢占线程: 普通线程，可被更高优先级的线程抢占执行</li>
</ul>
<p>Zephyr默认给Cooperative线程分配小于0的优先级数值，而可抢占线程分配为正值。用户可修改编译选项来更改这两种线程的优先级区间，当然要保证Cooperative线程的优先级数值区间小于可抢占线程。线程运行过程中，其优先级可以被更改。一张图表示线程优先级关系：</p>
<p><img src="https://docs.zephyrproject.org/latest/_images/priorities.svg" alt="https://docs.zephyrproject.org/latest/_images/priorities.svg"></p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程有一列属性，根据这些不同的属性，线程的执行方式也会有相应的差异。一些主要的属性如下:  </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>K_ESSENTIAL</td>
<td>表示线程是核心线程，该类线程若有退出或者取消是系统不允许的，系统会断言严重错误</td>
</tr>
<tr>
<td>K_SSE_REGS</td>
<td>X86独有属性，表示是否使用CPU的SSE功能</td>
</tr>
<tr>
<td>K_FP_REGS</td>
<td>表示是否使用CPU的浮点计算寄存器</td>
</tr>
<tr>
<td>K_USER</td>
<td>表示用户空间态线程，只有当系统编译选项CONFIG_USERSPACE打开时才有效</td>
</tr>
<tr>
<td>K_INHERIT_PERMS</td>
<td>对USERSPACE线程有效，表示是否继承父进程的权限属性</td>
</tr>
</tbody></table>
<h2 id="线程自定义数据"><a href="#线程自定义数据" class="headerlink" title="线程自定义数据"></a>线程自定义数据</h2><p>线程可以自定义数据，使得应用可以对线程功能做一定程度的扩展。</p>
<h2 id="特殊线程"><a href="#特殊线程" class="headerlink" title="特殊线程"></a>特殊线程</h2><h3 id="系统线程"><a href="#系统线程" class="headerlink" title="系统线程"></a>系统线程</h3><p>Zephyr内核初始化会创建的一些初始线程。主要分为主线程和空闲线程。</p>
<h3 id="Workqueue"><a href="#Workqueue" class="headerlink" title="Workqueue"></a>Workqueue</h3><p>与Linux系统的Workqueue相似，主要用于中断下半部使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文为Zephyr系统，线程的基本概念。主要介绍了线程的状态、分类、优先级等基础思想。</p>
]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
  </entry>
  <entry>
    <title>Zephyr线程管理 - 数据结构与API</title>
    <url>/p/5b9388b6.html</url>
    <content><![CDATA[<p>本文介绍和Zephyr线程的数据结构，及相应的API。  </p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Zephyr数据结构使用k_thread定义，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_base</span> <span class="title">base</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">callee_saved</span> <span class="title">callee_saved</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *init_data;</span><br><span class="line">	<span class="keyword">void</span> (*fn_abort)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_MONITOR)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">thread_entry</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">next_thread</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_NAME)</span></span><br><span class="line">	<span class="keyword">char</span> name[CONFIG_THREAD_MAX_NAME_LEN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_CUSTOM_DATA</span></span><br><span class="line">	<span class="keyword">void</span> *custom_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_USERSPACE_LOCAL_DATA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_userspace_local_data</span> *<span class="title">userspace_local_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ERRNO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_USERSPACE</span></span><br><span class="line">	<span class="keyword">int</span> errno_var;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_STACK_INFO)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_stack_info</span> <span class="title">stack_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_THREAD_STACK_INFO */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USERSPACE)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">mem_domain_info</span> <span class="title">mem_domain_info</span>;</span></span><br><span class="line">	<span class="keyword">k_thread_stack_t</span> *stack_obj;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_USERSPACE */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USE_SWITCH)</span></span><br><span class="line">	<span class="keyword">int</span> swap_retval;</span><br><span class="line">	<span class="keyword">void</span> *switch_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_mem_pool</span> *<span class="title">resource_pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">thread_arch</span> <span class="title">arch</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>参数说明：</p>
<ul>
<li><strong>base</strong>： 存储Thread的基础调度信息结构体。具体如下：<ul>
<li><strong>qnode_dlist/qnode_rb</strong>: 指向线程在等待/就绪队列的位置</li>
<li><strong>pended_on</strong>:指向线程所在的等待队列（仅对红黑树等待队列有效）</li>
<li><strong>user_options</strong>:线程参数</li>
<li><strong>thread_state</strong>:线程状态</li>
<li><strong>union(prio/sched_locked/preemt)</strong>: 线程的抢占优先级相关参数</li>
<li><strong>order_key</strong>:被调度器使用来比对优先级</li>
<li>SMP相关参数先忽略</li>
<li><strong>timeout</strong>:指向超时队列中该线程的位置</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">thread_base</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">sys_dnode_t</span> qnode_dlist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rbnode</span> <span class="title">qnode_rb</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">_wait_q_t</span> *pended_on;</span><br><span class="line">	<span class="keyword">u8_t</span> user_options;</span><br><span class="line">	<span class="keyword">u8_t</span> thread_state;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__</span></span><br><span class="line">			<span class="keyword">u8_t</span> sched_locked;</span><br><span class="line">			<span class="keyword">s8_t</span> prio;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* LITTLE and PDP */</span></span></span><br><span class="line">			<span class="keyword">s8_t</span> prio;</span><br><span class="line">			<span class="keyword">u8_t</span> sched_locked;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">u16_t</span> preempt;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SCHED_DEADLINE</span></span><br><span class="line">	<span class="keyword">int</span> prio_deadline;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">u32_t</span> order_key;</span><br><span class="line"><span class="comment">/*SMP 相关*/</span></span><br><span class="line">	<span class="keyword">void</span> *swap_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYS_CLOCK_EXISTS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">timeout</span> <span class="title">timeout</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>_callee_saved</strong>: 与平台相关的一些参数，主要保存一些线程相关寄存器信息。</li>
<li><strong>init_data</strong>: 线程静态初始化数据</li>
<li><strong>fn_abort</strong>: 线程取消回调函数</li>
<li><strong>entry</strong>:Thread入口函数</li>
<li><strong>next_thread</strong>: Thread链表中下一个线程指针</li>
<li><strong>name</strong>: Thread名称</li>
<li><strong>custom_data</strong>: Thread自定义数据</li>
<li><strong>userspace_local_data</strong>:用户空间态数据</li>
<li><strong>errno_var</strong>: 错误编号（类似Linux的Errno）</li>
<li><strong>stack_info</strong>: 栈信息，主要记录栈的开始地址与大小</li>
<li><strong>mem_domain_info</strong>: 线程内存域信息（用户空间态线程使用）</li>
<li><strong>stack_obj</strong>: 线程栈地址</li>
<li><strong>swap_retval</strong>: TBD</li>
<li><strong>switch_handle</strong>: TBD</li>
<li><strong>resource_pool</strong>:线程所占用的资源池</li>
<li><strong>arch</strong>: 体系结构相关的线程数据。因为体系结构不同，所占大小也不相同，为保证其他参数的位置相同，Zephyr将此参数置于线程末尾</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Zephyr定义了一系列的API来使用线程：</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>线程创建的函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">K_THREAD_DEFINE(my_tid, MY_STACK_SIZE, my_entry_point, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, MY_PRIORITY, <span class="number">0</span>, K_NO_WAIT);</span><br><span class="line"><span class="function"><span class="keyword">k_tid_t</span> <span class="title">k_thread_create</span><span class="params">(structk_thread *new_thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>, <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry, <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3, <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">s32_t</span> <span class="built_in">delay</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>前者主要用于静态定义线程，而后者主要用于运行时创建线程。线程的静态定义主要就是定义如下结构体（参数明确，不做一一解释）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">static_thread_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_thread</span> *<span class="title">init_thread</span>;</span></span><br><span class="line">	<span class="keyword">k_thread_stack_t</span> *init_stack;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> init_stack_size;</span><br><span class="line">	<span class="keyword">k_thread_entry_t</span> init_entry;</span><br><span class="line">	<span class="keyword">void</span> *init_p1;</span><br><span class="line">	<span class="keyword">void</span> *init_p2;</span><br><span class="line">	<span class="keyword">void</span> *init_p3;</span><br><span class="line">	<span class="keyword">int</span> init_prio;</span><br><span class="line">	<span class="keyword">u32_t</span> init_options;</span><br><span class="line">	<span class="keyword">s32_t</span> init_delay;</span><br><span class="line">	<span class="keyword">void</span> (*init_abort)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *init_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>k_thread_create的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">k_tid_t</span> <span class="title">z_impl_k_thread_create</span><span class="params">(struct k_thread *new_thread,      <span class="comment">//代码注解1</span></span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">s32_t</span> <span class="built_in">delay</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__ASSERT(!z_arch_is_in_isr(), <span class="string">"Threads may not be created in ISRs"</span>); <span class="comment">//代码注解2</span></span><br><span class="line"></span><br><span class="line">	z_setup_new_thread(new_thread, <span class="built_in">stack</span>, stack_size, entry, p1, p2, p3, prio, options, <span class="literal">NULL</span>); <span class="comment">//代码注解3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">delay</span> != K_FOREVER) &#123;</span><br><span class="line">		schedule_new_thread(new_thread, <span class="built_in">delay</span>);  <span class="comment">//代码注解4</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> new_thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>代码注解1</strong>： 这里函数名为何是z_impl_k_thread_create而不是k_thread_create。因为Zephyr在编译时使用了脚本来生成系统中API调用。所以在搜索源码时大部分时间只能搜索到z_impl_xxx形式的系统函数定义。不过编译连接前，是可以看得到不带<em>z_impl_</em>形式的API，最终调用的即是z_impl_k_thread_create</li>
<li><strong>代码注解2</strong>：中断上下文不能创建线程，因为创建线程会需要申请系统资源，也会引起重新调度，带来不可预料的后果</li>
<li><strong>代码注解3</strong>：创建新线程</li>
<li><strong>代码注解4</strong>：将线程加入调度</li>
</ul>
<p>z_setup_new_thread定义如下(为方便分析，代码做一定简化)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_setup_new_thread</span><span class="params">(struct k_thread *new_thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>, <span class="keyword">size_t</span> stack_size, <span class="keyword">k_thread_entry_t</span> entry, <span class="keyword">void</span> *p1, <span class="keyword">void</span> *p2, <span class="keyword">void</span> *p3, <span class="keyword">int</span> prio, <span class="keyword">u32_t</span> options, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	stack_size = adjust_stack_size(stack_size); <span class="comment">//代码注解1</span></span><br><span class="line"></span><br><span class="line">	z_arch_new_thread(new_thread, <span class="built_in">stack</span>, stack_size, entry, p1, p2, p3, prio, options); <span class="comment">//代码注解2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_MONITOR</span></span><br><span class="line">	new_thread-&gt;entry.pEntry = entry;</span><br><span class="line">	new_thread-&gt;entry.parameter1 = p1;</span><br><span class="line">	new_thread-&gt;entry.parameter2 = p2;</span><br><span class="line">	new_thread-&gt;entry.parameter3 = p3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">	new_thread-&gt;next_thread = _kernel.threads;</span><br><span class="line">	_kernel.threads = new_thread;</span><br><span class="line">	k_spin_unlock(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_NAME</span></span><br><span class="line">	<span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">strncpy</span>(new_thread-&gt;name, name,</span><br><span class="line">			CONFIG_THREAD_MAX_NAME_LEN - <span class="number">1</span>);</span><br><span class="line">		new_thread-&gt;name[CONFIG_THREAD_MAX_NAME_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>; <span class="comment">//代码注解4</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN</span></span><br><span class="line">	<span class="keyword">if</span> (!_current) &#123;</span><br><span class="line">		new_thread-&gt;resource_pool = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	new_thread-&gt;resource_pool = _current-&gt;resource_pool; <span class="comment">//代码注解5</span></span><br><span class="line">	sys_trace_thread_create(new_thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码注解1</strong>: 修正栈大小，主要为线程栈地址随机化功能使用（算是简单的地址随机化方案，感兴趣大家可以搜索一下ASLR相关资料），目的为的是防止破解攻击</li>
<li><strong>代码注解2</strong>: 执行体系结构相关的线程创建过程（本文接下来以ARM Cortex-M为例介绍）</li>
<li><strong>代码注解3/代码注解4</strong>: 线程一些公共参数的初始化，用于系统监视器监视线程状态。</li>
<li><strong>代码注解5</strong>: 继承父线程的资源池。</li>
</ul>
<p>其中z_arch_new_thread代码如下(省去部分代码)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_arch_new_thread</span><span class="params">(struct k_thread *thread, <span class="keyword">k_thread_stack_t</span> *<span class="built_in">stack</span>,  <span class="keyword">size_t</span> stackSize, <span class="keyword">k_thread_entry_t</span> pEntry,  <span class="keyword">void</span> *parameter1, <span class="keyword">void</span> *parameter2, <span class="keyword">void</span> *parameter3, <span class="keyword">int</span> priority, <span class="keyword">unsigned</span> <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *pStackMem = Z_THREAD_STACK_BUFFER(<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">char</span> *stackEnd;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">u32_t</span> top_of_stack_offset = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">	Z_ASSERT_VALID_PRIO(priority, pEntry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT) \</span></span><br><span class="line">	&amp;&amp; defined(CONFIG_USERSPACE)</span><br><span class="line">	stackSize -= MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_FLOAT) &amp;&amp; defined(CONFIG_FP_SHARING) \</span></span><br><span class="line">	&amp;&amp; defined(CONFIG_MPU_STACK_GUARD)</span><br><span class="line">	<span class="keyword">if</span> ((options &amp; K_FP_REGS) != <span class="number">0</span>) &#123;</span><br><span class="line">		pStackMem += MPU_GUARD_ALIGN_AND_SIZE_FLOAT</span><br><span class="line">			- MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line">		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT</span><br><span class="line">			- MPU_GUARD_ALIGN_AND_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	stackEnd = pStackMem + stackSize;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">esf</span> *<span class="title">pInitCtx</span>;</span></span><br><span class="line"></span><br><span class="line">	z_new_thread_init(thread, pStackMem, stackSize, priority,  options);</span><br><span class="line"></span><br><span class="line">	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -</span><br><span class="line">		(<span class="keyword">char</span> *)top_of_stack_offset - <span class="keyword">sizeof</span>(struct __basic_sf)));</span><br><span class="line">        </span><br><span class="line">	pInitCtx-&gt;basic.pc = (<span class="keyword">u32_t</span>)z_thread_entry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CPU_CORTEX_M)</span></span><br><span class="line">	pInitCtx-&gt;basic.pc &amp;= <span class="number">0xfffffffe</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	pInitCtx-&gt;basic.a1 = (<span class="keyword">u32_t</span>)pEntry;</span><br><span class="line">	pInitCtx-&gt;basic.a2 = (<span class="keyword">u32_t</span>)parameter1;</span><br><span class="line">	pInitCtx-&gt;basic.a3 = (<span class="keyword">u32_t</span>)parameter2;</span><br><span class="line">	pInitCtx-&gt;basic.a4 = (<span class="keyword">u32_t</span>)parameter3;</span><br><span class="line">	pInitCtx-&gt;basic.xpsr = <span class="number">0x01000000</span>UL; </span><br><span class="line"></span><br><span class="line">	thread-&gt;callee_saved.psp = (<span class="keyword">u32_t</span>)pInitCtx;</span><br><span class="line">	thread-&gt;arch.basepri = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_USERSPACE) || defined(CONFIG_FP_SHARING)</span></span><br><span class="line">	thread-&gt;arch.mode = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">void</span> <span class="title">z_new_thread_init</span><span class="params">(struct k_thread *thread, <span class="keyword">char</span> *pStack, <span class="keyword">size_t</span> stackSize, <span class="keyword">int</span> prio, <span class="keyword">unsigned</span> <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_INIT_STACKS</span></span><br><span class="line">	<span class="built_in">memset</span>(pStack, <span class="number">0xaa</span>, stackSize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_SENTINEL</span></span><br><span class="line">	*((<span class="keyword">u32_t</span> *)pStack) = STACK_SENTINEL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_STACK_SENTINEL */</span></span></span><br><span class="line">	z_init_thread_base(&amp;thread-&gt;base, prio, _THREAD_PRESTART, options);</span><br><span class="line">	thread-&gt;init_data = <span class="literal">NULL</span>;</span><br><span class="line">	thread-&gt;fn_abort = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_CUSTOM_DATA</span></span><br><span class="line">	thread-&gt;custom_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_NAME</span></span><br><span class="line">	thread-&gt;name[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_THREAD_STACK_INFO)</span></span><br><span class="line">	thread-&gt;stack_info.start = (<span class="keyword">uintptr_t</span>)pStack;</span><br><span class="line">	thread-&gt;stack_info.<span class="built_in">size</span> = (<span class="keyword">u32_t</span>)stackSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_THREAD_STACK_INFO */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上初始化过程执行后，线程的栈空间如图所示：</p>
<p><img src="http://pic.l2h.site/QQMail_0.png" alt="http://pic.l2h.site/QQMail_0.png"></p>
<p>以上为线程的初始化过程</p>
<h3 id="线程执行"><a href="#线程执行" class="headerlink" title="线程执行"></a>线程执行</h3><p>线程开始执行调用<em>z_impl_k_thread_start</em>函数。该函数也会被k_thread_create–&gt;schedule_new_thread间接调用，其源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_start</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (z_has_thread_started(thread)) &#123;</span><br><span class="line">		k_spin_unlock(&amp;lock, key);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z_mark_thread_as_started(thread); <span class="comment">//代码注解1</span></span><br><span class="line">	z_ready_thread(thread);  <span class="comment">//代码注解2</span></span><br><span class="line">	z_reschedule(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码注解1</strong>：仅仅将thread_state标记上_THREAD_PRESTART  </li>
<li><strong>代码注解2</strong>：将Thread加入调度的ready Q，关于线程调度之后文章进行介绍</li>
<li><strong>代码注解3</strong>：调用系统的reschedule函数触发系统调度。对Cortex-M3来讲，将会调用系统的PENDSV系统指令，悬起系统切换异常。下图为引用自《Cortex-M3权威指南》的一张PendSV使用的示例：</li>
</ul>
<p><img src="http://pic.l2h.site/PendSV.png" alt="PendSV"></p>
<h3 id="线程挂起"><a href="#线程挂起" class="headerlink" title="线程挂起"></a>线程挂起</h3><p>线程挂起使用<em>z_impl_k_thread_suspend</em>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_suspend</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">k_spinlock_key_t</span> key = k_spin_lock(&amp;lock);</span><br><span class="line">	z_thread_single_suspend(thread);</span><br><span class="line">	sys_trace_thread_suspend(thread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (thread == _current) &#123;</span><br><span class="line">		z_reschedule(&amp;lock, key); <span class="comment">//代码注解3</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		k_spin_unlock(&amp;lock, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_thread_single_suspend</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (z_is_thread_ready(thread)) &#123;</span><br><span class="line">		z_remove_thread_from_ready_q(thread); <span class="comment">//代码注解1</span></span><br><span class="line">	&#125;</span><br><span class="line">	z_mark_thread_as_suspended(thread); <span class="comment">//代码注解2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码注解3</strong>：若该线程正在运行，调用reschedule重新调度</li>
<li><strong>代码注解1</strong>：将Thread从调度的ready Q移除</li>
<li><strong>代码注解2</strong>：对线程状态做挂起标记</li>
</ul>
<h3 id="线程继续（resume）"><a href="#线程继续（resume）" class="headerlink" title="线程继续（resume）"></a>线程继续（resume）</h3><p>线程Resume仅做线程的标记，不再进行分析</p>
<h3 id="线程取消（Abort）"><a href="#线程取消（Abort）" class="headerlink" title="线程取消（Abort）"></a>线程取消（Abort）</h3><p>线程取消使用API <em>z_impl_k_thread_abort</em>,代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_impl_k_thread_abort</span><span class="params">(<span class="keyword">k_tid_t</span> thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">	key = irq_lock();</span><br><span class="line">	__ASSERT(!(thread-&gt;base.user_options &amp; K_ESSENTIAL),</span><br><span class="line">		 <span class="string">"essential thread aborted"</span>);</span><br><span class="line"></span><br><span class="line">	z_thread_single_abort(thread);</span><br><span class="line">	z_thread_monitor_exit(thread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_current == thread) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((SCB-&gt;ICSR &amp; SCB_ICSR_VECTACTIVE_Msk) == <span class="number">0</span>) &#123;</span><br><span class="line">			(<span class="keyword">void</span>)z_swap_irqlock(key);</span><br><span class="line">			CODE_UNREACHABLE;   <span class="comment">//代码注解7</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			SCB-&gt;ICSR |= SCB_ICSR_PENDSVSET_Msk; <span class="comment">//代码注解7</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	z_reschedule_irqlock(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">z_thread_single_abort</span><span class="params">(struct k_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (thread-&gt;fn_abort != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		thread-&gt;fn_abort();     <span class="comment">//代码注解1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SMP)) &#123;</span><br><span class="line">		z_sched_abort(thread);  <span class="comment">//代码注解2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (z_is_thread_ready(thread)) &#123;</span><br><span class="line">		z_remove_thread_from_ready_q(thread); <span class="comment">//代码注解3</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (z_is_thread_pending(thread)) &#123;</span><br><span class="line">			z_unpend_thread_no_timeout(thread); <span class="comment">//代码注解4</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (z_is_thread_timeout_active(thread)) &#123;</span><br><span class="line">			(<span class="keyword">void</span>)z_abort_thread_timeout(thread); <span class="comment">//代码注解5</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	thread-&gt;base.thread_state |= _THREAD_DEAD; <span class="comment">//代码注解6</span></span><br><span class="line">	sys_trace_thread_abort(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码注解1</strong>：先执行该线程的退出回调函数（供应用程序做特殊处理）</li>
<li><strong>代码注解2</strong>：SMP相关通知，此处不做深入分析</li>
<li><strong>代码注解3</strong>：将Thread从调度的ready Q移除</li>
<li><strong>代码注解4</strong>：将Thread从Pending Q也移除</li>
<li><strong>代码注解5</strong>：若Thread正在等待一定超时后调度，也将其从超时列表中移除</li>
<li><strong>代码注解6</strong>：对线程状态做死亡（Dead）标记</li>
<li><strong>代码注解7</strong>：待添加</li>
<li><strong>代码注解8</strong>：置起PendSV，进行重新调度</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上为线程使用相关结构体、API及对应的分析。可以看出，线程相关函数的实现足够简洁明了，这也正应了Zephyr的设计思想。有任何问题，欢迎留言讨论。</p>
]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
  </entry>
  <entry>
    <title>无前</title>
    <url>/p/89f375ed.html</url>
    <content><![CDATA[<p>距离上次写博客已经有约5个月了。一直没有时间和动力来更新博客。</p><p>最近半年，工作异常忙碌，不止一次跟XH表示，这是我工作以来最为忙碌的时光。所幸所做之工作，又是个人认为比较前言且具有挑战的项目。虽然充实，但也持续迷茫着。</p><p>外面的世界，贸易战、洪水、新冠肆虐。家里却也非绝对宁静。</p><p>去年八月一年来，搬了三次家。上次博客更新时，还在20公里之外的出租房里。现在，也幸得终于可以回到自己的寒舍。房子虽小，也有雨季漏水的问题。却也增添了几分方便，更多了归属感。</p><a id="more"></a>



<p>预见还会有的动迁和变化，希望一切顺利。也希望一直以来的愿望还是可以达成。</p>
<p>努力！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>在家办公记</title>
    <url>/p/f790099a.html</url>
    <content><![CDATA[<p>今天是20200202，难得的日期对称日，有必要记上一篇。</p><p>四川省最后还是刚起，仅仅发了一个不痛不痒的通知说企业可自行安排复工时间，成为遵守国务院命令2月3日准时上班的唯一一个省份。</p><p><img src="https://l2h.site/images/posts/20200202/1.jpeg" alt="全国开复工时间表"></p><p>看着最新的疫情地图，加上查到的1600多万的成都人口，心理慌得不要不要的。料医学博士的省长也没办法抑制得了新病毒的传播，希望成都不要学武汉的各种神操作。幸好公司人性化，允许在家办公。</p><a id="more"></a>



<p><img src="https://l2h.site/images/posts/20200202/2.png" alt="疫情地图"></p>
<p>仔细想想，如果可以解决公司信息泄露问题，IT行业在家办公其实挺好的。最起码有以下几点优势：</p>
<ul>
<li>节省时间（各种通勤时间）</li>
<li>对企业来讲节省各种水电物业等开销。</li>
<li>居家环境，压力更小，做事效率应也会更高。</li>
</ul>
<p>明天先这样工作第一天试试看，如果可行，强烈建议公司在疫情结束后也继续推广！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>哎，Notepad++</title>
    <url>/p/8b759bb.html</url>
    <content><![CDATA[<p>一直以为技术是无国界的，也是不带政治观点的。没想到被NotePad++ 疯狂打脸。<br>来看看其作者如何表达政治观点的。<br><img src="https://l2h.site/images/posts/20201007/1.png" alt="NoteFuxk++"></p><p>至于为什么这么多对华内容，后来了解到这是一个台湾人。<br>在台湾公司呆了这么多年，从来不会也不可能表达政治观点。同事也都是客客气气的。<br>但是相信无论是我们或者台湾同事，也都能感受到对方的想法。例如，</p><a id="more"></a>

<ul>
<li>台湾同事有意无意将中国、台湾放在并列的层面讨论。Nice一点的台湾同事发现自己讲错了以后也会改成“大陆”这种讲法</li>
<li>而我又习惯用大陆、台湾这样的逻辑和方式</li>
</ul>
<p>相信看到作者这些政治宣言后，个人不会再去下载该软件，也会跟同事朋友提醒，远离这个软件!</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 数据结构</title>
    <url>/p/1dc6adc2.html</url>
    <content><![CDATA[<p>内存管理是Linux内核最为复杂且最为重要的部分，本文从原理及代码角度对Linux内存管理机制进行分析。</p><h2 id="内存的划分"><a href="#内存的划分" class="headerlink" title="内存的划分"></a>内存的划分</h2><p>Linux将内存从大到小依次划分为Node（节点）-&gt;Zone（内存域）-&gt;Page（页）：</p><ul>
<li>节点：在大型结算及系统中，内存有不同的簇，依据对处理器距离的不同，访问这些簇有不同的代价。而这些簇就可以成为节点。例：在PC系统中可以理解为实际挂载的物理内存；在嵌入式系统中，有两块内存芯片A和B，分别代表一个节点。</li>
<li>内存域：内存域并不是物理存在的概念，是Linux系统对每个内存节点进行管理的单位，每个节点的内存域表示的是对该节点不同地址范围的划分。一般内存域有三种，分别为Normal、DMA和HighMem。</li>
<li>页：在每个内存域中，内存被划分为大小固定的块（32位系统一般为4K大小），为内核进行内存分配的基本单位（当然内核内存管理机制其实更为复杂，“基本单位”不代表每次分配内存最小就要分到4K。后边可以看到，当需要获取小于4K大小的内存时，内核有Slab分配器来满足要求）</li>
</ul><a id="more"></a>


<p>一张图说明Node、Zone和Page的关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                  Node 1            Node 2           Node 3</span><br><span class="line">                       +----------+     +----------+     +----------+</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |Zone_High |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       +----------+     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |Zone_Norm |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">                       +----------+     |          |     |          |</span><br><span class="line">                       |          |     |          |     |          |</span><br><span class="line">     page  page        |Zone_DMA  |     |          |     |          |</span><br><span class="line">+-+--+--+--+--+        |          |     |          |     |          |</span><br><span class="line">| |  |  |  |  |  &lt;--------+       |     |          |     |          |</span><br><span class="line">+-+--+--+--+--+        +----------+     +----------+     +----------+</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>构成上述三个内存划分的数据结构如下：</p>
<h3 id="内存节点"><a href="#内存节点" class="headerlink" title="内存节点"></a>内存节点</h3><p>Node对应的结构为pglist_data_t，定义如下（为方便理解，省略部分结构体成员）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="keyword">int</span> nr_zones;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page  range, including holes */</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span> <span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="keyword">int</span> kswapd_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kswapd_classzone_idx;</span><br><span class="line">    <span class="keyword">int</span> kswapd_failures;        <span class="comment">/* Number of 'reclaimed == 0' runs */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="keyword">enum</span> zone_type kcompactd_classzone_idx;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_next_window;</span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       totalreserve_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lru_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line">    <span class="comment">/* Number of non-deferred pages */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> static_init_pgcnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inactive_ratio;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/* Per-node vmstats */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>node_zones</strong>: 内存节点上的内存域，分别为 ZONE_HIGHMEM, ZONE_NORMAL, ZONE_DMA。新版Linux还增加了ZONE_MOVABLE和ZONE_DEVICE。</li>
<li><strong>node_zonelists:</strong> 对内存域进行类别指定的优先级顺序。例，当ZONE_HIGHMEM分配失败时，会u退到ZONE_DMA类型后ZONE_NORMAL类型</li>
<li><strong>nr_zones:</strong> 该节点上的内存域数量</li>
<li><strong>node_mem_map:</strong> 节点中页面的映射图</li>
<li><strong>bdata:</strong> 与内核初始化内存分配器相关数据</li>
<li><strong>node_size_lock</strong>： 与内存热拔插相关</li>
<li><strong>node_start_pfn:</strong> 内存节点的起始页。</li>
<li><strong>node_present_pages:</strong> 物理页面数量<strong>.</strong></li>
<li><strong>node_spanned_pages:</strong> 内存节点物理页面的大小</li>
<li><strong>node_id:</strong> 节点编号</li>
<li><strong>kswapd_wait</strong>/<strong>pfmemalloc_wait</strong>/<strong>kswapd</strong>/<strong>kswapd_order</strong>/<strong>kswapd_classzone_idx/kswapd_failures:</strong> kswapd内核线程相关参数</li>
<li><strong>……..</strong></li>
</ul>
<h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>内存区域对应的结构体为struct zone，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_NR_WMARK];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line">    <span class="keyword">long</span> lowmem_reserve_MAX_NR_ZONES];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>  *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       zone_start_pfn;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       managed_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       spanned_pages;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       present_pages;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>      *name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="keyword">seqlock_t</span>       span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> initialized;</span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area_MAX_ORDER</span>];</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>       flags;</span><br><span class="line">    <span class="keyword">spinlock_t</span>      lock;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">atomic_long_t</span>       vm_stat_NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>watermark</strong>: 内存域的水位</li>
<li><strong>nr_reserved_highatomic:</strong> 紧急内存大小，</li>
<li><strong>lowmem_reserve</strong>:内存域最少保留内存</li>
<li><strong>zone_pgdat</strong>: 所在内存节点指针</li>
<li><strong>pageset</strong>: 每个CPU维护的页面列表</li>
<li><strong>zone_start_pfn</strong>:内存域第一个页的索引</li>
<li><strong>managed_pages</strong>: 伙伴系统管理的所有页面数量</li>
<li><strong>spanned_pages</strong>: 内存域所跨越所有内存页数量</li>
<li><strong>present_pages</strong>: 内存域物理内存所有页数量(除去内存空洞后的部分)present_pages=spanned_pages-absent_pages</li>
<li><strong>name</strong>: 区域名</li>
<li><strong>free_area</strong>:所有空闲页面的数组</li>
<li><strong>flags</strong>:内存域标识</li>
<li><strong>lock</strong>:保护free_area的锁</li>
<li><strong>vm_stat</strong>:虚拟内存统计信息</li>
</ul>
<p>特别说明一下内存域的水位（Watermark），它表示几个阈值，用来管理内核线程kswapd唤起与休眠的。当域内可用内存水位较高时，kswapd不用起来工作，而水位较低时，kswapd需要唤起来回收内存。如下图（来自深入理解Linux虚拟内存管理）：</p>
<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.40.53.png" alt></p>
<h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>系统中每个物理页面都有数据结构struct page与其关联，用于管理页面的使用。结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;       </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span> </span><br><span class="line">        <span class="keyword">void</span> *s_mem;            <span class="comment">/* slab first object */</span></span><br><span class="line">        <span class="keyword">atomic_t</span> compound_mapcount; <span class="comment">/* first tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;     <span class="comment">/* slub first free object */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span><br><span class="line">        <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">union</span> &#123;</span><br><span class="line">                <span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> active;        <span class="comment">/* SLAB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>            <span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">int</span> units;          <span class="comment">/* SLOB */</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">atomic_t</span> _refcount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Third double word block */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>  <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">int</span> pages;  <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="keyword">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            short <span class="keyword">int</span> pages;</span><br><span class="line">            short <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>   </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">unsigned</span> short <span class="keyword">int</span> compound_dtor;</span><br><span class="line">            <span class="keyword">unsigned</span> short <span class="keyword">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> __pad;    </span><br><span class="line">            <span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SLuB: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;          <span class="comment">/* Kernel virtual address (NULL if  not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页面结构体使用双字块来划分：</p>
<ul>
<li><p>第一个双字</p>
<ul>
<li><p>flags: 页面状态，脏页、上锁等院子标记</p>
</li>
<li><p>联合体</p>
<ul>
<li><p>mapping：指向inode address_space</p>
</li>
<li><p>s_mem：slab首对象</p>
</li>
<li><p>compound_mapcount：</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>第二个双字：</p>
<ul>
<li><p>联合体</p>
<ul>
<li><p>index：页面偏移</p>
</li>
<li><p>freelist：slab/slob的首个可用对象</p>
</li>
</ul>
</li>
<li><p>联合体：slab/slub/slob相关的记数（取决于编译内核时选择的管理方式）</p>
</li>
</ul>
</li>
<li><p>第三个双字：</p>
<ul>
<li><p>lru：换出页列表</p>
</li>
<li><p>pgmap:</p>
</li>
<li><p>rcu_head</p>
</li>
<li><p>结构体，用于slub管理</p>
</li>
<li><p>结构体，用于复合页管理</p>
</li>
</ul>
</li>
<li><p>联合体(ptl/slab_cache): slab指针，或者PTE自旋锁</p>
</li>
<li><p>virtual: 内核虚拟地址。用于高端内存中的页，即无法直接映射到内核内存中的页</p>
</li>
</ul>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>Linux进行内存寻址时，往往不会直接内存物理地址，需要经过虚拟地址到物理地址的转化。使用虚拟地址的好处是可以避免进程与进程间互踩内存（除非特别指定共享内存），同时虚拟内存的换出换入使得进程使用超过物理内存大小的内存范围。</p>
<p>CPU中内存管理单元（MMU）作用就是根据内存中特定的转化表格（不错，页表本身也是需要内存存储的），将虚拟地址转化为真正的物理地址。而这个表格就是我们所讲的页表。</p>
<p>取决于体系结构，Linux采用三级或者四级页表机制：</p>
<ul>
<li>PGD：Page Global Directory，全局页表目录</li>
<li>PUD：Page Upper Directory，上级页表目录</li>
<li>PMD：Page Middle Directory，中级页表目录</li>
<li>PTE：Page Table Entry，页表表项</li>
</ul>
<p>每级表项所占位数，取决于我们编译内核时的选择。一般情况下，取决于寻址宽度，以及CPU体系结构每级页表所占位数是有约定俗成的。</p>
<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8A%E5%8D%887.56.58.png" alt></p>
<p>内核在arch/xxx/include/asm/page.h（其中xxx表示CPU体系结构）定义了一系列的类型、函数和宏来方便对每级页表进行操作。</p>
<p>如上图我们看到的几个SHIFT宏定义，是为了方便通过位移操作来快速获取对应等级页表。</p>
<p>在IA64中用来表示以上各级页表目录的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pte; &#125; <span class="keyword">pte_t</span>;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pmd; &#125; <span class="keyword">pmd_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_PGTABLE_LEVELS == 4</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pud; &#125; <span class="keyword">pud_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> pgd; &#125; <span class="keyword">pgd_t</span>;</span><br></pre></td></tr></table></figure>

<p>与页表相关的宏或者函数定义有<a href="https://elixir.bootlin.com/linux/latest/ident/pmd_alloc" target="_blank" rel="noopener">pmd/pte/pgd_alloc</a>/free()等等，具体可以参考include/linux/mm.h。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了Linux内核内存管理的基本单位划分Node、Zone和Page及对应的数据结构，同时对页表的基本概念进行了介绍。将在下一文分析Linux初始化流程中对内存的管理。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 从内核启动过程透视内存管理</title>
    <url>/p/8f5117c5.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第三篇</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
</blockquote>
</blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以Intel X64 CPU为例，Linux的初始化可大致分为如下几个过程：</p><ol>
<li>Loader跳转到内核后的实模式(Real Mode)</li>
<li>32位保护模式跳转到64位长模式</li>
<li>64位长模式下解压内核</li>
<li>解压内核后，建立新的页表映射，并跳转到Arch（平台）相关C代码</li>
<li>执行平台无关初始化代码</li>
</ol><a id="more"></a>


<p>内存管理占据了以上过程的重要角色。包括了内存布局规划、分段管理、页表配置、内核移动等。</p>
<p>本文使用Qemu模拟，基于Linux v5.13.9版本，按顺序介绍以上过程中的内存管理。</p>
<h2 id="实模式-Real-Mode"><a href="#实模式-Real-Mode" class="headerlink" title="实模式(Real Mode)"></a>实模式(Real Mode)</h2><p>使用如下命令启动编译好的64位内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel arch/x86/boot/bzImage -nographic  -append "console=ttyS0 nokaslr"  -s -S</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>内核参数”<strong>console=ttyS0 nokaslr</strong>“的主要作用为指定内核控制台，以及关闭KASLR功能（主要原因是为了调试方便，开启KASLR后每次开机内核解压的地址都是随机的）。</li>
<li>而-s和-S参数主要是为了GDB调试Qemu之用。  </li>
</ul>
<p>执行上述命令后，便得到如下图的内核地址分布。<br><img src="http://pic.l2h.site/Linux%20Boot%20Layout-1.png" alt="实模式内存分布" title="Figure 1. 实模式下内存分布"></p>
<p>根据内核文档<a href="https://www.kernel.org/doc/html/latest/x86/boot.html" target="_blank" rel="noopener">Linux/x86 Boot Protocol</a>，任何Boot Loader(Grub/Lilo/…)加载X86内核，均要遵守该协议。内核发展至今，该协议版本已经发展到了2.15。图中<em>X</em>为Boot Loader加载内核的起始偏移，在Qemu平台上该偏移为 <strong>0x10000</strong>。 加载后，内核Boot Sector开始执行，执行入口点为 <strong>_start</strong>。参考Linker Script <strong>arch/x86/boot/setup.ld</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-i386&quot;)</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	. = 0;</span><br><span class="line">	.bstext		: &#123; *(.bstext) &#125;</span><br><span class="line">	.bsdata		: &#123; *(.bsdata) &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>这里会直接跳转到<strong>start_of_setup</strong>开始执行。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">#arch/x86/boot/header<span class="number">.</span>S</span><br><span class="line"><span class="meta">	.globl</span>	_start</span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line"><span class="meta">		.byte</span>	<span class="number">0xeb</span>		# short (<span class="number">2</span>-<span class="built_in">byte</span>) jump</span><br><span class="line"><span class="meta">		.byte</span>	start_of_setup-1f</span><br><span class="line"></span><br><span class="line"><span class="meta">	.section</span> <span class="string">".entrytext"</span>, <span class="string">"ax"</span></span><br><span class="line"><span class="symbol">start_of_setup:</span></span><br><span class="line"># Force %es = %ds</span><br><span class="line">	movw	%ds, %ax</span><br><span class="line">	movw	%ax, %es</span><br><span class="line">	<span class="keyword">cld</span></span><br><span class="line"></span><br><span class="line">	movw	%ss, %dx</span><br><span class="line">	cmpw	%ax, %dx	# %ds == %ss?</span><br><span class="line">	movw	%sp, %dx</span><br><span class="line">	<span class="keyword">je</span>	2f		# -&gt; <span class="meta">assume</span> %sp is reasonably set</span><br><span class="line"></span><br><span class="line">	# Invalid %ss, make <span class="meta">up</span> a new stack</span><br><span class="line">	movw	$_end, %dx</span><br><span class="line">	testb	$CAN_USE_HEAP, loadflags</span><br><span class="line">	<span class="keyword">jz</span>	1f</span><br><span class="line">	movw	heap_end_ptr, %dx</span><br><span class="line"><span class="number">1</span>:	addw	$STACK_SIZE, %dx</span><br><span class="line">	<span class="keyword">jnc</span>	2f</span><br><span class="line">	xorw	%dx, %dx	# Prevent wraparound</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:	# Now %dx should point to the end of our stack space</span><br><span class="line">	andw	$~<span class="number">3</span>, %dx	# <span class="built_in">dword</span> <span class="meta">align</span> (might as well...)</span><br><span class="line">	<span class="keyword">jnz</span>	3f</span><br><span class="line">	movw	<span class="number">$0</span>xfffc, %dx	# Make sure we<span class="string">'re not zero</span></span><br><span class="line"><span class="string">3:	movw	%ax, %ss</span></span><br><span class="line"><span class="string">	movzwl	%dx, %esp	# Clear upper half of %esp</span></span><br><span class="line"><span class="string">	sti			# Now we should have a working stack</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># We will have entered with %cs = %ds+0x20, normalize %cs so it is on par with the other segments.</span></span><br><span class="line"><span class="string">	pushw	%ds</span></span><br><span class="line"><span class="string">	pushw	$6f</span></span><br><span class="line"><span class="string">	lretw</span></span><br><span class="line"><span class="string">6:</span></span><br><span class="line"><span class="string"># Check signature at end of setup</span></span><br><span class="line"><span class="string">	cmpl	$0x5a5aaa55, setup_sig</span></span><br><span class="line"><span class="string">	jne	setup_bad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Zero the bss</span></span><br><span class="line"><span class="string">	movw	$__bss_start, %di</span></span><br><span class="line"><span class="string">	movw	$_end+3, %cx</span></span><br><span class="line"><span class="string">	xorl	%eax, %eax</span></span><br><span class="line"><span class="string">	subw	%di, %cx</span></span><br><span class="line"><span class="string">	shrw	$2, %cx</span></span><br><span class="line"><span class="string">	rep; stosl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Jump to C code (should not return)</span></span><br><span class="line"><span class="string">	calll	main</span></span><br></pre></td></tr></table></figure>

<p>以上代码会为实模式代码执行清理方向位，并未C代码的执行分配堆空间和栈空间。接着跳转到6执行，检查内核代码加载的正确性。这里说明一下， <strong>lretw</strong>及之前两行汇编语句的作用是调用返回，之前两行是将返回地址保存在栈内，参考&lt;<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>&gt;。如注释，使用lret的目的是为了重置CS寄存器的值，确保与其他段寄存器一致。可参考Intel手册，ret指令的说明：</p>
<blockquote>
<p>When executing a far return, the processor pops the return instruction pointer from the top of the stack into the EIP<br>register, <strong>then pops the segment selector from the top of the stack into the CS register</strong>. The processor then begins<br>program execution in the new code segment at the new instruction pointer.</p>
</blockquote>
<p>接着清空BSS段后跳转到main函数执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* First, copy the boot header into the "zeropage" */</span></span><br><span class="line">	copy_boot_params();</span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (cmdline_find_option_bool(<span class="string">"debug"</span>))</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"early console in setup code\n"</span>);</span><br><span class="line">	init_heap();</span><br><span class="line">	<span class="keyword">if</span> (validate_cpu()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Unable to boot - please use a kernel appropriate "</span></span><br><span class="line">		     <span class="string">"for your CPU.\n"</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line">	set_bios_mode();</span><br><span class="line">	detect_memory();</span><br><span class="line">	keyboard_init();</span><br><span class="line">	query_ist();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)</span></span><br><span class="line">	query_apm_bios();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)</span></span><br><span class="line">	query_edd();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	set_video();</span><br><span class="line">	go_to_protected_mode();</span><br></pre></td></tr></table></figure>

<p><strong>main</strong>函数的注释比较清楚,我们这里只讲一下copy_boot_param/detect_memory/go_to_protected_mode:</p>
<ul>
<li>copy_boot_param将内存中boot_param的信息（见图“实模式内存分布”）拷贝到全局变量boot_params内。boot_params存放的就是Linux Boot Protocol定义的哪些参数。有些栏位是编译过程中改写，有些烂尾由Boot Loader填写。boot_param包括内核cmdline会穿插内核初始化的各个子过程中</li>
<li>detect_memory主要是使用<a href="https://en.wikipedia.org/wiki/E820" target="_blank" rel="noopener">e820</a>获取内存的基础布局，存储到boot_param指定区域（<strong>boot_params.e820_table</strong>和<strong>boot_params.e820_entries</strong>）。</li>
<li>go_to_protected_mode主要是打开32位地址线（<a href="https://en.wikipedia.org/wiki/A20_line" target="_blank" rel="noopener">A20 Gate</a>），做GDT/IDT表的配置，关中断，打开保护模式，并跳转到32位代码开始执行。代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arch/x86/boot/pm.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_to_protected_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	realmode_switch_hook();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enable the A20 gate */</span></span><br><span class="line">	<span class="keyword">if</span> (enable_a20()) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"A20 gate not responding, unable to boot...\n"</span>);</span><br><span class="line">		die();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reset_coprocessor();</span><br><span class="line"></span><br><span class="line">	mask_all_interrupts();</span><br><span class="line"></span><br><span class="line">	setup_idt();</span><br><span class="line">	setup_gdt();</span><br><span class="line">	protected_mode_jump(boot_params.hdr.code32_start,</span><br><span class="line">			    (u32)&amp;boot_params + (ds() &lt;&lt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>protected_mode_jump</strong>是一段汇编代码，定义在arch/x86/boot/pmjump.S，这里不多过多分析。其主要就是修改CR0寄存器的PE（Protect Enable）位，并执行跳转指令跳转到32位代码(.Lin_pm32标号)处执行。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">#arch/x86/boot/pmjump<span class="number">.</span>S</span><br><span class="line">/*</span><br><span class="line"> * void protected_mode_jump(u32 entrypoint, u32 bootparams)<span class="comment">;</span></span><br><span class="line"> */</span><br><span class="line">SYM_FUNC_START_NOALIGN(protected_mode_jump)</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">	movl	%cr0, %edx</span><br><span class="line">	orb	$X86_CR0_PE, %dl	# Protected mode</span><br><span class="line">	movl	%edx, %cr0</span><br><span class="line"></span><br><span class="line">	# Transition to <span class="number">32</span>-bit mode</span><br><span class="line"><span class="meta">	.byte</span>	<span class="number">0x66</span>, <span class="number">0xea</span>		# ljmpl opcode</span><br><span class="line"><span class="number">2</span>:	.long	.Lin_pm32		# offset</span><br><span class="line"><span class="meta">	.word</span>	__BOOT_CS		# <span class="meta">segment</span></span><br><span class="line">SYM_FUNC_END(protected_mode_jump)</span><br><span class="line"></span><br><span class="line">SYM_FUNC_START_LOCAL_NOALIGN(.Lin_pm32)</span><br><span class="line">	# Set <span class="meta">up</span> data segments for flat <span class="number">32</span>-bit mode</span><br><span class="line">	movl	%ecx, %ds</span><br><span class="line">	movl	%ecx, %es</span><br><span class="line">	movl	%ecx, %fs</span><br><span class="line">	movl	%ecx, %gs</span><br><span class="line">	movl	%ecx, %ss</span><br><span class="line">	# The <span class="number">32</span>-bit code <span class="keyword">sets</span> <span class="meta">up</span> its own stack, but this way we <span class="built_in">do</span> have</span><br><span class="line">	# a valid stack if some debugging hack wants to use it.</span><br><span class="line">	addl	%ebx, %esp</span><br><span class="line"></span><br><span class="line">	# Set <span class="meta">up</span> TR to make Intel VT happy</span><br><span class="line">	<span class="keyword">ltr</span>	%di</span><br><span class="line"></span><br><span class="line">	# Clear registers to allow for future extensions to the</span><br><span class="line">	# <span class="number">32</span>-bit boot protocol</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	xorl	%ebx, %ebx</span><br><span class="line">	xorl	%ebp, %ebp</span><br><span class="line">	xorl	%edi, %edi</span><br><span class="line"></span><br><span class="line">	# Set <span class="meta">up</span> LDTR to make Intel VT happy</span><br><span class="line">	<span class="keyword">lldt</span>	%cx</span><br><span class="line"></span><br><span class="line">	jmpl	*%eax			# Jump to the <span class="number">32</span>-bit entrypoint</span><br><span class="line">SYM_FUNC_END(.Lin_pm32)</span><br></pre></td></tr></table></figure>

<p>32位代码伊始就是重建各个段寄存器为<strong>BOOT_DS。段寄存器内容为向GDT某项的段选择子，而</strong>BOOT_DS即为GDT的第三个表项。 此时GDT的表项可以到arch/x86/boot/pm.c查找，大概定义了Base为0大小为4G的段，这足以覆盖内核初始化32位代码执行的区域。有关GDT表及段选择相关知识，可以查阅&lt;<a href="https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>&gt;中Volume 3，CHAPTER 3 PROTECTED-MODE MEMORY MANAGEMENT一节。做一些寄存器内容的清理，就跳转到32位内核的起始地址执行。  </p>
<p>该起始地址，是protected_mode_jump函数的第一个参数-boot_params.hdr.code32_start。在我们的QEMU环境中这个值为<strong>0x100000</strong></p>
<blockquote>
<p>为什么是存储在eax寄存器呢，这里就需要了解<a href="https://uclibc.org/docs/psABI-x86_64.pdf" target="_blank" rel="noopener">System V Application Binary Interface AMD64</a>中有关<strong>calling convention</strong>的知识,Linux内核也是遵守System V ABI的。ABI指的是Application Binary Interface，根据程序运行的Arch不同而有不同的定义。</p>
</blockquote>
<h2 id="32位保护模式跳转到64位长模式"><a href="#32位保护模式跳转到64位长模式" class="headerlink" title="32位保护模式跳转到64位长模式"></a>32位保护模式跳转到64位长模式</h2><h3 id="startup-32"><a href="#startup-32" class="headerlink" title="startup_32"></a>startup_32</h3><p>_<br><strong>0x100000</strong>存放的是32位代码起始地址，具体布局可以参考链接脚本：<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/boot/compressed/vmlinux.lds.S" target="_blank" rel="noopener">vmlinux.lds</a></p>
<blockquote>
<p>链接脚本，即<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_chapter/ld_3.html" target="_blank" rel="noopener">Linker Script</a>，这是告诉链接器目标文件该如何链接的脚本。一般GCC编译我们不会指定链接脚本，这是因为其有默认的链接脚本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line">OUTPUT_ARCH(i386:x86-64)</span><br><span class="line">ENTRY(startup_64)</span><br><span class="line">#else</span><br><span class="line">OUTPUT_ARCH(i386)</span><br><span class="line">ENTRY(startup_32)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	/* Be careful parts of head_64.S assume startup_32 is at</span><br><span class="line">	 * address 0.</span><br><span class="line">	 */</span><br><span class="line">	. = 0;</span><br><span class="line">	.head.text : &#123;</span><br><span class="line">		_head = . ;</span><br><span class="line">		HEAD_TEXT</span><br><span class="line">		_ehead = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	.rodata..compressed : &#123;</span><br><span class="line">		*(.rodata..compressed)</span><br><span class="line">	&#125;</span><br><span class="line">	.text :	&#123;</span><br><span class="line">		_text = .; 	/* Text */</span><br><span class="line">		*(.text)</span><br><span class="line">		*(.text.*)</span><br><span class="line">		_etext = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		_rodata = . ;</span><br><span class="line">		*(.rodata)	 /* read-only data */</span><br><span class="line">		*(.rodata.*)</span><br><span class="line">		_erodata = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	.data :	&#123;</span><br><span class="line">		_data = . ;</span><br><span class="line">		*(.data)</span><br><span class="line">		*(.data.*)</span><br><span class="line">		*(.bss.efistub)</span><br><span class="line">		_edata = . ;</span><br><span class="line">	&#125;</span><br><span class="line">	. = ALIGN(L1_CACHE_BYTES);</span><br><span class="line">	.bss : &#123;</span><br><span class="line">		_bss = . ;</span><br><span class="line">		*(.bss)</span><br><span class="line">		*(.bss.*)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		. = ALIGN(8);	/* For convenience during zeroing */</span><br><span class="line">		_ebss = .;</span><br><span class="line">	&#125;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line">       . = ALIGN(PAGE_SIZE);</span><br><span class="line">       .pgtable : &#123;</span><br><span class="line">		_pgtable = . ;</span><br><span class="line">		*(.pgtable)</span><br><span class="line">		_epgtable = . ;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	. = ALIGN(PAGE_SIZE);	/* keep ZO size page aligned */</span><br><span class="line">	_end = .;</span><br></pre></td></tr></table></figure>

<p>经过ld链接、且qemu加载后，得到下图左侧的内存布局。从地址0x100000开始，首先是32位保护模式入口代码、解压缩代码等，之后摆放了压缩的内核。其后分别是解压后内核的代码段、只读数据段、数据段、未初始化数据段和32位代码页表。<br><img src="http://pic.l2h.site/Linux-Boot-Layout-2.png" alt="32位下内存分布" title="Figure 2. 32位下内存分布"></p>
<p>从链接脚本可以看出：32位代码的入口地址是<strong>startup_32</strong>。代码首先清中断，加载新GDT表，同时重置各段寄存器，建立堆栈。</p>
<blockquote>
<p>需要注意代码定义了一个宏<strong>rva</strong>,它的主要作用是为了计算段内相对地址，这样可以避免内核加载到不同位置时，同样的代码皆可执行。</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">#arch/x86/boot/compressed/head_64<span class="number">.</span>S</span><br><span class="line">#define rva(X) ((X) - startup_32)</span><br><span class="line"></span><br><span class="line"><span class="meta">	.code32</span></span><br><span class="line">SYM_FUNC_START(startup_32)</span><br><span class="line">	<span class="keyword">cld</span></span><br><span class="line">	<span class="keyword">cli</span></span><br><span class="line"></span><br><span class="line">	leal	(BP_scratch+<span class="number">4</span>)(%esi), %esp</span><br><span class="line">	<span class="keyword">call</span>	1f</span><br><span class="line"><span class="number">1</span>:	popl	%ebp</span><br><span class="line">	subl	$ rva(<span class="number">1b</span>), %ebp</span><br><span class="line"></span><br><span class="line">	leal	rva(gdt)(%ebp), %eax</span><br><span class="line">	movl	%eax, <span class="number">2</span>(%eax)</span><br><span class="line">	<span class="keyword">lgdt</span>	(%eax)</span><br><span class="line"></span><br><span class="line">	/* Load <span class="meta">segment</span> registers with our descriptors */</span><br><span class="line">	movl	$__BOOT_DS, %eax</span><br><span class="line">	movl	%eax, %ds</span><br><span class="line">	movl	%eax, %es</span><br><span class="line">	movl	%eax, %fs</span><br><span class="line">	movl	%eax, %gs</span><br><span class="line">	movl	%eax, %ss</span><br><span class="line"></span><br><span class="line">	leal	rva(boot_stack_end)(%ebp), %esp</span><br><span class="line"></span><br><span class="line">	pushl	$__KERNEL32_CS</span><br><span class="line">	leal	rva(1f)(%ebp), %eax</span><br><span class="line">	pushl	%eax</span><br><span class="line">	lretl</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	<span class="keyword">call</span>	startup32_load_idt</span><br><span class="line">	<span class="keyword">call</span>	verify_cpu</span><br><span class="line">	testl	%eax, %eax</span><br><span class="line">	<span class="keyword">jnz</span>	.Lno_longmode</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">	movl	%ebp, %ebx</span><br><span class="line">......</span><br><span class="line">	movl	BP_kernel_alignment(%esi), %eax</span><br><span class="line">	decl	%eax</span><br><span class="line">	addl	%eax, %ebx</span><br><span class="line">	notl	%eax</span><br><span class="line">	andl	%eax, %ebx</span><br><span class="line">	cmpl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line">	<span class="keyword">jae</span>	1f</span><br><span class="line">#endif</span><br><span class="line">	movl	$LOAD_PHYSICAL_ADDR, %ebx</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">	addl	BP_init_size(%esi), %ebx</span><br><span class="line">	subl	$ rva(_end), %ebx</span><br><span class="line"></span><br><span class="line">	/* Enable PAE mode */</span><br><span class="line">	movl	%cr4, %eax</span><br><span class="line">	orl	$X86_CR4_PAE, %eax</span><br><span class="line">	movl	%eax, %cr4</span><br></pre></td></tr></table></figure>

<p>加载IDT后，打开PAE模式。 然后会计算出将压缩内核摆放的位置放到ebx，用于原地(<strong>in-place</strong>)解压。上面代码中<strong>BP_kernel_alignment(%esi)</strong> 主要作用是从boot_param对应区域取出对应的值。我们再次打开<a href="https://www.kernel.org/doc/html/latest/x86/boot.html" target="_blank" rel="noopener">Linux/x86 Boot Protocol</a>和<a href="https://www.kernel.org/doc/html/v5.6/x86/zero-page.html" target="_blank" rel="noopener">Boot Protocol附属栏位</a>查看这些栏位的说明:</p>
<table>
<thead>
<tr>
<th>偏移/所占字节数</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0230/4</td>
<td>kernel_alignment</td>
<td>Physical addr alignment required for kernel</td>
</tr>
<tr>
<td>0260/4</td>
<td>init_size</td>
<td>Linear memory required during initialization</td>
</tr>
<tr>
<td>01E4/4</td>
<td>scratch</td>
<td>Scratch field for the kernel setup code</td>
</tr>
</tbody></table>
<p>其中init_size存放的是内核初始化、解压所需要的空间，这是根据内核压缩In-place解压预留足够的空间。这部分大小的计算可以参考内核源码<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/boot/header.S#L494" target="_blank" rel="noopener">arch/x86/boot/header.S</a>的说明（<strong><em>本人也还没吃透,待补充</em></strong>）。<br>紧接着内核为4GB大小的内存建立每页大小为2MB的内核页表（见Figure 2图右）并加载页表目录地址（<strong>pgtable</strong>）到CR3寄存器，并开启64位长模式。参考<a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank" rel="noopener">Wiki</a>:</p>
<blockquote>
<p>当处于长模式（Long mode）时，64位应用程序（或者是操作系统）可以使用64位指令和寄存器，而32位程序将以一种兼容子模式运行。</p>
</blockquote>
<p>4GB大小足以执行内核解压等动作。接着内核将64位地址<strong>startup_64</strong>压入栈，开启分页，并执行<em>lret</em>指令跳转到<strong>startup_64</strong>处执行。</p>
<blockquote>
<p>此处我们省略了SEV功能的检查，这是AMD CPU的特性。此处不做分析。</p>
</blockquote>
<h3 id="startup-64"><a href="#startup-64" class="headerlink" title="startup_64"></a>startup_64</h3><p><strong>startup_64</strong> 的开始同样会清中断，清理各段寄存器。同时计算压缩内核要移动到的地址，即LOAD_PHYSICAL_ADDR + INIT_SIZE - 压缩内核的长度(<strong>rva（_end）</strong>)。此处处理与<strong>startup_32</strong>相同</p>
<blockquote>
<p>可能大家会疑惑，为什么这段代码在startup_32做了，此处还要做一遍。主要原因代码内有描述，内核可能会被64位Loader直接加载并从<strong>startup_64</strong>处执行。</p>
</blockquote>
<p>接着内核加载空的IDT表，检查是否需要开启五级页表，并做对应处理。紧接着清除EFLAGS寄存器后，将压缩内核移动到In-place解压的位置(LOAD_PHYSICAL_ADDR + INIT_SIZE - 压缩内核的长度)，紧接着重新加载移动过位置的GDT表。之后跳转到移动后的 <strong>.Lrelocated</strong> 地址处开始执行。</p>
<h3 id="Lrelocated"><a href="#Lrelocated" class="headerlink" title=".Lrelocated"></a>.Lrelocated</h3><p><strong>.Lrelocated</strong> 代码最主要的作用有三个：</p>
<ul>
<li><strong>加载IDT</strong>：此时IDT的内容只开启了Page Fault Trap，对应的处理函数是<em>boot_page_fault</em>，其实现在<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/boot/compressed/ident_map_64.c#L324" target="_blank" rel="noopener">arch/x86/boot/compressed/ident_map_64.c</a>, 主要作用就是做一些基础检查后，为对应缺页的地址建立一致性映射。</li>
<li><strong>创建一致性映射</strong>： 主要为[_head, _end], bootparam 和 boot cmdline三个区域建立一致性映射。</li>
<li><strong>解压内核</strong>： 解压内核本文不做分析。提及一点就是如果开启了KASLR，解压内核前，会计算一个随机偏移生成内核真正的解压地址。</li>
</ul>
<p>解压完内核后跳转到加压后内核的入口地址,即arch/x86/kernel/head_64.S的<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/kernel/head_64.S#L44" target="_blank" rel="noopener">startup_64标号处</a></p>
<h2 id="内核解压后"><a href="#内核解压后" class="headerlink" title="内核解压后"></a>内核解压后</h2><p><strong>startup_64</strong> 代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">SYM_CODE_START_NOALIGN(startup_64)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line">	leaq	(__end_init_task - SIZEOF_PTREGS)(%rip), %rsp</span><br><span class="line"></span><br><span class="line">	leaq	_text(%rip), %rdi</span><br><span class="line">	pushq	%rsi</span><br><span class="line">	<span class="keyword">call</span>	startup_64_setup_env</span><br><span class="line">	popq	%rsi</span><br><span class="line"></span><br><span class="line">	pushq	$__KERNEL_CS</span><br><span class="line">	leaq	.Lon_kernel_cs(%rip), %rax</span><br><span class="line">	pushq	%rax</span><br><span class="line">	lretq</span><br><span class="line"></span><br><span class="line"><span class="symbol">.Lon_kernel_cs:</span></span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">	/* Sanitize <span class="meta">CPU</span> configuration */</span><br><span class="line">	<span class="keyword">call</span> verify_cpu</span><br><span class="line"></span><br><span class="line">	leaq	_text(%rip), %rdi</span><br><span class="line">	pushq	%rsi</span><br><span class="line">	<span class="keyword">call</span>	__startup_64</span><br><span class="line">	popq	%rsi</span><br><span class="line"></span><br><span class="line">	addq	$(early_top_pgt - __START_KERNEL_map), %rax</span><br><span class="line">	<span class="keyword">jmp</span> 1f</span><br><span class="line">SYM_CODE_END(startup_64)</span><br></pre></td></tr></table></figure>

<p>以上代码会配置栈之后，调用<strong>startup_64_setup_env</strong>配置Startup GDT和IDT。GDT表的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct desc_struct startup_gdt[GDT_ENTRIES] = &#123;</span><br><span class="line">	[GDT_ENTRY_KERNEL32_CS]         = GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_KERNEL_CS]           = GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),</span><br><span class="line">	[GDT_ENTRY_KERNEL_DS]           = GDT_ENTRY_INIT(0xc093, 0, 0xfffff),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Startup GDT中的段描述符,都是0地址开始的4GB大小。Startup IDT（也叫binrgup IDT）主要处理AMD 架构下VMM Communication异常，该异常与虚拟机有关。<br>之后内核继续执行到<strong>verify_cpu</strong>这个汇编函数，其定义在<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/kernel/verify_cpu.S#L34" target="_blank" rel="noopener">verify_cpu.S</a>,其主要是使用<em>cpuid</em>指令得到CPU对长模式和SSE指令集的支持状况。<br>检查完后，内核跳转执行 <strong>__startup_64</strong>,其主要作用是重新建立内核早期4级或者5级页表，此时需要考虑KASLR产生的随机偏移，因此我们可以看到此函数调用了多次<strong>fixup_pointer</strong>函数进行页表项纠正。<br>页表定义在<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/kernel/head_64.S#L472" target="_blank" rel="noopener">head_64.s</a>，如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">SYM_DATA_START_PTI_ALIGNED(early_top_pgt)</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">512</span>,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	.fill</span>	PTI_USER_PGD_FILL,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">SYM_DATA_END(early_top_pgt)</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(early_dynamic_pgts)</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">512</span>*EARLY_DYNAMIC_PAGE_TABLES,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">SYM_DATA_END(early_dynamic_pgts)</span><br><span class="line"></span><br><span class="line">SYM_DATA(early_recursion_flag, .long <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">	.data</span></span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_XEN_PV) || defined(CONFIG_PVH)</span><br><span class="line">SYM_DATA_START_PTI_ALIGNED(init_top_pgt)</span><br><span class="line"><span class="meta">	.quad</span>   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE_NOENC</span><br><span class="line"><span class="meta">	.org</span>    init_top_pgt + L4_PAGE_OFFSET*<span class="number">8</span>, <span class="number">0</span></span><br><span class="line"><span class="meta">	.quad</span>   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE_NOENC</span><br><span class="line"><span class="meta">	.org</span>    init_top_pgt + L4_START_KERNEL*<span class="number">8</span>, <span class="number">0</span></span><br><span class="line">	/* (<span class="number">2</span>^<span class="number">48</span>-(<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>))/(<span class="number">2</span>^<span class="number">39</span>) = <span class="number">511</span> */</span><br><span class="line"><span class="meta">	.quad</span>   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC</span><br><span class="line"><span class="meta">	.fill</span>	PTI_USER_PGD_FILL,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">SYM_DATA_END(init_top_pgt)</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level3_ident_pgt)</span><br><span class="line"><span class="meta">	.quad</span>	level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE_NOENC</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">511</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">SYM_DATA_END(level3_ident_pgt)</span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level2_ident_pgt)</span><br><span class="line">	PMDS(<span class="number">0</span>, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)</span><br><span class="line">SYM_DATA_END(level2_ident_pgt)</span><br><span class="line">#else</span><br><span class="line">SYM_DATA_START_PTI_ALIGNED(init_top_pgt)</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">512</span>,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	.fill</span>	PTI_USER_PGD_FILL,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">SYM_DATA_END(init_top_pgt)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_5LEVEL</span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level4_kernel_pgt)</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">511</span>,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	.quad</span>	level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC</span><br><span class="line">SYM_DATA_END(level4_kernel_pgt)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level3_kernel_pgt)</span><br><span class="line"><span class="meta">	.fill</span>	L3_START_KERNEL,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">	/* (<span class="number">2</span>^<span class="number">48</span>-(<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>)-((<span class="number">2</span>^<span class="number">39</span>)*<span class="number">511</span>))/(<span class="number">2</span>^<span class="number">30</span>) = <span class="number">510</span> */</span><br><span class="line"><span class="meta">	.quad</span>	level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE_NOENC</span><br><span class="line"><span class="meta">	.quad</span>	level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC</span><br><span class="line">SYM_DATA_END(level3_kernel_pgt)</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level2_kernel_pgt)</span><br><span class="line">	PMDS(<span class="number">0</span>, __PAGE_KERNEL_LARGE_EXEC, KERNEL_IMAGE_SIZE/PMD_SIZE)</span><br><span class="line">SYM_DATA_END(level2_kernel_pgt)</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level2_fixmap_pgt)</span><br><span class="line"><span class="meta">	.fill</span>	(<span class="number">512</span> - <span class="number">4</span> - FIXMAP_PMD_NUM),<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">	pgtno = <span class="number">0</span></span><br><span class="line"><span class="meta">	.rept</span> (FIXMAP_PMD_NUM)</span><br><span class="line"><span class="meta">	.quad</span> level1_fixmap_pgt + (pgtno &lt;&lt; PAGE_SHIFT) - __START_KERNEL_map \</span><br><span class="line">		+ _PAGE_TABLE_NOENC<span class="comment">;</span></span><br><span class="line">	pgtno = pgtno + <span class="number">1</span></span><br><span class="line"><span class="meta">	.endr</span></span><br><span class="line">	/* <span class="number">6</span> MB reserved space + a 2MB hole */</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">4</span>,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line">SYM_DATA_END(level2_fixmap_pgt)</span><br><span class="line"></span><br><span class="line">SYM_DATA_START_PAGE_ALIGNED(level1_fixmap_pgt)</span><br><span class="line"><span class="meta">	.rept</span> (FIXMAP_PMD_NUM)</span><br><span class="line"><span class="meta">	.fill</span>	<span class="number">512</span>,<span class="number">8</span>,<span class="number">0</span></span><br><span class="line"><span class="meta">	.endr</span></span><br><span class="line">SYM_DATA_END(level1_fixmap_pgt)</span><br></pre></td></tr></table></figure>

<p>比较难理解，我们用图翻译一下：<br><img src="http://pic.l2h.site/early_page_table.png" alt="内核早期页表" title="Figure 3. 内核早期页表"></p>
<p>图中为内核代码建立了早期映射，这样，就可以愉快地执行内核代码了。（当然，也并不一定是愉快执行内核代码，后面我们也会看到，内核需要注册IDT表项来处理Page Fault Trap）。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">/* Switch to new page-table */</span><br><span class="line"><span class="keyword">movq</span>	%rax, %cr3</span><br><span class="line"></span><br><span class="line">/* Ensure I am executing from virtual addresses */</span><br><span class="line"><span class="keyword">movq</span>	<span class="number">$1f</span>, %rax</span><br><span class="line">ANNOTATE_RETPOLINE_SAFE</span><br><span class="line"><span class="keyword">jmp</span>	*%rax</span><br></pre></td></tr></table></figure>

<p> <strong>__startup_64</strong>执行过后我们跳过一些SEV的处理，便开始使用新的内核页表。此后我们就跳转到__START_KERNEL_map开始的虚拟地址执行了。紧接着重新初始化GDT、设置段寄存器、建立初始化运营时的栈、建立IDT。这中间有一段代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">	/* Set <span class="meta">up</span> %gs.</span><br><span class="line">	 *</span><br><span class="line">	 * The base of %gs always points to fixed_percpu_data. If the</span><br><span class="line">	 * stack protector canary is enabled, it is located <span class="meta">at</span> %gs:<span class="number">40</span>.</span><br><span class="line">	 * Note that, on SMP, the boot <span class="meta">cpu</span> uses init data <span class="meta">section</span> until</span><br><span class="line">	 * the per <span class="meta">cpu</span> areas are set <span class="meta">up</span>.</span><br><span class="line">	 */</span><br><span class="line">	movl	$MSR_GS_BASE,%ecx</span><br><span class="line">	movl	initial_gs(%rip),%eax</span><br><span class="line">	movl	initial_gs+<span class="number">4</span>(%rip),%edx</span><br><span class="line">	<span class="keyword">wrmsr</span></span><br><span class="line">..................</span><br><span class="line">	pushq	$.Lafter_lret	# put return address on stack for unwinder</span><br><span class="line">	xorl	%ebp, %ebp	# clear frame pointer</span><br><span class="line">	<span class="keyword">movq</span>	initial_code(%rip), %rax</span><br><span class="line">	pushq	$__KERNEL_CS	# set correct <span class="built_in">cs</span></span><br><span class="line">	pushq	%rax		# target address <span class="keyword">in</span> negative space</span><br><span class="line">	lretq</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">SYM_DATA(initial_code,	.quad x86_64_start_kernel)</span><br></pre></td></tr></table></figure>

<p>它的作用是为多处理器系统保存per CPU变量的地址，保存到64-bit model specific register (MSR)。接着跳转到初始化c代码, 即<strong>x86_64_start_kernel</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文重点分析了从内核被Loader加载一直执行到C代码入口的内存管理。一些主要的步骤：</p>
<ul>
<li>开启保护模式</li>
<li>开启长模式</li>
<li>内核解压同时添加随机偏移</li>
<li>建立内核页表并跳转到虚拟地址执行</li>
</ul>
<p>系列后续我们将分析执行到C代码入口之后的处理</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 初始化C代码中的内存处理概览</title>
    <url>/p/94b22c5d.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第四篇</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
</blockquote>
</blockquote><h2 id="x86-64体系结构C代码处理"><a href="#x86-64体系结构C代码处理" class="headerlink" title="x86_64体系结构C代码处理"></a>x86_64体系结构C代码处理</h2><p>前文我们从汇编代码跳转到了<strong>x86_64_start_kernel</strong>，该函数代码如下：</p><a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">x86_64_start_kernel</span><span class="params">(<span class="keyword">char</span> * real_mode_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(MODULES_VADDR &lt; __START_KERNEL_map);</span><br><span class="line">	BUILD_BUG_ON(MODULES_VADDR - __START_KERNEL_map &lt; KERNEL_IMAGE_SIZE);</span><br><span class="line">	BUILD_BUG_ON(MODULES_LEN + KERNEL_IMAGE_SIZE &gt; <span class="number">2</span>*PUD_SIZE);</span><br><span class="line">	BUILD_BUG_ON((__START_KERNEL_map &amp; ~PMD_MASK) != <span class="number">0</span>);</span><br><span class="line">	BUILD_BUG_ON((MODULES_VADDR &amp; ~PMD_MASK) != <span class="number">0</span>);</span><br><span class="line">	BUILD_BUG_ON(!(MODULES_VADDR &gt; __START_KERNEL));</span><br><span class="line">	MAYBE_BUILD_BUG_ON(!(((MODULES_END - <span class="number">1</span>) &amp; PGDIR_MASK) ==</span><br><span class="line">				(__START_KERNEL &amp; PGDIR_MASK)));</span><br><span class="line">	BUILD_BUG_ON(__fix_to_virt(__end_of_fixed_addresses) &lt;= MODULES_END);</span><br><span class="line"></span><br><span class="line">	cr4_init_shadow();</span><br><span class="line">	reset_early_page_tables();</span><br><span class="line">	clear_bss();</span><br><span class="line">	clear_page(init_top_pgt);</span><br><span class="line"></span><br><span class="line">	sme_early_init();</span><br><span class="line">	kasan_early_init();</span><br><span class="line">	idt_setup_early_handler();</span><br><span class="line">	copy_bootdata(__va(real_mode_data));</span><br><span class="line"></span><br><span class="line">	load_ucode_bsp();</span><br><span class="line">	init_top_pgt[<span class="number">511</span>] = early_top_pgt[<span class="number">511</span>];</span><br><span class="line"></span><br><span class="line">	x86_64_start_reservations(real_mode_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先几个<em>BUILD_BUG_ON</em> 用于检查潜在的配置错误，分别检查的是：</p>
<ul>
<li>内核模块的虚拟地址位于内核映像之后。</li>
<li>内核模块+内核映像所占空间小于 2^31 (即2GB)</li>
<li>内核映像和内核模块的地址为2MB对齐</li>
<li>固定映射结束地址大于内核模块结束地址</li>
</ul>
<p>接着初始化CR4 Shadow，<a href="https://lore.kernel.org/lkml/808fa43ef6e24d1df47c2666174d997105b9582d.1413323611.git.luto@amacapital.net/" target="_blank" rel="noopener">内核Check-in List</a>给出其作用如下：</p>
<blockquote>
<p>Context switches and TLB flushes can change individual bits of CR4. CR4 reads take several cycles, so store a shadow copy of CR4 in a per-cpu variable. To avoid wasting a cache line, I added the CR4 shadow to cpu_tlbstate, which is already touched during context switches.</p>
</blockquote>
<p>也就是说，CR4读取是需要多个CPU时钟周期的，所以将CR4存在一个per-cpu变量内。CR4 Shadow放置于cpu_tlbstate，因为cpu_tlbstate在上下文切换时会被CPU加载到Cache，由此可以节省Cache line的使用。</p>
<p><strong>reset_early_page_tables</strong>将early_top_pgt清除并重新加载其为内核页表。<strong>clear_bss</strong>清理BSS和init_top_pgt<strong>sme_early_init</strong>是初始化内存加密相关。<br><strong>kasan_early_init</strong>作用是初始化KASAN功能，后续会再具体介绍KASAN，这里略过不表。<br><strong>idt_setup_early_handler</strong>作用是加载<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/kernel/head_64.S#L363" target="_blank" rel="noopener">IDT Handler</a>，其代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">SYM_CODE_START_LOCAL(early_idt_handler_common)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">cld</span></span><br><span class="line"></span><br><span class="line">	incl early_recursion_flag(%rip)</span><br><span class="line">	pushq %rsi				/* pt_regs-&gt;<span class="built_in">si</span> */</span><br><span class="line">	<span class="keyword">movq</span> <span class="number">8</span>(%rsp), %rsi			/* <span class="built_in">RSI</span> = vector number */</span><br><span class="line">	<span class="keyword">movq</span> %rdi, <span class="number">8</span>(%rsp)			/* pt_regs-&gt;<span class="built_in">di</span> = <span class="built_in">RDI</span> */</span><br><span class="line">	pushq %rdx				/* pt_regs-&gt;<span class="built_in">dx</span> */</span><br><span class="line">	pushq %rcx				/* pt_regs-&gt;<span class="built_in">cx</span> */</span><br><span class="line">	pushq %rax				/* pt_regs-&gt;<span class="built_in">ax</span> */</span><br><span class="line">	pushq %r8				/* pt_regs-&gt;<span class="built_in">r8</span> */</span><br><span class="line">	pushq %r9				/* pt_regs-&gt;<span class="built_in">r9</span> */</span><br><span class="line">	pushq %r10				/* pt_regs-&gt;<span class="built_in">r10</span> */</span><br><span class="line">	pushq %r11				/* pt_regs-&gt;<span class="built_in">r11</span> */</span><br><span class="line">	pushq %rbx				/* pt_regs-&gt;<span class="built_in">bx</span> */</span><br><span class="line">	pushq %rbp				/* pt_regs-&gt;<span class="built_in">bp</span> */</span><br><span class="line">	pushq %r12				/* pt_regs-&gt;<span class="built_in">r12</span> */</span><br><span class="line">	pushq %r13				/* pt_regs-&gt;<span class="built_in">r13</span> */</span><br><span class="line">	pushq %r14				/* pt_regs-&gt;<span class="built_in">r14</span> */</span><br><span class="line">	pushq %r15				/* pt_regs-&gt;<span class="built_in">r15</span> */</span><br><span class="line">	UNWIND_HINT_REGS</span><br><span class="line"></span><br><span class="line">	<span class="keyword">movq</span> %rsp,%rdi		/* <span class="built_in">RDI</span> = pt_regs<span class="comment">; RSI is already trapnr */</span></span><br><span class="line">	<span class="keyword">call</span> do_early_exception</span><br><span class="line"></span><br><span class="line">	decl early_recursion_flag(%rip)</span><br><span class="line">	<span class="keyword">jmp</span> restore_regs_and_return_to_kernel</span><br><span class="line">SYM_CODE_END(early_idt_handler_common)</span><br></pre></td></tr></table></figure>

<p>上述代码主要作用是寄存器状态保存，同时执行<strong>do_early_exception</strong>。<br><strong>copy_bootdata</strong>的主要作用是检查初始化参数，并将它们复制<em>boot_params</em>和<em>boot_command_line</em>内。同时将early_top_pgt页表的第512项赋值给init_top_pgt对应项。<br>最后<strong>x86_64_start_reservations</strong>执行一些特定平台相关的”quirks”后，开始执行<strong>start_kernel</strong>。</p>
<h2 id="start-kernel"><a href="#start-kernel" class="headerlink" title="start_kernel"></a>start_kernel</h2><p><strong>start_kernel</strong>执行所有内核初始化代码。本文仅分析与内存管理相关的步骤如下图：<br><img src="http://pic.l2h.site/start_kernel.png" alt="内核初始化的内存处理" title="Figure 1. 内核初始化的内存处理"></p>
<ul>
<li><strong>set_task_stack_end_magic</strong> 为内核栈底设置Magic Number，用于栈溢出的检查。</li>
<li><strong>page_address_init</strong> 初始化<em>page_address_htable</em>链表</li>
<li><strong>setup_arch</strong>为体系结构相关的初始化代码。X64系统对应的setup_arch定义在<a href="https://elixir.bootlin.com/linux/v5.13.9/source/arch/x86/kernel/setup.c#L790" target="_blank" rel="noopener">arch/x86/kernel/setup.c</a><ul>
<li><strong>early_ioremap_init</strong> 初始化数组 <strong><em>slot_virt</em></strong> 用于保存虚拟地址和外设物理地址的早期固定映射，其定义在<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/fixmap.h#L127" target="_blank" rel="noopener">fixmap.h</a>。</li>
<li><strong>setup_olpc_ofw_pgd</strong> 为“<a href="https://en.wikipedia.org/wiki/One_Laptop_per_Child" target="_blank" rel="noopener">One Laptop Per Child</a>”公益项目相关设备初始化PGD。</li>
<li><strong>e820__memory_setup</strong> 执行 <strong>e820__memory_setup_default</strong> ，主要作用是从 <a href="https://en.wikipedia.org/wiki/E820" target="_blank" rel="noopener">E820</a>获取硬件内存布局，保存在全局变量<em>e820_table</em>。代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> <span class="title">e820_table_init</span>		__<span class="title">initdata</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> <span class="title">e820_table_kexec_init</span>		__<span class="title">initdata</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> <span class="title">e820_table_firmware_init</span>	__<span class="title">initdata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> *<span class="title">e820_table</span> __<span class="title">refdata</span>			= &amp;<span class="title">e820_table_init</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> *<span class="title">e820_table_kexec</span> __<span class="title">refdata</span>		= &amp;<span class="title">e820_table_kexec_init</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820_table</span> *<span class="title">e820_table_firmware</span> __<span class="title">refdata</span>	= &amp;<span class="title">e820_table_firmware_init</span>;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意 <strong>initdata和</strong>refdata修饰作用在内核代码有说明,其中<strong>init的作用是为了标记初始化使用的数据以便内核初始化结束后释放对应的内存。而</strong>refdata的用于引用__initdata标记的数据。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __init		__section(<span class="meta-string">".init.text"</span>) __cold  __latent_entropy __noinitretpoline __nocfi</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __initdata	__section(<span class="meta-string">".init.data"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __initconst	__section(<span class="meta-string">".init.rodata"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __exitdata	__section(<span class="meta-string">".exit.data"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __exit_call	__used __section(<span class="meta-string">".exitcall.exit"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ref            __section(<span class="meta-string">".ref.text"</span>) noinline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __refdata        __section(<span class="meta-string">".ref.data"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __refconst       __section(<span class="meta-string">".ref.rodata"</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>early_reserve_memory</strong> 作用是将已占用的内存区域标记为不可用。这样后续不允许被memblock或者伙伴系统分配器再分配。</p>
<ul>
<li>[_text, __end_of_kernel_reserve]</li>
<li>[0,64K]</li>
<li>setup_data: [hdr.setup_data, sizeof(setup_data)+hdr.setup_data]</li>
<li>initrd</li>
<li>ibft(<a href="https://docs.vmware.com/en/VMware-vSphere/6.7/com.vmware.vsphere.storage.doc/GUID-03E73408-076A-4A7F-9732-3BB816A16CA1.html" target="_blank" rel="noopener">iSCSI Boot Format Table</a>) 区域(如果有的话)</li>
<li>BIOS区域: [BIOS Start, 0x1000000]</li>
<li>etc.</li>
</ul>
</li>
<li><p><strong>memblock_set_bottom_up</strong> 标记memblock内存分配是从低地址到高地址</p>
<blockquote>
<p><a href="https://lwn.net/Articles/761215/" target="_blank" rel="noopener">memblock</a>是系统初始化初期，伙伴系统接管前的分配器，它取代了内核早期的bootmem分配器。</p>
</blockquote>
</li>
<li><p><strong>e820__reserve_setup_data</strong> 将Boot Loader扩展的数据区标记为内核保留区域，并为其分配内存映射。</p>
</li>
<li><p><strong>e820__finish_early_params</strong> 更新e820表。用户可以通过Loader传入内核CMD line来自定义内存区域映射。下图是在QEMU中E820扫描到的内存映射。<br><img src="/images/posts/20210921/e820_memory_mapping.png" alt="E820物理内存映射" title="Figure 2. E820物理内存映射"></p>
</li>
<li><p><strong>probe_roms</strong> 为ROM的分配IO资源</p>
</li>
<li><p><strong>insert_resource</strong> 将code、rodata、data和bss插入IOMEM资源</p>
</li>
<li><p><strong>e820_add_kernel_range</strong> 将内核_text 到 _end区域加入到e820表。</p>
</li>
<li><p><strong>trim_bios_range</strong> 处理一些BIOS识别内存的特殊情况</p>
<ul>
<li>0到4KB区域没有被BIOS加入到e820中，我们将这段区域加入到e820保留区域。</li>
<li>将BIOS区域中BIOS_BEGIN到BIOS_END(640Kb -&gt; 1Mb) 从e820表中删除。这是因为有些BIOS会将这段区域识别为物理内存（但起始不是）。</li>
</ul>
</li>
<li><p><strong>early_gart_iommu_check</strong> 针对早期的AMD处理器中基于<a href="https://en.wikipedia.org/wiki/Graphics_address_remapping_table" target="_blank" rel="noopener">GART IOMMU</a>的支持。</p>
</li>
<li><p><strong>e820__end_of_ram_pfn</strong> 从e820获取最大物理页帧号</p>
</li>
<li><p><strong>init_cache_modes</strong> <font color="red">待确定</font></p>
</li>
<li><p><strong>kernel_randomize_memory</strong> 与KASLR相关，后续介绍，此处不表</p>
</li>
<li><p><strong>early_alloc_pgt_buf</strong> 为初始化过程中分配PGT预留堆空间</p>
</li>
<li><p><strong>reserve_brk</strong> 在Boot分配器Reserve堆空间</p>
</li>
<li><p><strong>e820__memblock_setup</strong> 将e820内存分布表的数据读出，并填写到Boot分配器管理</p>
<blockquote>
<p>关于memblock分配器memblock，系列后续文章专门介绍</p>
</blockquote>
</li>
<li><p><strong>e820__memblock_alloc_reserved_mpc_new</strong> 从Memblock为<a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification" target="_blank" rel="noopener">MPC Table</a>分配内存。</p>
</li>
<li><p><strong>reserve_real_mode</strong> 从Memblock为实模式的[0, 1MB]分配内存。</p>
</li>
<li><p><strong>init_mem_mapping</strong>  <font color="red">待确定</font></p>
</li>
<li><p><strong>memblock_set_current_limit</strong> 设置memblock.current_limit为membelcok管理的最大页帧号</p>
</li>
<li><p><strong>initmem_init</strong> 初始化NUMA（如果开启对应Kconfig的话），为memblock的现有区域分配NUMA节点ID号</p>
</li>
<li><p><strong>dma_contiguous_reserve</strong> 为DMA预留连续内存</p>
</li>
<li><p><strong>reserve_crashkernel</strong> 为kernel crash分配内存</p>
</li>
<li><p><strong>memblock_find_dma_reserve</strong>  计算DMA区域的大小</p>
</li>
<li><p><strong>x86_init.paging.pagetable_init</strong> 调用 <em>native_pagetable_init</em> 来初始化paging <font color="red">待确定</font></p>
</li>
<li><p><strong>kasan_init</strong> 初始化KASAN</p>
</li>
<li><p><strong>sync_initial_page_table</strong> <font color="red">待确定</font></p>
</li>
<li><p><strong>e820__reserve_resources</strong> 为e820表项分配IO resource （reserve标记的表项除外） </p>
</li>
<li><p><strong>x86_init.resources.reserve_resources</strong> 使用reserve_standard_io_resources 为下面硬件端口分配ioport resource</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">standard_io_resources</span>[] = &#123;</span></span><br><span class="line">	&#123; .name = <span class="string">"dma1"</span>, .start = <span class="number">0x00</span>, .<span class="built_in">end</span> = <span class="number">0x1f</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"pic1"</span>, .start = <span class="number">0x20</span>, .<span class="built_in">end</span> = <span class="number">0x21</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"timer0"</span>, .start = <span class="number">0x40</span>, .<span class="built_in">end</span> = <span class="number">0x43</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"timer1"</span>, .start = <span class="number">0x50</span>, .<span class="built_in">end</span> = <span class="number">0x53</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"keyboard"</span>, .start = <span class="number">0x60</span>, .<span class="built_in">end</span> = <span class="number">0x60</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"keyboard"</span>, .start = <span class="number">0x64</span>, .<span class="built_in">end</span> = <span class="number">0x64</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"dma page reg"</span>, .start = <span class="number">0x80</span>, .<span class="built_in">end</span> = <span class="number">0x8f</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"pic2"</span>, .start = <span class="number">0xa0</span>, .<span class="built_in">end</span> = <span class="number">0xa1</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"dma2"</span>, .start = <span class="number">0xc0</span>, .<span class="built_in">end</span> = <span class="number">0xdf</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;,</span><br><span class="line">	&#123; .name = <span class="string">"fpu"</span>, .start = <span class="number">0xf0</span>, .<span class="built_in">end</span> = <span class="number">0xff</span>,</span><br><span class="line">		.flags = IORESOURCE_BUSY | IORESOURCE_IO &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>e820__setup_pci_gap</strong> 在0到4GB找到空闲的内存区域，用于PCI设备的IO映射。</li>
<li><strong>build_all_zonelists</strong> 将所有内存节点的区域加入到对应的zonelist，可以参考<a href="1dc6adc2">数据结构</a>的介绍</li>
<li><strong>page_alloc_init</strong> <font color="red">待确定</font></li>
<li><strong>mm_init</strong> 为内存管理初始化最核心的部分，由以下部分组成<ul>
<li><strong>page_ext_init_flatmem</strong></li>
<li><strong>init_mem_debugging_and_hardening</strong></li>
<li><strong>kfence_alloc_pool</strong></li>
<li><strong>report_meminit</strong></li>
<li><strong>stack_depot_init</strong> </li>
<li><strong>mem_init</strong> 回收memblock分配的内存（Reserve的除外），接着用<strong>mem_init_print_info</strong>打印内存信息</li>
<li><strong>kmem_cache_init</strong> 初始化SLAB分配器</li>
<li><strong>kmemleak_init</strong> 初始化Kmemleak</li>
<li><strong>pgtable_init</strong> 为启动后各进程的页表分配建立SLAB</li>
<li><strong>debug_objects_mem_init</strong> 为debugobject功能分配SLAB内存</li>
<li><strong>vmalloc_init</strong> </li>
</ul>
</li>
<li><strong>kmem_cache_init_late</strong> 为SLAB分配器的后续初始化。如果编译时采用的是SLUB，此处无操作。</li>
<li><strong>numa_policy_init</strong></li>
<li><strong>anon_vma_init</strong></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是对初始化C代码中内存管理的概览，并没有介绍到每个子部分的细节，后续将会在专门的章节进行具体介绍。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 内核职责</title>
    <url>/p/61304bbb.html</url>
    <content><![CDATA[<blockquote>
<p>本系列是本人对Linux内核内存管理的学习持续总结。</p>
</blockquote><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>内存系统是操作系统最复杂的子系统之一，内存管理穿插着内核的方方面面。做驱动开发有2年多了，之前写过Linux内核<a href="d209b5b5.html">内存管理的博客</a>。现在回头看，之前的理解并不到位，也不完整。希望用本系列对Linux内核内存管理的知识做重新梳理，增强自己的理解，也能给对这个复杂功能一头雾水的朋友提供一些思路。  </p><a id="more"></a>

<h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>为了阐述方便，本文（系列）会基于Intel 64位平台做讨论。所涉及内核代码主要位于如下目录：</p>
<ul>
<li>mm</li>
<li>arch/x86</li>
</ul>
<h2 id="内核职责"><a href="#内核职责" class="headerlink" title="内核职责"></a>内核职责</h2><p>内存是系统得以运行的最基本保证。为了将内存进行有效管理，内核需要做如下考虑：</p>
<h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><ul>
<li><strong>非一致性内存访问（NUMA）</strong>： 多处理器系统中有多个内存节点。每个处理器和每个内存节点距离并不相同，因此访问不同内存节点的距离和开销并不相同。OS需要考虑如何有效管理处理器对内存的访问，使该处理器更多地距其更近的处理器（一般称为Local）节点。 当然实际内核NUMA内存管理策略并非所述这么简单，Linux有一系列配置NUMA访问策略的方法，详见<a href="https://elixir.bootlin.com/linux/latest/source/Documentation/admin-guide/mm/numa_memory_policy.rst" target="_blank" rel="noopener">NUMA Policy Guide</a>。</li>
<li><strong>内存热拔插</strong>: 顾名思义,系统运行时内存热拔插的处理。</li>
</ul>
<h3 id="内核物理地址的规划"><a href="#内核物理地址的规划" class="headerlink" title="内核物理地址的规划"></a>内核物理地址的规划</h3><p>在Boot Loader加载内核后，如何分别摆放16 Bit, 32 Bit代码区域。压缩内核，以及如何解压内核，解压还要考虑KASLR（内核地址随机化）等因素。同时，每个启动阶段使用的堆和栈如何划分。</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><ul>
<li><strong>内核初始化前</strong>：可大致分为32 Bit页表映射，64 Bit内存页表映射（解压内核前），64 Bit内存页表映射（解压内核后）</li>
<li><strong>内核初始化后</strong>: 各个进程独立页表的控制，同时需要保证内核空间态地址对所有进程是一致的。同时需要考虑用户态和内核态对不同内存区域访问权限的控制。</li>
</ul>
<h3 id="外设访问"><a href="#外设访问" class="headerlink" title="外设访问"></a>外设访问</h3><p>通过虚拟地址访问外设IO端口或者MMIO端口，这需要内核为其建立对应的页表项，同时为了保证特定IO区域只能有一个主体来管理，内核需要以树状结构来管理IO区域。<br>同时，外设要访问的内存空间，需要考虑CPU和外设访问内存一致性问题（DMA一致性）。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分配和释放是操作系统内最为频繁的操作。保证内存分配和释放的同时，也需要考虑避免系统内存的碎片化，避免系统运行到一段时间后，程序需要一块大内存的的时候无法分配到。其中：</p>
<ul>
<li><strong>伙伴系统(Buddy System)</strong>: 按页管理内存分配和释放</li>
<li><strong>SLAB系列</strong>: 页内小内存分配的管理和释放</li>
</ul>
<h3 id="内存回收和换页"><a href="#内存回收和换页" class="headerlink" title="内存回收和换页"></a>内存回收和换页</h3><p>当系统物理内存紧张时，系统会将一些内存换出到硬盘上。而当系统访问该内存页产生Page Fault时，操作系统需要负责将该内存页的内容换回到内存上。</p>
<h2 id="内存使用检测和Debug"><a href="#内存使用检测和Debug" class="headerlink" title="内存使用检测和Debug"></a>内存使用检测和Debug</h2><p>除了上述职责，内核也需要提供方法对内存使用进行检测和调试。例：  </p>
<ul>
<li>程序可能会对内存做不当使用，当这种不当使用发生在内核态，往往会产生严重的后果。因此Linux提供了KASAN、Kmemleak等工具方便开发人员进行检查。</li>
<li>同时内核内存管理子系统也提供了一系列接口和方法供系统运维管理人员对内存使用进行调试和检测。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上为本人对内核内存管理功能的梳理。因为内核内存管理功能复杂，以上理解并不一定准确，因此本文也需要持续更新。系列文章后续也将会对本文提及的内容进行具体的分析和介绍。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - Memblock和Buddy System(1)</title>
    <url>/p/20210923linuxmm4.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第四篇</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
</blockquote>
</blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>参考<a href="https://www.kernel.org/doc/html/latest/core-api/boot-time-mm.html" target="_blank" rel="noopener">内核文档</a>，系统初始化早期是不能使用我们常用的 <em>kmalloc</em> ，<em>vmalloc</em> 等函数，这是因为此时对应的功能还没初始化好。</p><a id="more"></a>

<p>尽管如此，早期初始化仍然需要分配内存。因此早期内核提供了基于bitmap的Bootmem分配器，后续逐渐演进成了现在的Memblock。<br>Memblock或者早期的Bootmem并不能适应系统运行时的各种复杂场景（多线程、碎片等）。因此在内核启动到一定阶段后，内存管理的工作会交由伙伴系统(Buddy System)接管。  </p>
<blockquote>
<p>当然也并非是仅由伙伴系统管理。除了伙伴系统来以页为单位进行内存分配，还会有SLAB系统的某种（一般是SLUB）来实现对小内存分配的管理。</p>
</blockquote>
<h2 id="Memblock"><a href="#Memblock" class="headerlink" title="Memblock"></a>Memblock</h2><p>Memblock将系统中的内存分为一系列不同类型的连续区域。主要有以下几个类型：</p>
<ul>
<li><strong>memory</strong>：用于描述当前内核可用的物理内存。</li>
<li><strong>reserved</strong>: 用于描述不可用内存（已分配）。</li>
<li><strong>physmem</strong>：特殊体系结构才有，此处不表。</li>
</ul>
<p>Memblock使用以上概念对内核启动早期内存分配进行管理。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Memblock的内存主要数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> &#123;</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> base;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">enum</span> memblock_flags flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> nid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memblock_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cnt;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">max</span>;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> total_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">regions</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memblock</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> bottom_up;  <span class="comment">/* is bottom up direction? */</span></span><br><span class="line">	<span class="keyword">phys_addr_t</span> current_limit;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_type</span> <span class="title">memory</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_type</span> <span class="title">reserved</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>memblock_region</strong>: 代表一段物理内存区域。<ul>
<li><strong>base</strong>：表示区域物理起始物理地址</li>
<li><strong>size</strong>：表示区域大小</li>
<li><strong>flags</strong>：区域标记，主要有（HOTPLUG, MIRROR, NOMAP），分别表示区域是否是热插拔，镜像区域和是否加入到内核直接映射区。</li>
<li><strong>nid</strong>: 如果开启了NUMA（Non Unified Memory Access）</li>
</ul>
</li>
<li><strong>memblock_type</strong>: 表示某种内存类型的集合。如<a href="#Memblock">前文</a>所述，目前主要有Memory和Reserved。<ul>
<li><strong>cnt</strong>：表示该memblock_type的个数</li>
<li><strong>max</strong>: 此type内区域的数量（即<strong>regions</strong>链表的元素个数）</li>
<li><strong>total_size</strong>: 此类内存区域内存的总大小</li>
<li><strong>regions</strong>：所有此类区域内存的链表</li>
<li><strong>name</strong>: 该类型的符号名</li>
</ul>
</li>
<li><strong>memblock</strong>: 管理整个Memblock的数据结构<ul>
<li><strong>bottom_up</strong>: 内存分配的方向，是否从底向上</li>
<li><strong>current_limit</strong>：Memblock分配器管理的物理内存地址的上限</li>
<li><strong>memory</strong>: memory类型</li>
<li><strong>reserved</strong>: memory类型</li>
</ul>
</li>
</ul>
<p>一张图说明以上结构的关系：</p>
<h3 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h3><p>Memblock分配和释放函数主要有以下：</p>
<ul>
<li><strong>memblock_alloc</strong>: 分配内存，主要有(memblock_alloc_range_nid, memblock_alloc_raw, memblock_alloc_from等)</li>
<li><strong>memblock_add</strong>: 分配内存区域</li>
<li><strong>memblock_add_node</strong>: 在指定NUMA上分配内存区域</li>
<li><strong>memblock_add_range</strong>: 在指定NUMA区域内分配指定类型和FLAG标记的内存区域</li>
<li><strong>memblock_remove</strong>: 删除一个内存区域</li>
<li><strong>memblock_remove_range</strong>: 删除一个指定类型的内存区域</li>
<li><strong>memblock_remove_region</strong>: 删除指定内存区域</li>
<li><strong>memblock_free</strong>: 删除内存区域， 主要有(memblock_free_early, memblock_free_early_nid等)</li>
<li><strong>memblock_reserve</strong>: 将指定区域设定为保留区域</li>
</ul>
<p>以上API名称很像，但其实最终只是对其中某几个API的封装。</p>
<h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>从如下alloc系函数调用关系可以看到，最终调用到memblock_add_range。</p>
<p><img src="/images/posts/20210923/Memblock_Alloc.png" alt="Memblock分配函数" title="Figure 1. Memblock分配函数调用"></p>
<p>从不同分支进到分配函数memblock_add_range，差异仅在与分配时选取的NUMA Node ID、标记（Flag）、类型（Memory还是Reserved）等参数的不同。其具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init_memblock <span class="title">memblock_add_range</span><span class="params">(struct memblock_type *type,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">phys_addr_t</span> base, <span class="keyword">phys_addr_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">int</span> nid, <span class="keyword">enum</span> memblock_flags flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> insert = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> obase = base;</span><br><span class="line">	<span class="keyword">phys_addr_t</span> <span class="built_in">end</span> = base + memblock_cap_size(base, &amp;<span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">int</span> idx, nr_new;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memblock_region</span> *<span class="title">rgn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">size</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* special case for empty array */</span></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;regions[<span class="number">0</span>].<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		WARN_ON(type-&gt;cnt != <span class="number">1</span> || type-&gt;total_size);</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].base = base;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].<span class="built_in">size</span> = <span class="built_in">size</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].flags = flags;</span><br><span class="line">		memblock_set_region_node(&amp;type-&gt;regions[<span class="number">0</span>], nid);</span><br><span class="line">		type-&gt;total_size = <span class="built_in">size</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following is executed twice.  Once with %false @insert and</span></span><br><span class="line"><span class="comment">	 * then with %true.  The first counts the number of regions needed</span></span><br><span class="line"><span class="comment">	 * to accommodate the new area.  The second actually inserts them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base = obase;</span><br><span class="line">	nr_new = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	for_each_memblock_type(idx, type, rgn) &#123;</span><br><span class="line">		<span class="keyword">phys_addr_t</span> rbase = rgn-&gt;base;</span><br><span class="line">		<span class="keyword">phys_addr_t</span> rend = rbase + rgn-&gt;<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rbase &gt;= <span class="built_in">end</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (rend &lt;= base)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * @rgn overlaps.  If it separates the lower part of new</span></span><br><span class="line"><span class="comment">		 * area, insert that portion.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (rbase &gt; base) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">			WARN_ON(nid != memblock_get_region_node(rgn));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			WARN_ON(flags != rgn-&gt;flags);</span><br><span class="line">			nr_new++;</span><br><span class="line">			<span class="keyword">if</span> (insert)</span><br><span class="line">				memblock_insert_region(type, idx++, base,</span><br><span class="line">						       rbase - base, nid,</span><br><span class="line">						       flags);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* area below @rend is dealt with, forget about it */</span></span><br><span class="line">		base = <span class="built_in">min</span>(rend, <span class="built_in">end</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* insert the remaining portion */</span></span><br><span class="line">	<span class="keyword">if</span> (base &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line">		nr_new++;</span><br><span class="line">		<span class="keyword">if</span> (insert)</span><br><span class="line">			memblock_insert_region(type, idx, base, <span class="built_in">end</span> - base,</span><br><span class="line">					       nid, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_new)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this was the first round, resize array and repeat for actual</span></span><br><span class="line"><span class="comment">	 * insertions; otherwise, merge and return.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!insert) &#123;</span><br><span class="line">		<span class="keyword">while</span> (type-&gt;cnt + nr_new &gt; type-&gt;<span class="built_in">max</span>)</span><br><span class="line">			<span class="keyword">if</span> (memblock_double_array(type, obase, <span class="built_in">size</span>) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		insert = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		memblock_merge_regions(type);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码虽长，其实比较容易理解：</p>
<ul>
<li>首先如果对应类型类型还没有任何内存区域，便直接在对应分配所要求的的内存区域。</li>
<li>如果该类型区域非空，就需要遍历所有内存区域，确定待加入区域是否与已存在区域重合。据此会有三种处理：<ul>
<li>如果待加入区域与现存区域无重叠，则直接添加此区域</li>
<li>如果待加入区域与现存区域有重叠且并未被现存区域完整包含，则将待加入区域与现存区域进行合并</li>
<li>如果待加入区域被现存区域完全包含，则不用重新添加该区域</li>
</ul>
</li>
</ul>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>另外可以从如下free系函数调用关系的简图看到，memblock_free*最终调用到memblock_remove_region和memblock_free_pages。</p>
<p><img src="/images/posts/20210923/Memblock_Free.png" alt="Memblock Free APIs" title="Figure 2. Memblock Free函数调用"></p>
<p>memblock_remove_region的主要作用是移除对应内存区，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init_memblock <span class="title">memblock_remove_region</span><span class="params">(struct memblock_type *type, <span class="keyword">unsigned</span> <span class="keyword">long</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	type-&gt;total_size -= type-&gt;regions[r].<span class="built_in">size</span>;</span><br><span class="line">	memmove(&amp;type-&gt;regions[r], &amp;type-&gt;regions[r + <span class="number">1</span>],</span><br><span class="line">		(type-&gt;cnt - (r + <span class="number">1</span>)) * <span class="keyword">sizeof</span>(type-&gt;regions[r]));</span><br><span class="line">	type-&gt;cnt--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Special case for empty arrays */</span></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;cnt == <span class="number">0</span>) &#123;</span><br><span class="line">		WARN_ON(type-&gt;total_size != <span class="number">0</span>);</span><br><span class="line">		type-&gt;cnt = <span class="number">1</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].base = <span class="number">0</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].<span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">		type-&gt;regions[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">		memblock_set_region_node(&amp;type-&gt;regions[<span class="number">0</span>], MAX_NUMNODES);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的主要作用就是将内存区域从对应类型的区域数组中移除，修改对应类型区域的长度，同时将该区域索引之后的区域依次向前移动一位。</p>
<p>memblock_free_pages的作用则是将对应页释放会给Buddy System：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">memblock_free_pages</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (early_page_uninitialised(pfn))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	__free_pages_core(page, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="物理内存模型"><a href="#物理内存模型" class="headerlink" title="物理内存模型"></a>物理内存模型</h2><p>在讲解伙伴系统之前，我们先讲解物理内存模型（<a href="https://www.kernel.org/doc/html/latest/vm/memory-model.html" target="_blank" rel="noopener">Physical Memory Model</a>），这是向伙伴系统过度的基础。简单一点讲，伙伴系统是按页对内存进行管理的，物理内存模型解决的是：</p>
<ul>
<li>页对应的描述符(<em>struct page</em>)如何与对应物理页匹配。</li>
<li>通过物理页帧号如何快速找到对应的页描述符。</li>
<li>处理内存地址不连续 （存在多个内存节点，或者同个内存节点内有空洞造成的不连续）</li>
</ul>
<p>Linux系统的物理内存管理模型有三种配置，通过KConfig选择：</p>
<ul>
<li>Flat：平坦内存模型是最简单的内存管理模型，适用于地址连续没有内存空洞的系统，也是Linux最早采用的内存模型。因为被管理的内存地址连续，因此可以方便地使用数组来管理。数组下标也可以直接和页帧号进行关联。</li>
<li>Discontiguous：随着处理器系统发展，有了非均匀内存访问模型（<a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%9D%87%E5%8C%80%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">NUMA</a>）。为了处理这种需求，内核就有了Discontiguous内存管理模型。这种管理模型因为在对页帧和对应页描述符映射不够有效，且不能很好适应一些嵌入式系统的需求，逐渐被Sparse模型替代。</li>
</ul>
<blockquote>
<p>也可以称为“非一致性内存访问”，但一致性内存往往会跟DMA一致性，Cache一致性等概念混淆。</p>
</blockquote>
<ul>
<li>Sparse：目前最常用且适配性最强的内存模型，它还支持内存的热拔插。管理方式如下：</li>
</ul>
<p><img src="/images/posts/20210923/Sparse_Memory_Model.PNG" alt="Sparse Memory Model" title="Figure 3. Sparse内存模型"></p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>从上图看出，mem_section的数据结构比较简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">	____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is, logically, a pointer to an array of struct</span></span><br><span class="line"><span class="comment">	 * pages.  However, it is stored with some other magic.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::sparse_init_one_section())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Additionally during early boot we encode node id of</span></span><br><span class="line"><span class="comment">	 * the location of the section here to guide allocation.</span></span><br><span class="line"><span class="comment">	 * (see sparse.c::memory_present())</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Making it a UL at least makes someone do a cast</span></span><br><span class="line"><span class="comment">	 * before using it wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> section_mem_map;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_section_usage</span> *<span class="title">usage</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">page_ext</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pad;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>section_mem_map</em>: 存的是指向对应struct page表的指针，以及一些标记性栏位（如该section是否是存在的）</li>
<li><em>usage</em>:</li>
<li><em>page_ext</em>:</li>
<li><em>pad</em>:</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Sparse的每个mem_section管理一块连续的内存区域，它由多个物理页组成。mem_section和这些内存区域的映射关系在<strong>sparse_init</strong>函数建立。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">sparse_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pnum_end, pnum_begin, map_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> nid_begin;</span><br><span class="line"></span><br><span class="line">	memblocks_present();</span><br><span class="line"></span><br><span class="line">	pnum_begin = first_present_section_nr();</span><br><span class="line">	nid_begin = sparse_early_nid(__nr_to_section(pnum_begin));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup pageblock_order for HUGETLB_PAGE_SIZE_VARIABLE */</span></span><br><span class="line">	set_pageblock_order();</span><br><span class="line"></span><br><span class="line">	for_each_present_section_nr(pnum_begin + <span class="number">1</span>, pnum_end) &#123;</span><br><span class="line">		<span class="keyword">int</span> nid = sparse_early_nid(__nr_to_section(pnum_end));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nid == nid_begin) &#123;</span><br><span class="line">			map_count++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Init node with sections in range [pnum_begin, pnum_end) */</span></span><br><span class="line">		sparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);</span><br><span class="line">		nid_begin = nid;</span><br><span class="line">		pnum_begin = pnum_end;</span><br><span class="line">		map_count = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* cover the last node */</span></span><br><span class="line">	sparse_init_nid(nid_begin, pnum_begin, pnum_end, map_count);</span><br><span class="line">	vmemmap_populate_print_last();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>memblocks_present</em> 作用是为Mem Block中标记的memory类型的内存分配mem_section，并对mem_section的section_mem_map自段做Present标记。如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ms-&gt;section_mem_map) &#123;</span><br><span class="line">	ms-&gt;section_mem_map = sparse_encode_early_nid(nid) |</span><br><span class="line">					SECTION_IS_ONLINE;</span><br><span class="line">	section_mark_present(ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“分配mem_section”并不准确，当Kconfig不是 _CONFIG_SPARSEMEM_EXTREME_时，mem_section数组是静态定义的。</p>
</blockquote>
<ul>
<li>接着的循环就是遍历所有mem_section，分配struct page，修改mem_sesction的section_mem_map将该mem_section指向的page首地址与其关联。这里提一点是，section_mem_map主要存的是struct page表首地址减去该mem_section首个页的页帧号。这样后续可以快速的进行页帧号与对应struct page的相互转换。如下代码是封装，及页和页帧转换部分：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">sparse_encode_mem_map</span><span class="params">(struct page *mem_map, <span class="keyword">unsigned</span> <span class="keyword">long</span> pnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> coded_mem_map =</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mem_map - (section_nr_to_pfn(pnum)));</span><br><span class="line">	BUILD_BUG_ON(SECTION_MAP_LAST_BIT &gt; (<span class="number">1U</span>L&lt;&lt;PFN_SECTION_SHIFT));</span><br><span class="line">	BUG_ON(coded_mem_map &amp; ~SECTION_MAP_MASK);</span><br><span class="line">	<span class="keyword">return</span> coded_mem_map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line">(&#123;	<span class="keyword">const</span> struct page *__pg = (pg);				\</span><br><span class="line">	<span class="keyword">int</span> __sec = page_to_section(__pg);			\</span><br><span class="line">	(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line">(&#123;	<span class="keyword">unsigned</span> <span class="keyword">long</span> __pfn = (pfn);			\</span><br><span class="line">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span><br><span class="line">	__section_mem_map_addr(__sec) + __pfn;		\</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本文先介绍到这，后续篇幅接着介绍Buddy System。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>Buddy System</tag>
        <tag>伙伴系统</tag>
        <tag>Memblock</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - Memblock和Buddy System(2)</title>
    <url>/p/5347665a.html</url>
    <content><![CDATA[<blockquote>
<p>书接前文，本文介绍《Memblock和Buddy System》的第二篇，第一篇见<a href="/p/20210923linuxmm4.html">前文</a></p>
</blockquote><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><h3 id="Mem-Block向Buddy-System过渡"><a href="#Mem-Block向Buddy-System过渡" class="headerlink" title="Mem Block向Buddy System过渡"></a>Mem Block向Buddy System过渡</h3><p>伙伴系统便是使用页为单位对内存进行管理的方法。伙伴系统接管前，处理建立mem_section结构，也必须先从Mem Block中释放出不再使用的内存交给伙伴系统管理。本文<a href="#%E9%87%8A%E6%94%BE">Figure 2</a>中略有体现，实现这个过渡的函数是memblock_free_all:</p><a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">memblock_free_all</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pages;</span><br><span class="line"></span><br><span class="line">	free_unused_memmap();</span><br><span class="line">	reset_all_zones_managed_pages();</span><br><span class="line">	pages = free_low_memory_core_early();</span><br><span class="line">	totalram_pages_add(pages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>free_unused_memmap</em> 释放未使用mem_map内存。</p>
</li>
<li><p><em>reset_all_zones_managed_pages</em> 作用是将所有节点所有区域的managed_pages自动设置为0（<strong>managed_pages</strong>表示被伙伴系统管理的页的数量）。</p>
</li>
<li><p>_free_low_memory_core_early_主要做两个动作：</p>
<ul>
<li><p>将reserve类型的memblock和明确标记为Memory None的内存对应的页做标记为reserved(PG_reserved)</p>
</li>
<li><p>将Mem block类型为memory的区域free掉，并标记为Free页面</p>
</li>
</ul>
</li>
<li><p>_totalram_pages_add_增加 <em>_totalram_pages</em> ，用于标记系统中可用总页数。</p>
</li>
</ul>
<h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><p>伙伴系统的管理方式可以参考&lt;<a href="http://ptgmedia.pearsoncmg.com/images/0131453483/downloads/gorman_book.pdf" target="_blank" rel="noopener">Understanding the Linux® Virtual Memory Manager</a>&gt;的图：</p>
<p><img src="https://pic.l2h.site/20211004_buddy_system.png" alt="伙伴系统管理图示" title="Figure 1. 伙伴系统管理图示"></p>
<p>每个内存区域(zone)，都有一个链表数组，数组元素用来存放 $2^{Order}$个页的链表。内存的分配和释放便围绕着这个表来管理。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><a href="/p/1dc6adc2.html">数据结构</a>一文，我们已经介绍的struct page/struct zone/struct pglist_data等数据结构。我们回顾其中部分字段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/linux/mmzone.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		managed_pages; <span class="comment">//managed_pages = present_pages - reserved_pages;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages; <span class="comment">//spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages; <span class="comment">//present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    ...</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>

<p><strong>zone</strong></p>
<ul>
<li>zone_pgdat: 表示该内存区域所在的内存结点</li>
<li>zone_start_pfn: 表示该内存区域的起始页帧号</li>
<li>managed_pages: 表示该区域内由伙伴系统管理的页数</li>
<li>spanned_pages: 表示该区域跨越的总页数</li>
<li>present_pages：表示该区域内去掉内存空洞的总页数 （含系统保留页）</li>
<li>free_area:  如前文，存放伙伴系统有关的可用区域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment">	 * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment">	 * this node's node_zonelists as well as other node's node_zonelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment">	 * Generally the first zones will be references to this node's</span></span><br><span class="line"><span class="comment">	 * node_zones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="keyword">int</span> kswapd_order;</span><br><span class="line">	<span class="keyword">enum</span> zone_type kswapd_highest_zoneidx;</span><br><span class="line">	<span class="keyword">int</span> kswapd_failures;		<span class="comment">/* Number of 'reclaimed == 0' runs */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>

<p><strong>pglist_data</strong></p>
<ul>
<li>node_zones: 该数组存储该内存节点内所有的内存区域</li>
<li>node_zonelists：保护所有内存节点中所有内存区域的应用</li>
<li>kswapd_wait、kswapd、kswapd_order等: kswpad线程运行所需字段。</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分配使用<strong>alloc_pages*</strong>系列函数，其核心代码__alloc_pages代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp, order, preferred_nid, nodemask, &amp;ac,</span><br><span class="line">			&amp;alloc_gfp, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ....</span><br><span class="line">	<span class="comment">/* First allocation attempt */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_gfp, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    ...</span><br><span class="line">	page = __alloc_pages_slowpath(alloc_gfp, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge_page(page, gfp, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_gfp, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很多，但是核心部分就是下面三个函数：</p>
<ul>
<li><strong>prepare_alloc_pages</strong>: 主要作用是，分配前准备页面分配的上下文，特别是选取合适的内存节点的内存区域（Zone）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_gfp,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">	ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">	ac-&gt;nodemask = nodemask;</span><br><span class="line">	ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line">    </span><br><span class="line">    ........</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The preferred zone is used for statistics but crucially it is</span></span><br><span class="line"><span class="comment">	 * also used as the starting point for the zonelist iterator. It</span></span><br><span class="line"><span class="comment">	 * may get reset for allocations that ignore memory policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>get_page_from_freelist</strong>: 作用是根据传入的分配参数不断尝试来分配内存。同样引用&lt;<a href="http://ptgmedia.pearsoncmg.com/images/0131453483/downloads/gorman_book.pdf" target="_blank" rel="noopener">Understanding the Linux® Virtual Memory Manager</a>&gt;的图，当所需order的页数不足时，会将更大order的free_area拆分来满足返回对应的page指针。当无法分配成功时，则返回NULL。</li>
</ul>
<p><img src="https://pic.l2h.site/2021-10-04Buddy_Alloc.png" alt="伙伴系统分配" title="伙伴系统分配"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">get_page_from_freelist</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">						<span class="title">const</span> <span class="title">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment">	 * See also __cpuset_node_allowed() comment in kernel/cpuset.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">	z = ac-&gt;preferred_zoneref;</span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mark;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">				last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">			<span class="keyword">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment">			 * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment">			 * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_reclaim_enabled() ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* did not scan */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* did we reclaim enough */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>__alloc_pages_slowpath</strong>:如果get_page_from_freelist分配页面失败，则进行慢速分配。这个函数会尝试回收内存，采用以下顺序：<ul>
<li>触发kswapd尝试回收内存。</li>
<li>如果回收失败，则尝试杀掉进程回收内存。</li>
</ul>
</li>
</ul>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>内存释放最后会调用到*<em>__free_one_page *</em>：释放过程比较容易来讲，找到可以合并的Buddy页帧号向上一级Order合并直到不能合并，将合并好的页加入到对应Order的free_area。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __free_one_page(struct page *page,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">		struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line">		<span class="keyword">int</span> migratetype, <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;   .....</span><br><span class="line">	max_order = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line">    .....</span><br><span class="line">continue_merging:</span><br><span class="line">	<span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">			__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">								migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">		buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,</span></span><br><span class="line"><span class="comment">		 * merge with it and move up one order.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			del_page_from_free_list(buddy, zone, order);</span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/* If we are here, it means order is &gt;= pageblock_order.</span></span><br><span class="line"><span class="comment">		 * We want to prevent merge between freepages on isolate</span></span><br><span class="line"><span class="comment">		 * pageblock and normal pageblock. Without this, pageblock</span></span><br><span class="line"><span class="comment">		 * isolation could cause incorrect freepage or CMA accounting.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We don't want to hit this code for the more frequent</span></span><br><span class="line"><span class="comment">		 * low-order merging.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">			<span class="keyword">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">			buddy = page + (buddy_pfn - pfn);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		&#125;</span><br><span class="line">		max_order = order + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> continue_merging;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">	set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">		to_tail = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">		to_tail = shuffle_pick_tail();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (to_tail)</span><br><span class="line">		add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line">	<span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">		page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kswapd"><a href="#kswapd" class="headerlink" title="kswapd"></a>kswapd</h3><p>见<a href="#内存分配">内存分配</a>一节，_alloc_pages_slowpath会触发kswapd来回收内存。kswapd在每个内存节点都有一个，其定义和代码如下。其实这里就是调用了balance_pgdat进行内存回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kswapd_run</span><span class="params">(<span class="keyword">int</span> nid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line">    ...</span><br><span class="line">	pgdat-&gt;kswapd = kthread_run(kswapd, pgdat, <span class="string">"kswapd%d"</span>, nid);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kswapd</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">		<span class="keyword">bool</span> ret;</span><br><span class="line"></span><br><span class="line">		alloc_order = reclaim_order = READ_ONCE(pgdat-&gt;kswapd_order);</span><br><span class="line">		highest_zoneidx = kswapd_highest_zoneidx(pgdat,</span><br><span class="line">							highest_zoneidx);</span><br><span class="line"></span><br><span class="line">kswapd_try_sleep:</span><br><span class="line">		kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,</span><br><span class="line">					highest_zoneidx);</span><br><span class="line">        ......</span><br><span class="line">		ret = try_to_freeze();</span><br><span class="line">		<span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">		trace_mm_vmscan_kswapd_wake(pgdat-&gt;node_id, highest_zoneidx,</span><br><span class="line">						alloc_order);</span><br><span class="line">		reclaim_order = balance_pgdat(pgdat, alloc_order,</span><br><span class="line">						highest_zoneidx);</span><br><span class="line">		<span class="keyword">if</span> (reclaim_order &lt; alloc_order)</span><br><span class="line">			<span class="keyword">goto</span> kswapd_try_sleep;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;flags &amp;= ~(PF_MEMALLOC | PF_SWAPWRITE | PF_KSWAPD);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是自己学习Linux内存管理的简单梳理，介绍了：</p>
<ul>
<li>Linux初始化早期的Memblock内存管理</li>
<li>Linux物理内存模型</li>
<li>Linux伙伴系统（Buddy Allocator）</li>
</ul>
<p>希望也对您理解Linux的内存管理有一些帮助。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>内核代码. <a href="https://elixir.bootlin.com/linux/latest/source/" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source/</a>.</li>
<li>内核手册. <a href="https://www.kernel.org/doc/html/latest/vm/index.html" target="_blank" rel="noopener">https://www.kernel.org/doc/html/latest/vm/index.html</a>.</li>
<li>Understanding the Linux® Virtual Memory Manager. Mel Gorman. <a href="http://ptgmedia.pearsoncmg.com/images/0131453483/downloads/gorman_book.pdf" target="_blank" rel="noopener">http://ptgmedia.pearsoncmg.com/images/0131453483/downloads/gorman_book.pdf</a>.</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>Buddy System</tag>
        <tag>伙伴系统</tag>
        <tag>Memblock</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - SLUB</title>
    <url>/p/37327e44.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第六篇</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
<p><a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>介绍了Memblock和伙伴系统分配器</p>
</blockquote>
<p>为了避免晦涩难懂，本文及之后均主要使用图表+文字描述，尽量避免涉及过多代码。专注点会在：</p>
<ol>
<li>背景</li>
<li>架构及其思想</li>
<li>流程</li>
<li>特殊处理及其原因</li>
</ol>
</blockquote><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络上介绍SLAB/SLUB的文章很多，也都很详细，本文以当前内核版本(<strong>5.14.X</strong>)来介绍被广泛采用的SLAB内存管理，希望尽可能地做到详尽易理解。一些更多的参考资料见，文中不再另外标注引用：</p>
<ul>
<li><a href="http://www.wowotech.net/memory_management/426.html" target="_blank" rel="noopener">图解Slub</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/vm/slub.html" target="_blank" rel="noopener">Short users guide for SLUB</a></li>
</ul>
<p><strong>kmalloc/kfree</strong> 大概是内核最常用的内存分配和释放函数，其背后的实现就是SLAB分配器。而SLUB是SLAB分配器的一种实现，另外的两种实现分别是SLAB和SLOB。从命名也可以看出SLAB是鼻祖，随着内核的发展，演进出了SLOB和SLUB分配器。</p>
<ul>
<li>SLOB分配器是为了应对嵌入式设备内存管理的特殊需求而生</li>
<li>SLUB则是在SLAB的基础上演进而来，可以很好地适应各种平台的需求，更为有效地使用内存，同时增强了调试的容易度。</li>
</ul>
<p><strong>SLAB分配器解决的是什么问题？</strong>这个问题可以换种方式来问，为什么有了Buddy System，还要用SLAB分配器？ 解释如下：</p>
<ul>
<li>伙伴系统是以页为单位进行管理的，每页的大小一般为4096字节。内核程序在申请内存时，往往不会刚好申请页大小的倍数，如果我们按页进行分配，没过多久系统内存就会被耗尽。</li>
<li>因为上述原因，必须采用更小的单位对内存进行管理。这需要考虑频繁内存分配释放造成的内存碎片问题。与此同时，需要考虑如何更有效地利用CPU缓存，以及尽量避免访问同一块内存区域造成的静态，等等。</li>
</ul>
<p><strong>为什么这三种分配器又都是SLAB分配器的实现</strong>？这是因为这三种分配器采用一样的数据结构名称和内存分配/释放API（注意，仅仅是“名称”一样）。例，其管理结构体，都叫<strong><em>struct kmem_cache</em></strong>。</p>
<h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><p><a href="#前言">前言</a>讲到，SLAB/SLOB/SLUB采用相同的API，相同的结构体，那么他们一定是相互排他的，这从内核定义KConfig也可以看出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">choice</span><br><span class="line">	prompt <span class="string">"Choose SLAB allocator"</span></span><br><span class="line">	<span class="keyword">default</span> SLUB</span><br><span class="line">	help</span><br><span class="line">	   This option allows to select a slab allocator.</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> SLAB</span><br><span class="line">	<span class="keyword">bool</span> <span class="string">"SLAB"</span></span><br><span class="line">	select HAVE_HARDENED_USERCOPY_ALLOCATOR</span><br><span class="line">	help</span><br><span class="line">	  The regular slab allocator that is established <span class="keyword">and</span> known to work</span><br><span class="line">	  well in all environments. It organizes cache hot objects in</span><br><span class="line">	  per cpu <span class="keyword">and</span> per node queues.</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> SLUB</span><br><span class="line">	<span class="keyword">bool</span> <span class="string">"SLUB (Unqueued Allocator)"</span></span><br><span class="line">	select HAVE_HARDENED_USERCOPY_ALLOCATOR</span><br><span class="line">	help</span><br><span class="line">	   SLUB is a slab allocator that minimizes cache <span class="built_in">line</span> usage</span><br><span class="line">	   instead of managing queues of cached objects (SLAB approach).</span><br><span class="line">	   Per cpu caching is realized <span class="keyword">using</span> slabs of objects instead</span><br><span class="line">	   of queues of objects. SLUB can use memory efficiently</span><br><span class="line">	   <span class="keyword">and</span> has enhanced diagnostics. SLUB is the <span class="keyword">default</span> choice <span class="keyword">for</span></span><br><span class="line">	   a slab allocator.</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> SLOB</span><br><span class="line">	depends on EXPERT</span><br><span class="line">	<span class="keyword">bool</span> <span class="string">"SLOB (Simple Allocator)"</span></span><br><span class="line">	help</span><br><span class="line">	   SLOB replaces the stock allocator with a drastically simpler</span><br><span class="line">	   allocator. SLOB is generally more space efficient but</span><br><span class="line">	   does <span class="keyword">not</span> perform as well on large systems.</span><br><span class="line"></span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>从中默认选项就是SLUB。</p>
<blockquote>
<p>KConfig相关知识可以参考<a href="https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html" target="_blank" rel="noopener">KConfig Language</a></p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>SLAB（下文中SLAB也统一代表SLUB）在系统中的位置如<strong>Figure 1</strong>所示.</p>
<p><img src="/images/posts/20211007/Architecture-in-the-system.png" alt="SLUB在内存管理系统中位置" title="Figure 1.SLUB在内存管理系统中位置"></p>
<p>简单说明如下:</p>
<ul>
<li>内存管理系统的最大管理单位是Node，被划分为多个Memory Zone（<font color="red">ToDo: 上一章Buddy System和第二章补充图片示意</font>）。</li>
<li>在进行Page分配时（Page分配还记得吗？可以参考<a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>对<strong>Buddy System</strong>的介绍），是依据分配传入的参数，选择从哪个Memory Zone分配内存。</li>
<li>SLAB的分配需要kmem_cache管理结构，而这些管理结构所需的内存也是从的kmem_cache来的。这里内核<u><strong>做了很巧妙的设计</strong></u>: <ul>
<li>建立kmem_cache的slab所需的slab初始管理对象是boot_kmem_cache和boot_kmem_cache_node。它们被__init属性修饰，表示将会被放到.init.data段，并在内核初始化的后半段释放。</li>
<li>在整个SLAB系统初始化过程中，会从boot_kmem_cache和boot_kmem_cache_node指向的SLAB，分配出全局SLAB对象kmem_cache和kmem_cache_node。</li>
<li>之后将boot_kmem_cache和boot_kmem_cache_node内容拷贝到kmem_cache和kmem_cache_node。</li>
<li>至此，使用全局SLAB对象kmem_cache和kmem_cache_node来进行SLUB管理。</li>
</ul>
</li>
<li>kmalloc的内存也是内核初始化早期分配的。其实质上是建立了大小分别为2, 4, 8, ….的SLAB对象。</li>
</ul>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>下表介绍SLAB及SLUB相关内核源文件：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>slab.c</td>
<td>SLAB分配器（三个分配器之一）的实现</td>
</tr>
<tr>
<td>slab.h</td>
<td>所有SLAB分配器的头文件定义</td>
</tr>
<tr>
<td>slob.c</td>
<td>SLOB分配器的实现</td>
</tr>
<tr>
<td>slub.c</td>
<td>SLUB分配器的实现</td>
</tr>
<tr>
<td>slab_common.c</td>
<td>所有SLAB分配器公用的，与实现无关的函数。大部分都会调用到具体的某个分配器。</td>
</tr>
</tbody></table>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>SLAB的重要的数据结构有三个，其内容和相互关系如下图：</p>
<p><img src="/images/posts/20211007/SLUB.png" alt="SLUB数据结构" title="Figure 2.SLUB数据结构"></p>
<p>其中：</p>
<ul>
<li>kmem_cache代表一个SLAB对象</li>
<li>kmem_cache_cpu里存储了该SLAB对象在CPU本地的资源，这里<strong>__percpu</strong>修饰表示这是一个Per CPU对象（每个CPU有一份拷贝）</li>
<li>kmem_cache_node是一个数组，每个数组成员代表该SLAB对象在每个<a href="/p/1dc6adc2.html#内存节点">内存结点</a>的内存资源。</li>
</ul>
<h2 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h2><p>SLUB的管理方式如下图：</p>
<p><img src="/images/posts/20211007/slub_Detail.png" alt="SLUB管理" title="Figure3. SLUB管理方式"></p>
<p>简单描述如下：</p>
<ul>
<li>每个SLUB管理结构分别有多个cpu本地slab和node slab。</li>
<li>SLUB刚建立时，只有对应的管理结构。</li>
<li>SLUB分配内存时<ul>
<li>若此时该对象中没有页面可用，则从伙伴系统中分配页面、挂到cpu本地slab上，从中返回一个所需内存。</li>
<li>若此时该对象中有可用页面，则从中分配内存。</li>
<li>若当前kmem_cache_cpu已经没有可用页面(kmem_cache_cpu的freelist和partial所指向页都满)，则从kmem_cache_node的partial处分配内存</li>
</ul>
</li>
</ul>
<blockquote>
<p>这样处理可以保证总是优先从该cpu的cache区域分配，提升资源的访问速度。</p>
</blockquote>
<ul>
<li>释放内存：会先将内存释放到该内存所在页。 释放有如下情况：</li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>释放方式</th>
</tr>
</thead>
<tbody><tr>
<td><u>释放前</u>该页上内存已经全部使用，per cpu partial链表上的空闲可用内存总数 <strong><font color="red">&gt;</font></strong> kmem_cache.cpu_partial</td>
<td>1. 将kmem_cache_cpu的partial链表上的页挂到per node partial。 2.将该内存所在页放回kmem_cache_cpu的partial链表</td>
</tr>
<tr>
<td><u>释放前</u>该页上内存已经全部使用，per cpu partial链表上的空闲可用内存总数 <strong><font color="red">&lt;=</font></strong> kmem_cache.cpu_partial</td>
<td>将该内存所在页放回kmem_cache_cpu的partial链表</td>
</tr>
<tr>
<td>1. 该页在per node partial 2.<u>释放后</u>，该页呈未分配状态 3.kmem_cache_node.nr_partial <strong><font color="red">&gt;</font></strong> kmem_cache.min_partial</td>
<td><font color="blue">将该页归还给伙伴系统</font></td>
</tr>
<tr>
<td>其他</td>
<td>/</td>
</tr>
</tbody></table>
<blockquote>
<p>设置阈值的主要目的是为了避免SLAB占用过多的内存页，导致系统中其他对象想要分配内存时拿不到内存。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了SLAB内存分配器，其是整个系统运行中，起重要且主要作用的内存分配器。介绍了：</p>
<ul>
<li>SLAB分配器的分类</li>
<li>SLUB分配器的架构</li>
<li>SLUB分配器的逻辑原理</li>
</ul>
<p>希望对您分析内核代码有所帮助。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>SLAB</tag>
        <tag>SLUB</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML主题选项</title>
    <url>/p/c5b29752.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.plantuml.com/" target="_blank" rel="noopener">PlantUML</a>可以算是最成功最知名的开源绘图工具了，它可以方便地将您输入文字型描述，转化成您想要的各种图（当然，要遵循其语法）。近日，在做流程图的时候，到网站上去翻语法，赫然发现其增加了一个新的<a href="https://plantuml.com/zh/theme" target="_blank" rel="noopener"><strong>主题</strong></a>功能。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>用法也很简单, 在文件头部增加如下配置即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!theme 主题名</span><br></pre></td></tr></table></figure><p>例如，如下图采用内置的spacelab主题：</p><a id="more"></a>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">!theme spacelab</span><br><span class="line">Bob -&gt; Alice :  hello</span><br><span class="line">Bob &lt;- Alice :  $success(&quot;success: hello B.&quot;)</span><br><span class="line">Bob -x Alice :  $failure(&quot;failure&quot;)</span><br><span class="line">Bob -&gt;&gt; Alice : $warning(&quot;warning&quot;)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="/images/posts/20211009/sample.png" alt="spacelab主题示例"></p>
<p>除了内置主题，也支持本地主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!theme 主题名 from /本地/摆放/主题的路径</span><br></pre></td></tr></table></figure>

<p>互联网主题也支持，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!theme 主题名 from https://raw.githubusercontent.com/plantuml/plantuml/master/themes</span><br></pre></td></tr></table></figure>

<h2 id="内置主题"><a href="#内置主题" class="headerlink" title="内置主题"></a>内置主题</h2><p>您可以使用如下代码查看PLANTUML支持哪些内置主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">help themes</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>目前plantuml支持如下内置主题，为了方便大家选用，我将所有的示例图显示出来（P.S. 个人比较喜欢sketchy）：</p>
<p><img src="/images/posts/20211009/vibrant.png" alt="vibrant"></p>
<p><img src="/images/posts/20211009/amiga.png" alt="amiga"></p>
<p><img src="/images/posts/20211009/aws-orange.png" alt="aws-orange"></p>
<p><img src="/images/posts/20211009/black-knight.png" alt="black-knight"></p>
<p><img src="/images/posts/20211009/bluegray.png" alt="bluegray"></p>
<p><img src="/images/posts/20211009/blueprint.png" alt="blueprint"></p>
<p><img src="/images/posts/20211009/cerulean-outline.png" alt="cerulean-outline"></p>
<p><img src="/images/posts/20211009/cerulean.png" alt="cerulean"></p>
<p><img src="/images/posts/20211009/crt-amber.png" alt="crt-amber"></p>
<p><img src="/images/posts/20211009/crt-green.png" alt="crt-green"></p>
<p><img src="/images/posts/20211009/cyborg-outline.png" alt="cyborg-outline"></p>
<p><img src="/images/posts/20211009/Cyborg.png" alt="Cyborg"></p>
<p><img src="/images/posts/20211009/hacker.png" alt="hacker"></p>
<p><img src="/images/posts/20211009/lightgray.png" alt="lightgray"></p>
<p><img src="/images/posts/20211009/materia-outline.png" alt="materia-outline"></p>
<p><img src="/images/posts/20211009/materia.png" alt="materia"></p>
<p><img src="/images/posts/20211009/metal.png" alt="metal"></p>
<p><img src="/images/posts/20211009/mimeograph.png" alt="mimeograph"></p>
<p><img src="/images/posts/20211009/minty.png" alt="minty"></p>
<p><img src="/images/posts/20211009/plain.png" alt="plain"></p>
<p><img src="/images/posts/20211009/reddress-darkblue.png" alt="reddress-darkblue"></p>
<p><img src="/images/posts/20211009/reddress-darkgreen.png" alt="reddress-darkgreen"></p>
<p><img src="/images/posts/20211009/reddress-darkorange.png" alt="reddress-darkorange"></p>
<p><img src="/images/posts/20211009/reddress-darkred.png" alt="reddress-darkred"></p>
<p><img src="/images/posts/20211009/reddress-lightblue.png" alt="reddress-lightblue"></p>
<p><img src="/images/posts/20211009/reddress-lightgreen.png" alt="reddress-lightgreen"></p>
<p><img src="/images/posts/20211009/reddress-lightorange.png" alt="reddress-lightorange"></p>
<p><img src="/images/posts/20211009/reddress-lightred.png" alt="reddress-lightred"></p>
<p><img src="/images/posts/20211009/sample.png" alt="sample"></p>
<p><img src="/images/posts/20211009/sandstone.png" alt="sandstone"></p>
<p><img src="/images/posts/20211009/silver.png" alt="silver"></p>
<p><img src="/images/posts/20211009/sketchy-outline.png" alt="sketchy-outline"></p>
<p><img src="/images/posts/20211009/sketchy.png" alt="sketchy"></p>
<p><img src="/images/posts/20211009/spacelab.png" alt="spacelab"></p>
<p><img src="/images/posts/20211009/superhero-outline.png" alt="superhero-outline"></p>
<p><img src="/images/posts/20211009/superhero.png" alt="superhero"></p>
<p><img src="/images/posts/20211009/toy.png" alt="toy"></p>
<p><img src="/images/posts/20211009/united.png" alt="united"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了PlantUML的主题，将内置主题的样式全部呈现出来供参考。这类开发实用工具其实很多，本人后续也会推荐一些优秀的工具给大家。本站的链接栏也有一些链接可以参考。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PlantUML</tag>
        <tag>架构图</tag>
        <tag>主题</tag>
        <tag>Theme</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - KFENCE</title>
    <url>/p/75308136.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第六篇</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
<p><a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>介绍了Memblock和伙伴系统分配器</p>
</blockquote>
</blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a>
<p><a href="https://www.kernel.org/doc/html/latest/dev-tools/kfence.html" target="_blank" rel="noopener">Kernel Electric-Fence (KFENCE)</a>是5.12版本内核新引入的内存使用错误检测机制。它可以检查的错误有：</p>
<ul>
<li>内存访问越界</li>
<li>释放后使用</li>
<li>无效释放</li>
</ul>
<p>显然，它可以检测的内存错误类型不如<a href="https://www.kernel.org/doc/html/latest/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN</a>多。但与KASAN相比，它最大的优势是运行时小Overhead，可以直接用在生产环境中。因此在X86，ARM64，RISCV等平台上均默认开启。</p>
<blockquote>
<p>在Arch对应的defconfig中使用CONFIG_HAVE_ARCH_KFENCE开启。</p>
</blockquote>
<h2 id="架构及原理"><a href="#架构及原理" class="headerlink" title="架构及原理"></a>架构及原理</h2><p>Kfence的原理比较简单，如下图：</p>
<p><img src="/images/posts/20211016/Kfence.png" alt="KFENCE" title="KFENCE"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化过程中，KFENCE向<a href="https://www.l2h.site/p/20210923linuxmm4.html" target="_blank" rel="noopener">Memblock</a>申请一段内存，作为KFENCE内存池。<ul>
<li>这个内存池的大小配置为CONFIG_KFENCE_NUM_OBJECTS</li>
<li>即，预留两个页面作为保护页（Guard Page），接着为每一个用于分配的内存页分配一个Guard Page。因此总大小为：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KFENCE_POOL_SIZE ((CONFIG_KFENCE_NUM_OBJECTS + 1) * 2 * PAGE_SIZE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化一个Delayed Worker，定期（<strong>CONFIG_KFENCE_SAMPLE_INTEVAL</strong>）重置kfence_alloc_gate值为0。</li>
</ul>
<blockquote>
<p>这个值可以通过sysfs修改</p>
</blockquote>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><ul>
<li>kfence_alloc_gate值为0时，使用kmem_cache_alloc所作的内存分配从KFENCE内存池中分配，并增加kfence_alloc_gate的值。kfence_alloc_gate值大于等于1时，直接从SLUB中分配。由此可以看出，kfence是基于采样的内存检测。</li>
</ul>
<blockquote>
<p>大于一个Page(4K)的分配不会从KFENCE Pool中分配</p>
</blockquote>
<ul>
<li>每次通过KFENCE进行内存分配时，都会从KFENCE内存池分配一个内存页和一个Guard Page，并在实际使用内存的两端内存填充Canary数据。</li>
</ul>
<blockquote>
<p>解释一下为什么保护数据叫Canary。这是因为在19世纪，金丝雀在采矿业中常用的毒气检测方法，因为它们比人类对毒气更为敏感反应也更快。</p>
</blockquote>
<ul>
<li>如果KFENCE内存池中没有可用内存，则直接从SLAB中分配。</li>
</ul>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><ul>
<li>释放时，检查Canary数据，将所用内存放回KFENCE内存池。</li>
</ul>
<h3 id="检测报错"><a href="#检测报错" class="headerlink" title="检测报错"></a>检测报错</h3><p>在以下情况，会检测报错：</p>
<ul>
<li>释放时发现Canary数据不对。</li>
<li>当KFENCE内存池的内存区域发生Page Fault时，它或者是因为越界访问、或者是释放后使用。</li>
<li>无效释放：当一段KFENCE内存没有被标记分配，但对齐释放时，会有相应报错提示。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开源社区总能带来新的idea。KFENCE，克服了KASAN等工具需要占用大量内存且影响运行时性能的缺点，是一个有效地运行时内存访问错误检测工具。</p>
<p>当然，因为它所针对的内存区域仅仅是KFENCE内存池，且其是周期性进行采样，检测效果还不得而知。其又有可以动态开关、参数可调节等优点，这些劣势或许也不是问题。后续若有时间可以研究分析对比其和KASAN的检测效果。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>KFENCE</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC运行Virtual Box时&quot;The support driver is not installed&quot;解决</title>
    <url>/p/7ccf1cb6.html</url>
    <content><![CDATA[<blockquote>
<p>注意：这只是一个Work Around方法，并非完全解决方案</p>
</blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>MAC升级Big Sur后，每次运行Virtual Box都会有如下报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel driver not installed (rc=-1908)</span><br><span class="line"></span><br><span class="line">Make sure the kernel module has been loaded successfully.</span><br><span class="line"></span><br><span class="line">where: suplibOsInit what: 3 VERR_VM_DRIVER_NOT_INSTALLED (-1908) - The support driver is not installed. On linux, open returned ENOENT.</span><br></pre></td></tr></table></figure><a id="more"></a>



<p><a href="https://blog.csdn.net/u011700186/article/details/109741194" target="_blank" rel="noopener">CSDN这篇文章</a>介绍得很详细，但不够完整，这里做一下补充</p>
<h2 id="下载安装Extension"><a href="#下载安装Extension" class="headerlink" title="下载安装Extension"></a>下载安装Extension</h2><p>到<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">Virtual Box官网</a>下载Extension Pack并安装，如下图：</p>
<p><img src="/images/posts/20211017/VBox_MAC_Extension.png" alt="Extension Pack" title="Virtual Box Extension Pack"></p>
<p>下载安装时，如果被系统安全阻拦，可以在“安全与隐私”设置里信任相关程序的执行。</p>
<h2 id="执行kext"><a href="#执行kext" class="headerlink" title="执行kext"></a>执行kext</h2><p>这里很奇怪，无论怎么安装重启，在我的电脑上，对应的Driver总不能开机自动运行(<u>这也是前文说这是Workaround的原因</u>)，因此每次重新开机后还必须执行一次如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo kextload -b org.virtualbox.kext.VBoxDrv</span><br></pre></td></tr></table></figure>

<p>接着再运行Virtual Box就不会报错了。</p>
<blockquote>
<p>后续若找到自动加载的方法，可以再交流讨论更新</p>
</blockquote>
<h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><p>这里说明一下，会有以上报错的主要原因就是MAC High Sierra，开始逐渐淘汰运行在内核态的驱动，改推荐（甚至强制推行）厂商改用<a href="https://developer.apple.com/system-extensions/" target="_blank" rel="noopener">System Extension</a>来开发驱动，于是乎，各种兼容性问题就来了。</p>
<p>这也是Apple强硬的一点。当然反之使用System Extension是有好处的，希望Oracle后续看如何更好地兼容新的MAC OS。</p>
]]></content>
      <categories>
        <category>软件技巧</category>
      </categories>
      <tags>
        <tag>Virtual Box</tag>
        <tag>MAC OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 进程内存</title>
    <url>/p/e84c7fac.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第七篇:</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
<p><a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>介绍了Memblock和伙伴系统分配器</p>
<p><a href>第六篇</a>介绍了内存检测工具KFence工作原理</p>
</blockquote>
</blockquote><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em><a href="https://man7.org/linux/man-pages/man3/realloc.3.html" target="_blank" rel="noopener">malloc()</a></em></strong> 大概是在Linux平台上用户空间态编程，最常用的内存分配函数。大家可能会想，</p>
<ul>
<li><p>这个函数是如何拿到内存的？内核如何为它做的映射？</p>
</li>
<li><p>另外，一个可执行程序有自己的代码和静态数据，内核如何将这个可执行程序代码加载到内存中执行？其对应的静态变量，全局变量等所需内存又是如何分配的？</p>
</li>
</ul>
<p>以上问题是开发用户空间态程序时，容易被忽略的、甚至完全不会被注意到的问题。因为这些都是由程序所链接的C库和底层内核实现的，程序开发者往往无需在意这些细节。</p>
<p>一般情况下，这并不影响大家写出一个像样的程序。但是当面临一些疑难问题时，仅有如何使用C函数的知识，是无法胜任和处理的。</p>
<p>本文意在从以下几点剖析内核处理进程内存有关的过程:</p>
<ul>
<li>进程创建过程的段映射</li>
<li>进程内存分配过程的堆映射</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>下图简要描述了Linux内存管理架构：</p>
<ul>
<li>用户空间态程序使用GLIBC来创建进程或管理内存</li>
</ul>
<blockquote>
<p>这里GLIBC并不是唯一选项，也有许多其替代。例如：<a href="http://musl.libc.org/" target="_blank" rel="noopener">musl Libc</a>, 嵌入式设备常用的<a href="https://www.uclibc.org/about.html" target="_blank" rel="noopener">uClibc</a>等。</p>
</blockquote>
<ul>
<li>内核态和用户空间态处理内存分配和进程管理的接口是系统调用。</li>
</ul>
<blockquote>
<p>当然除了系统调用之外，内核和用户空间态通信方式还有<a href="https://en.wikipedia.org/wiki/Netlink" target="_blank" rel="noopener">Netlink</a>等。</p>
</blockquote>
<ul>
<li><strong><em>malloc()</em></strong>、<strong><em>free()</em></strong>等函数并不会直接跟系统要内存，反而会在必要时才会使用系统调用向内核申请内存。</li>
<li>启动程序时，使用系统调用<strong><em>fork</em></strong>或者<strong><em>clone</em></strong>创建进程，调用<strong><em>execv</em></strong>加载ELF，为进程创建必要的数据结构、分配必要的内存和页表。</li>
<li>内核内存管理如系列文章所述，有按页分配的伙伴系统、更小级别的分配器SLAB。</li>
<li>系统调用通过虚拟地址映射管理VMA来为进程分配和管理内存。</li>
<li>内核根据需要，会将暂时不需要使用的进程内存换出。而当有使用需求时，再将对应内存换入。这就需要内核的缺页中断处理程序及换页机制来保障。</li>
</ul>
<p><img src="/images/posts/20211106/arch.png" alt="Linux内存管理架构" title="Linux内存管理架构"></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>内核为每个进程分配了一个数据结构<strong><em>task_struct</em></strong>，而其中管理内存的部分是<strong><em>mm_struct</em></strong>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* list of VMAs */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span></span><br><span class="line">....</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;	<span class="comment">/* base of mmap area */</span></span><br><span class="line">...</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;	<span class="comment">/* size of task vm space */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> highest_vm_end;	<span class="comment">/* highest vma end address */</span></span><br><span class="line">		<span class="keyword">pgd_t</span> * pgd;</span><br><span class="line">...</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;	   <span class="comment">/* Total pages mapped */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;   <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">		<span class="keyword">atomic64_t</span>    pinned_vm;   <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> data_vm;	   <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;	   <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;	   <span class="comment">/* VM_STACK */</span></span><br><span class="line">...</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">...</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中所结构体栏位的意义标注如下图：</p>
<ul>
<li>mmap_base指向进程的MMAP空间</li>
<li>brk和start_brk分别指向进程堆的当前位置（若进程需要申请更大的堆，则从该位置开始分配）和起始地址。</li>
<li>start_code和end_code分别指向代码段的起始地址和结束地址。</li>
<li>start_data和end_data分别指向数据段的起始地址和结束地址。</li>
<li>start_stack指向栈的初始地址。</li>
<li>除此之外，还有为该进程参数、环境变量所分配的内存(arg_start/arg_end/env_start/env_end)。</li>
</ul>
<blockquote>
<p>以上地址皆为虚拟地址，是内核进程启动的过程中，由内核所初始化。</p>
</blockquote>
<ul>
<li>mmap和mm_rb下管理内核所以为该进程分配的虚拟内存，分别使用红黑树和链表管理。</li>
<li>pgd指向该进程的页目录</li>
</ul>
<p><img src="/images/posts/20211106/process_vma.png" alt="Linux进程内存管理" title="Linux进程内存管理"></p>
<h2 id="进程创建时内存管理"><a href="#进程创建时内存管理" class="headerlink" title="进程创建时内存管理"></a>进程创建时内存管理</h2><p>您可能会想知道，前一节所提及的那些段地址，内核是如何确定的？其实这跟<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">ELF格式</a>有关。</p>
<ul>
<li>所有的Linux进程都遵循ELF格式，在链接的过程中，链接器按照<a href="https://sourceware.org/binutils/docs/ld/Scripts.html" target="_blank" rel="noopener">Linker Script</a>的指定将程序打包成ELF。</li>
</ul>
<blockquote>
<p>如果没有明确指定，GCC会指定一个默认的Linker Script</p>
</blockquote>
<ul>
<li>内核创建进程时，会初始化<strong><em>mm_struct</em></strong>。</li>
<li>内核加载进程的过程中，按照ELF头部信息为该进程分配内存。</li>
</ul>
<p>一张图描述上述过程。</p>
<p><img src="/images/posts/20211106/Load_ELF.png" alt="Linux进程内存初始化" title="Linux进程内存初始化"></p>
<p>内核加载进程执行，也遵守ELF规范，在此期间为进程分配虚拟内存VMA。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="用户空间态"><a href="#用户空间态" class="headerlink" title="用户空间态"></a>用户空间态</h3><p>使用musl Libc来对<strong><em>malloc()</em></strong>进行介绍。</p>
<blockquote>
<p>没有选择Glibc分析的原因，是因为没有搞懂<strong><em><a href="https://sourceware.org/systemtap/wiki/UserSpaceProbeImplementation" target="_blank" rel="noopener">Systemtap</a></em></strong>的原理。使用musl Libc分析不会影响理解。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *__simple_malloc(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uintptr_t</span> brk, cur, <span class="built_in">end</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> mmap_step;</span><br><span class="line">	<span class="keyword">size_t</span> align=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &gt; SIZE_MAX/<span class="number">2</span>) &#123;</span><br><span class="line">		errno = ENOMEM;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!n) n++;</span><br><span class="line">	<span class="keyword">while</span> (align&lt;n &amp;&amp; align&lt;ALIGN)</span><br><span class="line">		align += align;</span><br><span class="line"></span><br><span class="line">	LOCK(lock);</span><br><span class="line"></span><br><span class="line">	cur += -cur &amp; align<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="built_in">end</span>-cur) &#123;</span><br><span class="line">		<span class="keyword">size_t</span> req = n - (<span class="built_in">end</span>-cur) + PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">			brk = __syscall(SYS_brk, <span class="number">0</span>);</span><br><span class="line">			brk += -brk &amp; PAGE_SIZE<span class="number">-1</span>;</span><br><span class="line">			cur = <span class="built_in">end</span> = brk;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (brk == <span class="built_in">end</span> &amp;&amp; req &lt; SIZE_MAX-brk</span><br><span class="line">		    &amp;&amp; !traverses_stack_p(brk, brk+req)</span><br><span class="line">		    &amp;&amp; __syscall(SYS_brk, brk+req)==brk+req) &#123;</span><br><span class="line">			brk = <span class="built_in">end</span> += req;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> new_area = <span class="number">0</span>;</span><br><span class="line">			req = n + PAGE_SIZE<span class="number">-1</span> &amp; -PAGE_SIZE;</span><br><span class="line">			<span class="comment">/* Only make a new area rather than individual mmap</span></span><br><span class="line"><span class="comment">			 * if wasted space would be over 1/8 of the map. */</span></span><br><span class="line">			<span class="keyword">if</span> (req-n &gt; req/<span class="number">8</span>) &#123;</span><br><span class="line">				<span class="comment">/* Geometric area size growth up to 64 pages,</span></span><br><span class="line"><span class="comment">				 * bounding waste by 1/8 of the area. */</span></span><br><span class="line">				<span class="keyword">size_t</span> <span class="built_in">min</span> = PAGE_SIZE&lt;&lt;(mmap_step/<span class="number">2</span>);</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">min</span>-n &gt; <span class="built_in">end</span>-cur) &#123;</span><br><span class="line">					<span class="keyword">if</span> (req &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">						req = <span class="built_in">min</span>;</span><br><span class="line">						<span class="keyword">if</span> (mmap_step &lt; <span class="number">12</span>)</span><br><span class="line">							mmap_step++;</span><br><span class="line">					&#125;</span><br><span class="line">					new_area = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">void</span> *mem = __mmap(<span class="number">0</span>, req, PROT_READ|PROT_WRITE,</span><br><span class="line">				MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (mem == MAP_FAILED || !new_area) &#123;</span><br><span class="line">				UNLOCK(lock);</span><br><span class="line">				<span class="keyword">return</span> mem==MAP_FAILED ? <span class="number">0</span> : mem;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = (<span class="keyword">uintptr_t</span>)mem;</span><br><span class="line">			<span class="built_in">end</span> = cur + req;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">void</span> *)cur;</span><br><span class="line">	cur += n;</span><br><span class="line">	UNLOCK(lock);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">weak_alias(__simple_malloc, __libc_malloc_impl);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __libc_malloc_impl(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码比较容易理解,我们只关注其中<strong><em>__syscall(SYS_brk, ….)</em></strong>。它的作用就是使用brk这个系统调用向内核要内存。</p>
<blockquote>
<p> <strong><em>weak_alias</em></strong>的定义如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> weak_alias(old,new) __attribute__((__weak__, __alias__(old)))</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<a href="https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html" target="_blank" rel="noopener">Weak Alias</a>的意义即给<strong><em>old</em></strong> symbol设置一个别名<strong><em>new</em></strong>。</p>
</blockquote>
<h3 id="内核空间态"><a href="#内核空间态" class="headerlink" title="内核空间态"></a>内核空间态</h3><p>内核空间态处理brk系统调用的代码如下：</p>
<ul>
<li>首先做一些必要的检查，如检查所申请的堆大小是否超过系统的rlimit，出错则退出返回错误。解释如下：</li>
</ul>
<blockquote>
<p><strong>RLIMIT_DATA</strong></p>
<p>The maximum size of the process’s data segment (initialized data, uninitialized data, and heap). This limit affects calls to <strong><a href="https://linux.die.net/man/2/brk" target="_blank" rel="noopener">brk</a></strong>(2) and <strong><a href="https://linux.die.net/man/2/sbrk" target="_blank" rel="noopener">sbrk</a></strong>(2), which fail with the error <strong>ENOMEM</strong> upon encountering the soft limit of this resource.</p>
</blockquote>
<ul>
<li>如果当前brk大于所需brk，则将多出的部分从该进程的堆VM映射中移除并返回。</li>
<li>如果当前brk小于所需brk，则为其扩展堆的VM映射并返回。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="keyword">unsigned</span> <span class="keyword">long</span>, brk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> newbrk, oldbrk, origbrk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_brk;</span><br><span class="line">	<span class="keyword">bool</span> populate;</span><br><span class="line">	<span class="keyword">bool</span> downgraded = <span class="literal">false</span>;</span><br><span class="line">	LIST_HEAD(uf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mmap_write_lock_killable(mm))</span><br><span class="line">		<span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">	origbrk = mm-&gt;brk;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CONFIG_COMPAT_BRK can still be overridden by setting</span></span><br><span class="line"><span class="comment">	 * randomize_va_space to 2, which will still cause mm-&gt;start_brk</span></span><br><span class="line"><span class="comment">	 * to be arbitrarily shifted</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;brk_randomized)</span><br><span class="line">		min_brk = mm-&gt;start_brk;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		min_brk = mm-&gt;end_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	min_brk = mm-&gt;start_brk;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (brk &lt; min_brk)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check against rlimit here. If this check is done later after the test</span></span><br><span class="line"><span class="comment">	 * of oldbrk with newbrk then it can escape the test and let the data</span></span><br><span class="line"><span class="comment">	 * segment grow beyond its set limit the in case where the limit is</span></span><br><span class="line"><span class="comment">	 * not page aligned -Ram Gupta</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm-&gt;start_brk,</span><br><span class="line">			      mm-&gt;end_data, mm-&gt;start_data))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	newbrk = PAGE_ALIGN(brk);</span><br><span class="line">	oldbrk = PAGE_ALIGN(mm-&gt;brk);</span><br><span class="line">	<span class="keyword">if</span> (oldbrk == newbrk) &#123;</span><br><span class="line">		mm-&gt;brk = brk;</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Always allow shrinking brk.</span></span><br><span class="line"><span class="comment">	 * __do_munmap() may downgrade mmap_lock to read.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (brk &lt;= mm-&gt;brk) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * mm-&gt;brk must to be protected by write mmap_lock so update it</span></span><br><span class="line"><span class="comment">		 * before downgrading mmap_lock. When __do_munmap() fails,</span></span><br><span class="line"><span class="comment">		 * mm-&gt;brk will be restored from origbrk.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mm-&gt;brk = brk;</span><br><span class="line">		ret = __do_munmap(mm, newbrk, oldbrk-newbrk, &amp;uf, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			mm-&gt;brk = origbrk;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">			downgraded = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check against existing mmap mappings. */</span></span><br><span class="line">	next = find_vma(mm, oldbrk);</span><br><span class="line">	<span class="keyword">if</span> (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ok, looks good - let it rip. */</span></span><br><span class="line">	<span class="keyword">if</span> (do_brk_flags(oldbrk, newbrk-oldbrk, <span class="number">0</span>, &amp;uf) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	mm-&gt;brk = brk;</span><br><span class="line"></span><br><span class="line">success:</span><br><span class="line">	populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (downgraded)</span><br><span class="line">		mmap_read_unlock(mm);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		mmap_write_unlock(mm);</span><br><span class="line">	userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">	<span class="keyword">if</span> (populate)</span><br><span class="line">		mm_populate(oldbrk, newbrk - oldbrk);</span><br><span class="line">	<span class="keyword">return</span> brk;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	mmap_write_unlock(mm);</span><br><span class="line">	<span class="keyword">return</span> origbrk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VMA"><a href="#VMA" class="headerlink" title="VMA"></a>VMA</h2><p>要更进一步理解以上过程，皆需理解VMA的管理方式。引用&lt;深入理解Linux内核架构&gt;一书的介绍：</p>
<p><img src="/images/posts/20211106/vma.png" alt="VMA管理" title="VMA管理"></p>
<ul>
<li><p>如果一个新区域紧接着现存区域前后直接添加(因此也包括在两个现存区域之间的情况)，内核将涉及的数据结构合并为一个。当然，前提是涉及的所有区域的访问权限相同，而且是从同一后备存储器映射的连续数据。</p>
</li>
<li><p>如果在区域的开始或结束处进行删除，则必须据此截断现存的数据结构。</p>
</li>
<li><p>如果删除两个区域之间的一个区域，那么一方面需要减小现存数据结构的长度，另一方面需</p>
<p>要为形成的新区域创建一个新的数据结构。</p>
</li>
</ul>
<p>代码部分不做进一步分析，大家可以直接看<a href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm.h#L2713" target="_blank" rel="noopener">内核源码</a>或者找相关资料学习。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文概要介绍了Linux内核对进程内存的管理方式。主要有：</p>
<ul>
<li>进程内存管理架构</li>
<li>进程加载执行时内存分配</li>
<li>堆管理</li>
<li>VMA的管理方式</li>
</ul>
<p>进程内存管理还涉及到以下知识，将会在之后的文章中介绍：</p>
<ul>
<li>内存映射mmap</li>
<li>反向映射</li>
<li>缺页管理</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>进程内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 文件mmap映射和反向映射</title>
    <url>/p/8cc7cf15.html</url>
    <content><![CDATA[<blockquote>
<p>这是&lt;Linux内核内存管理&gt;系列的第八篇:</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
<p><a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>介绍了Memblock和伙伴系统分配器</p>
<p><a href="/p/75308136.html">第六篇</a>介绍了内存检测工具KFence工作原理</p>
<p><a href="/p/e84c7fac.html">第七篇</a>介绍了进程内存分配malloc的原理</p>
</blockquote>
</blockquote><a id="more"></a>
<h2 id="mmap和munmap"><a href="#mmap和munmap" class="headerlink" title="mmap和munmap"></a>mmap和munmap</h2><p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener"><strong><em>mmap()</em></strong></a>的主要作用是将文件（普通文件或者设备文件）映射到进程的内存地址空间中，让应用程序可以以读写内存的方式来访问文件。与之对应的操作是<a href="https://man7.org/linux/man-pages/man3/munmap.3p.html" target="_blank" rel="noopener"><strong><em>munmap()</em></strong></a>。</p>
<p>一段示例代码来自<a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="noopener">维基百科</a>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> str1[] = <span class="string">"string 1"</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> str2[] = <span class="string">"string 2"</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> parpid = getpid(), childpid;</span><br><span class="line">        <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> *anon, *zero;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">"/dev/zero"</span>, O_RDWR, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"open"</span>);</span><br><span class="line"></span><br><span class="line">        anon = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_ANON|MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        zero = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (anon == MAP_FAILED || zero == MAP_FAILED)</span><br><span class="line">                errx(<span class="number">1</span>, <span class="string">"either mmap"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(anon, str1);</span><br><span class="line">        <span class="built_in">strcpy</span>(zero, str1);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PID %d:\tanonymous %s, zero-backed %s\n"</span>, parpid, anon, zero);</span><br><span class="line">        <span class="keyword">switch</span> ((childpid = fork())) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                err(<span class="number">1</span>, <span class="string">"fork"</span>);</span><br><span class="line">                <span class="comment">/* NOTREACHED */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                childpid = getpid();</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"PID %d:\tanonymous %s, zero-backed %s\n"</span>, childpid, anon, zero);</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"PID %d:\tanonymous %s, zero-backed %s\n"</span>, childpid, anon, zero);</span><br><span class="line">                munmap(anon, <span class="number">4096</span>);</span><br><span class="line">                munmap(zero, <span class="number">4096</span>);</span><br><span class="line">                <span class="built_in">close</span>(fd);</span><br><span class="line">                <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(anon, str2);</span><br><span class="line">        <span class="built_in">strcpy</span>(zero, str2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"PID %d:\tanonymous %s, zero-backed %s\n"</span>, parpid, anon, zero);</span><br><span class="line">        munmap(anon, <span class="number">4096</span>);</span><br><span class="line">        munmap(zero, <span class="number">4096</span>);</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PID 22475:      anonymous string 1, zero-backed string 1</span><br><span class="line">PID 22476:      anonymous string 1, zero-backed string 1</span><br><span class="line">PID 22475:      anonymous string 2, zero-backed string 2</span><br><span class="line">PID 22476:      anonymous string 2, zero-backed string 2</span><br></pre></td></tr></table></figure>

<p>主要作用是创建了两个匿名映射，父进程和子进程可以通过匿名映射来访问共享的内存。</p>
<p>mmap和munmap的架构如图所示，与<a href="/p/e84c7fac.html">上篇文章</a>中介绍的<strong>malloc()</strong>工作原理类似：</p>
<ul>
<li>应用程序通过libc的API <strong><em>mmap()</em></strong>和<strong><em>munmap()</em></strong>来创建和销毁映射</li>
<li>libc执行对应的系统调用SYS_mmap和SYS_munmap等</li>
<li><strong><em>mmap()</em></strong>，内核根据传入的地址，映射长度，文件信息进行<a href="/p/e84c7fac.html#VMA">VMA映射</a>的创建</li>
<li><strong><em>munmap()</em></strong>则根据地址信息进行VMA映射的删除</li>
</ul>
<p><img src="/images/posts/20211113/mmap.png" alt="mmap and munmap" title="mmap and munmap"></p>
<p>内核实现mmap的核心函数是<strong><em><a href="https://elixir.bootlin.com/linux/latest/source/mm/mmap.c#L1404" target="_blank" rel="noopener">do_mmap()</a></em></strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *populate, struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">.....................</span><br><span class="line">	<span class="keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))</span><br><span class="line">		<span class="keyword">if</span> (!(file &amp;&amp; path_noexec(&amp;file-&gt;f_path)))</span><br><span class="line">			prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* force arch specific MAP_FIXED handling in get_unmapped_area */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_FIXED_NOREPLACE)</span><br><span class="line">		flags |= MAP_FIXED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MAP_FIXED))</span><br><span class="line">		addr = round_hint_to_min(addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">	len = PAGE_ALIGN(len);</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* offset overflow? */</span></span><br><span class="line">	<span class="keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Too many mappings? */</span></span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">.........</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_NORESERVE) &#123;</span><br><span class="line">		<span class="comment">/* We honor MAP_NORESERVE if allowed to overcommit */</span></span><br><span class="line">		<span class="keyword">if</span> (sysctl_overcommit_memory != OVERCOMMIT_NEVER)</span><br><span class="line">			vm_flags |= VM_NORESERVE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* hugetlb applies strict overcommit unless MAP_NORESERVE */</span></span><br><span class="line">		<span class="keyword">if</span> (file &amp;&amp; is_file_hugepages(file))</span><br><span class="line">			vm_flags |= VM_NORESERVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">	    ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">	     (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">		*populate = len;</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要就是根据输入参数做一系列检查，并根据参数配置vm_flags，最终传入<strong><em>mmap_region()</em></strong>函数开始创建映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">mmap_region</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">vm_flags_t</span> vm_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>, *<span class="title">merge</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> charged = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check against address space limit. */</span></span><br><span class="line">	<span class="keyword">if</span> (!may_expand_vm(mm, vm_flags, len &gt;&gt; PAGE_SHIFT)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages;</span><br><span class="line">		nr_pages = count_vma_pages_range(mm, addr, addr + len);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!may_expand_vm(mm, vm_flags,</span><br><span class="line">					(len &gt;&gt; PAGE_SHIFT) - nr_pages))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clear old maps, set up prev, rb_link, rb_parent, and uf */</span></span><br><span class="line">	<span class="keyword">if</span> (munmap_vma_range(mm, addr, len, &amp;prev, &amp;rb_link, &amp;rb_parent, uf))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Private writable mapping: check memory availability</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (accountable_mapping(file, vm_flags)) &#123;</span><br><span class="line">		charged = len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		<span class="keyword">if</span> (security_vm_enough_memory_mm(mm, charged))</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		vm_flags |= VM_ACCOUNT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma = vma_merge(mm, prev, addr, addr + len, vm_flags,</span><br><span class="line">			<span class="literal">NULL</span>, file, pgoff, <span class="literal">NULL</span>, NULL_VM_UFFD_CTX);</span><br><span class="line">	<span class="keyword">if</span> (vma)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	vma = vm_area_alloc(mm);</span><br><span class="line">	<span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">		error = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> unacct_error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_start = addr;</span><br><span class="line">	vma-&gt;vm_end = addr + len;</span><br><span class="line">	vma-&gt;vm_flags = vm_flags;</span><br><span class="line">	vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</span><br><span class="line">	vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;</span><br><span class="line">			error = mapping_map_writable(file-&gt;f_mapping);</span><br><span class="line">			<span class="keyword">if</span> (error)</span><br><span class="line">				<span class="keyword">goto</span> free_vma;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vma-&gt;vm_file = get_file(file);</span><br><span class="line">		error = call_mmap(file, vma);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> unmap_and_free_vma;</span><br><span class="line"></span><br><span class="line">		WARN_ON_ONCE(addr != vma-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">		addr = vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If vm_flags changed after call_mmap(), we should try merge vma again</span></span><br><span class="line"><span class="comment">		 * as we may succeed this time.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(vm_flags != vma-&gt;vm_flags &amp;&amp; prev)) &#123;</span><br><span class="line">			merge = vma_merge(mm, prev, vma-&gt;vm_start, vma-&gt;vm_end, vma-&gt;vm_flags,</span><br><span class="line">				<span class="literal">NULL</span>, vma-&gt;vm_file, vma-&gt;vm_pgoff, <span class="literal">NULL</span>, NULL_VM_UFFD_CTX);</span><br><span class="line">			<span class="keyword">if</span> (merge) &#123;</span><br><span class="line">				<span class="comment">/* -&gt;mmap() can change vma-&gt;vm_file and fput the original file. So</span></span><br><span class="line"><span class="comment">				 * fput the vma-&gt;vm_file here or we would add an extra fput for file</span></span><br><span class="line"><span class="comment">				 * and cause general protection fault ultimately.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				fput(vma-&gt;vm_file);</span><br><span class="line">				vm_area_free(vma);</span><br><span class="line">				vma = merge;</span><br><span class="line">				<span class="comment">/* Update vm_flags to pick up the change. */</span></span><br><span class="line">				vm_flags = vma-&gt;vm_flags;</span><br><span class="line">				<span class="keyword">goto</span> unmap_writable;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vm_flags = vma-&gt;vm_flags;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm_flags &amp; VM_SHARED) &#123;</span><br><span class="line">		error = shmem_zero_setup(vma);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> free_vma;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vma_set_anonymous(vma);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allow architectures to sanity-check the vm_flags */</span></span><br><span class="line">	<span class="keyword">if</span> (!arch_validate_flags(vma-&gt;vm_flags)) &#123;</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (file)</span><br><span class="line">			<span class="keyword">goto</span> unmap_and_free_vma;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">goto</span> free_vma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">	<span class="comment">/* Once vma denies write, undo our temporary denial count */</span></span><br><span class="line">unmap_writable:</span><br><span class="line">	<span class="keyword">if</span> (file &amp;&amp; vm_flags &amp; VM_SHARED)</span><br><span class="line">		mapping_unmap_writable(file-&gt;f_mapping);</span><br><span class="line">	file = vma-&gt;vm_file;</span><br><span class="line">out:</span><br><span class="line">	perf_event_mmap(vma);</span><br><span class="line"></span><br><span class="line">	vm_stat_account(mm, vm_flags, len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">	<span class="keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((vm_flags &amp; VM_SPECIAL) || vma_is_dax(vma) ||</span><br><span class="line">					is_vm_hugetlb_page(vma) ||</span><br><span class="line">					vma == get_gate_vma(current-&gt;mm))</span><br><span class="line">			vma-&gt;vm_flags &amp;= VM_LOCKED_CLEAR_MASK;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file)</span><br><span class="line">		uprobe_mmap(vma);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * New (or expanded) vma always get soft dirty status.</span></span><br><span class="line"><span class="comment">	 * Otherwise user-space soft-dirty page tracker won't</span></span><br><span class="line"><span class="comment">	 * be able to distinguish situation when vma area unmapped,</span></span><br><span class="line"><span class="comment">	 * then new mapped in-place (which must be aimed as</span></span><br><span class="line"><span class="comment">	 * a completely new data area).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	vma-&gt;vm_flags |= VM_SOFTDIRTY;</span><br><span class="line">	vma_set_page_prot(vma);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>mmap_region()</em></strong>函数的实现也比较简单，这里不做过多解释。值得注意的是：如果传入的文件为空，则表示创建匿名映射。若连共享标记VM_SHARED也未指定，则与使用malloc()分配内存相同，仅为对应虚拟地址创建内存映射。</p>
<p><strong><em>munmap()</em></strong>的内核实现仅为移除对应VMA映射，本文也不再做分析。</p>
<h2 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h2><p><a href="https://lwn.net/Articles/23732/" target="_blank" rel="noopener">反向映射</a>的作用是给定物理页面，找到与其对应的所有进程的VMA。为什么会有这样的查找呢？这是因为所有进程的虚拟内存总大小往往远大于物理内存，为了支撑Linux系统的有效运作，内核在管理内存时，会将暂时不用的物理内存页换出到磁盘上，在有需要时再换入到内存中。</p>
<p>这种情况下，如何确定该物理内存有哪些进程正在使用？这便需要反向映射。</p>
<p>系统中内存页很多，在管理反向映射时，即使引入很小的数据结构，也会带来很大的额外内存开销。同时，因为反向映射使用比较频繁，也需要最优化查找效率，避免成为系统瓶颈。</p>
<p>回顾一下<strong><em>struct page</em></strong>，为了节省管理开销，其定义了很多联合体。其中与逆向映射有关的储存在mapping，_mapcount，index等成员中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">			 * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">			 * by the page owner.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">			<span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">			<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">			 * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">			 * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">			 * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">.............</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment">		 * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> active;		<span class="comment">/* SLAB */</span></span><br><span class="line">		<span class="keyword">int</span> units;			<span class="comment">/* SLOB */</span></span><br><span class="line">	&#125;;</span><br><span class="line">.............</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>

<p><a href="https://lwn.net/Articles/23732/" target="_blank" rel="noopener">内核文档</a>对这种映射有个直观的描述如下图:</p>
<p><img src="https://static.lwn.net/images/ns/ormap.png" alt="反向映射图示" title="反向映射图示"></p>
<p>简单一点讲：物理页结构体<strong><em>struct page</em></strong>使用<strong><em>mapping</em></strong>成员查找所有该页对应的VMA，从而找到所有正在使用该物理页的虚拟页。</p>
<p>mapping成员查找VMA的方法并非如上图那样容易理解。实际需要考虑很多情况，因此内核设计了如下数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The anon_vma heads a list of private "related" vmas, to scan if</span></span><br><span class="line"><span class="comment"> * an anonymous page pointing to this anon_vma needs to be unmapped:</span></span><br><span class="line"><span class="comment"> * the vmas on the list will be related by forking, or by splitting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since vmas come and go as they are split and merged (particularly</span></span><br><span class="line"><span class="comment"> * in mprotect), the mapping field of an anonymous page cannot point</span></span><br><span class="line"><span class="comment"> * directly to a vma: instead it points to an anon_vma, on whose list</span></span><br><span class="line"><span class="comment"> * the related vmas can be easily linked or unlinked.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After unlinking the last vma on the list, we must garbage collect</span></span><br><span class="line"><span class="comment"> * the anon_vma object itself: we're guaranteed no page can be</span></span><br><span class="line"><span class="comment"> * pointing to this anon_vma once its vma list is empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">root</span>;</span>		<span class="comment">/* Root of this anon_vma tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span>	<span class="comment">/* W: modification, R: walking the list */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> refcount;</span><br><span class="line">	<span class="keyword">unsigned</span> degree;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">parent</span>;</span>	<span class="comment">/* Parent of this anon_vma */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span> <span class="title">rb_root</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The copy-on-write semantics of fork mean that an anon_vma</span></span><br><span class="line"><span class="comment"> * can become associated with multiple processes. Furthermore,</span></span><br><span class="line"><span class="comment"> * each child process will have its own anon_vma, where new</span></span><br><span class="line"><span class="comment"> * pages for that process are instantiated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This structure allows us to find the anon_vmas associated</span></span><br><span class="line"><span class="comment"> * with a VMA, or the VMAs associated with an anon_vma.</span></span><br><span class="line"><span class="comment"> * The "same_vma" list contains the anon_vma_chains linking</span></span><br><span class="line"><span class="comment"> * all the anon_vmas associated with this VMA.</span></span><br><span class="line"><span class="comment"> * The "rb" field indexes on an interval tree the anon_vma_chains</span></span><br><span class="line"><span class="comment"> * which link all the VMAs associated with this anon_vma.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">anon_vma_chain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">same_vma</span>;</span>   <span class="comment">/* locked by mmap_lock &amp; page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span>			<span class="comment">/* locked by anon_vma-&gt;rwsem */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_VM_RB</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cached_vma_start, cached_vma_last;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上，数据结构定义有描述为什么需要这样的数据结构而不是直接由mapping指向vma_area_struct。即：vm_area_struct可能会被合并、拆分等。</p>
<p>下图描述了当fork一个新进程时，反向映射相关字段的变化状况。</p>
<ul>
<li>Fork新进程会将每个VM area(vm_area_struct)进行复制</li>
<li>将每一个VM area的anon_vma_chain链表的anon_vma_chain进行复制，并与父进程的anon_vma关联</li>
<li>对每个VM area，创建新的anon_vma和anon_vma_chain，与父进程的anon_vma关联</li>
</ul>
<p>这样的关联建立起来后，通过物理页结构体struct page就可以查找到所有的关联VM area。</p>
<p><img src="/images/posts/20211113/mmap2.png" alt="反向映射数据结构关系" title="反向映射数据结构关系"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文概要介绍了mmap和反向映射的原理。</p>
<ul>
<li>mmap主要用于用户空间态进程映射一段虚拟地址，用以共享、分配内存或者使用访问内存的方式来访问文件节点。</li>
<li>反向映射用于内核查找一个物理页面对应的所有虚拟地址，以便系统换页时使用。</li>
</ul>
<p>内存管理系统内容纷繁，也是内核工作者集体智慧的结晶，笔者在理解时不免有遗失或者偏差之处。如您有问题或者建议，请留言提出讨论。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>进程内存</tag>
      </tags>
  </entry>
  <entry>
    <title>30岁了</title>
    <url>/p/b7236e5.html</url>
    <content><![CDATA[<p>跨过人生一个10年，工作6年，结婚2年半 希望可以顺利达成对未来生活的期望 [改变]</p>
<ul>
<li>戒除熬夜等不良习惯</li>
<li>坚持锻炼</li>
<li>保持良好的心态</li>
<li>继续拼搏</li>
<li>坚持理财，学会买保险</li>
</ul>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>Linux内核内存管理 - 缺页异常处理</title>
    <url>/p/db78840c.html</url>
    <content><![CDATA[<blockquote>
<p> 这是&lt;Linux内核内存管理&gt;系列的第八篇:</p>
<blockquote>
<p><a href="/p/61304bbb.html">第一篇</a>为内核内存管理过程知识点的的简单梳理</p>
<p><a href="/p/1dc6adc2.html">第二篇</a>介绍了内核的数据结构</p>
<p><a href="/p/8f5117c5.html">第三篇</a>介绍了从内核第一行代码加载到跳转到C代码前的内存处理。</p>
<p><a href="/p/94b22c5d.html">第四篇</a>概览了初始化C代码中的内存处理</p>
<p><a href="/p/20210923linuxmm4.html">第五篇（上）</a>和<a href="/p/5347665a.html">第五篇（下）</a>介绍了Memblock和伙伴系统分配器</p>
<p><a href="/p/75308136.html">第六篇</a>介绍了内存检测工具KFence工作原理</p>
<p><a href="/p/e84c7fac.html">第七篇</a>介绍了进程内存分配malloc的原理</p>
<p><a href="/p/8cc7cf15.html">第八篇</a>介绍了MMAP映射和反向映射原理</p>
</blockquote>
</blockquote><a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Page Fault（缺页异常）大概是最为常见的异常，它发生在CPU访问不在内存的页时。本文以Intel IA32体系结构为例，介绍Linux对缺页异常的处理过程。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2>]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内存管理</tag>
        <tag>进程内存</tag>
      </tags>
  </entry>
  <entry>
    <title>小米手表使用ADB安装应用</title>
    <url>/p/2639ab6d.html</url>
    <content><![CDATA[<p>一直想入手一个智能手表，可惜Apple Watch需要连接苹果手机，遂未能如愿。最近小米终于发布一款智能手表，支持ESIM，使用Wear OS，果断入手。  </p><p>实际使用发现Bug不少，软件不多。Bug可以等系统更新来解决。不过软件不多是生态链的问题，等生态链慢慢建起来实在太慢。Wear OS是Android的一个分支，理论上应该支持安装安卓应用才对。翻了下小米手表的设置，也是有看到可以做ADB调试，因此理应可以用ADB安装Android应用。  </p><a id="more"></a>

<p>步骤：</p>
<ol>
<li>电脑上安装ADB（可根据您自己的电脑系统自行百度安装方法）</li>
<li>手表上“设置–开发者选项”，打开ADB调试。如图：<br><img src="http://pic.l2h.site/xiaomiwatch1.jpg" alt="开启ADB调试"></li>
<li>将手表连上充电底座，并将USB连接电源插头端直接连上电脑。如图：<br><img src="http://pic.l2h.site/xiaomiwatch2.jpg" alt="连接电脑"></li>
<li>连上电脑后，手表弹出“是否允许调试”选择框。直接选择允许或者始终允许。<br><img src="http://pic.l2h.site/xiaomiwatch3.jpg" alt="允许调试"></li>
<li>电脑端执行ADB Install安装应用,待显示成功，便安装完成。例如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb install qqmail_android_5.7.1.10141908.2480_0.apk</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>手表内存小，APK程序越大，其所需的内存越大。因此尽量选择程序本身小于10MB的程序</li>
<li>大部分APP并未针对小屏幕做优化，目前提供方法和思路供试用。如上例子QQMAIL安装后就因其无法支持手表屏幕大小，因此无法做有效操作。</li>
</ol>
<p>最后，收集可支持手表的应用如下：</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>版本</th>
<th>APK下载链接</th>
</tr>
</thead>
</table>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>小米手表</tag>
      </tags>
  </entry>
  <entry>
    <title>AirbNb有中文名啦</title>
    <url>/p/7cf0353c.html</url>
    <content><![CDATA[<p><img src="http://www.l2h.site/wp-content/uploads/2017/03/airbnb.png" alt> 一直对Airbnb蛮有好感度的，心里也默认为境外出游的首选。 最早L&amp;H’s Site也有上线到AbNb准备接待世界各地的客人，但由于考虑到房东打款方式过于繁琐，便又做了下线。 听闻AbNb为了进一步开拓中国市场，近日为自己起了个本土化的名字 – 爱彼迎。应该是想表达“让爱彼此相迎“的意思吧。 不过仔细读一读，“二饼”，Hin本土化啊，和成都Hin搭啊 :mrgreen: 。 去看了下房东打款，还不支持支付宝或者微信，看来还是要再等一等咯！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
      <tags>
        <tag>abnb</tag>
        <tag>airbnb</tag>
        <tag>爱彼迎</tag>
      </tags>
  </entry>
  <entry>
    <title>关于面试</title>
    <url>/p/c1e5aec7.html</url>
    <content><![CDATA[<p>翻到8年前自己写过一篇文章《<a href="https://www.l2h.site/2010/11/19/%E7%AC%94%E8%AF%95%E5%90%8E%E7%9A%84%E9%84%99%E8%A7%86/" target="_blank" rel="noopener">笔试后的鄙视</a>》，写了自己面试Intel的一些简单感受。当时做的总结是，“linux和内核一定学好”，没想到一语成箴，最近还苦苦奋斗在Linux平台和学习内核的路上。有幸跟着部门做了三年校招，且加上最近因为公司项目需要，自己也有面试过20个左右第三方人力公司推荐的程序员。面试成功的进入到部门工作的人中，也有少数半年后成功转正为公司同事。突然又想写写面试。从公司角度上看，面试到底在面什么？因为所写内容跟个人所面试的人群有关（多为Juniors），因此仅代表个人站在公司角度上看到的状况：</p><a id="more"></a>
<h2 id="基本技术"><a href="#基本技术" class="headerlink" title="基本技术"></a>基本技术</h2><p>这里说的基本技术，不见得要求被面试者一定要是某个领域的大牛。但是起码具有基本的编程、调试、Debug以及更进阶一点的架构设计能力。同样的C语言面试题，个人有面过有些被面试者短时间内写完调通，而且有各种容错检查；也有面过写不出来、逻辑思维混乱，或者勉强写出但是漏洞百出的。这直接能体现出被面试者实际代码量、思维方式。我们显然希望和具有更多代码经验，或者至少思维逻辑清晰的人合作。</p>
<p>从技术考察角度讲，不要试图去美化简历。简历上任何的“熟练”、“精通”，都不会抵过面试中一道简单的技术题，要知道只要不是特别水的面试官，一定能考察出您的“熟练”是真是假。</p>
<h2 id="工作能力"><a href="#工作能力" class="headerlink" title="工作能力"></a>工作能力</h2><p>工作能力则常常体现在个人的做事习惯上：当碰到问题的时候，是否有独立解题的能力，深入思考的习惯。</p>
<p>例如：您在经历的项目中有碰到过什么样具体的技术难题，您是怎么解决的？你的思路是什么？这样的问题展开，可以得出您对项目的真正了解程度、您的工作模式是倾向于自己解决问题还是找人帮忙甚至放过问题（这就是后边也会提到的责任心的部分了）。</p>
<p>个人碰到过的有些面试者，用搜索解决了工作中碰到的问题。但是问其原因，也不知所以然。这种快速搜索快速解决问题的能力固然很好，但是没有去抓问题的根源，或者没有去深入思考问题的本质，显然就没有做到技术的积累。之后的工作中，很有可能还会写出有同样问题的代码，显然总体上还是造成了个人的低工作效率，对团队造成影响。</p>
<h2 id="理解能力与表达能力"><a href="#理解能力与表达能力" class="headerlink" title="理解能力与表达能力"></a>理解能力与表达能力</h2><p>个人以为沟通成本其实是大公司大项目中最大的成本之一。如何清楚地理解他人的问题，以及简单有效地表达您要表达的问题，尤为关键。 理解能力和表达能力在团队项目中非常重要，甚至超过了技术部分。因为这技术毕竟通过积累可以增长，而沟通能力则是多年以来形成的习惯较难变化。</p>
<p>有的朋友可能技术上比较过关，但是表达啰嗦，很难Get到对方的点子，这种在后续的工作中也会浪费大量的时间在沟通上，进而浪费掉的是项目成本。</p>
<h2 id="学习能力"><a href="#学习能力" class="headerlink" title="学习能力"></a>学习能力</h2><p>学习能力其实也算是工作能力的一种。给您设定时间，一个新的领域，需要您可以<br>快速整理学习脉络，深入进去。</p>
<p>这类能力，面试时往往会从您的过往生活学习工作的经历中判断出。</p>
<h2 id="责任心"><a href="#责任心" class="headerlink" title="责任心"></a>责任心</h2><p>责任心是职场中人人都该具有的基本素质。生活中没人喜欢不负责任的人， 工作中更不例外。个人承诺的时间一定要达到，个人负责的模块一定会做好，这样才是老板同事都喜欢的人。</p>
<p>而责任心也一样，往往能从您个人历史工作学习经历中得出。我个人比较喜欢的一个从其他地方得到的问题：“您如何知道每天自己要做什么事情”。这题考察的就是您对工作的了解程度，对项目的熟悉度，间接就考察了个人的责任心。当然也考察的出个人工作习惯（甚至被面试者过往所在团队的成熟度）。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>个人比较倾向的其他的一些要考察的内容，例如个人的生活态度、前个工作离职原因、兴趣爱好等等，暂不做表，先到这里。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>支付宝推出“相互保”</title>
    <url>/p/160b18fb.html</url>
    <content><![CDATA[<p>![支付宝推出“相互保”](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-18 下午9.52.50.png “支付宝推出“相互保””) 支付宝蚂蚁保险和信美联合推出了“相互保”，10月16号上线，满足650芝麻积分即可参加。不用投入高额的保险费用，获得包括恶性肿瘤在内的100种大病保障，当参与成员有人患病时，大家共同帮助，参与费用分摊，如果自身不幸患病，也可一次性领取10万元或30万元不等的治疗费用。看到支付宝的推送，推荐一下 :-) 。 具体使用规则如下： <img src="http://pic.l2h.site/l2hsiteu=1277544735,3268155278&fm=173&app=25&f=JPEG.jpeg" alt="支付宝推出“相互保”" title="支付宝推出“相互保”"></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
      <tags>
        <tag>相互宝</tag>
      </tags>
  </entry>
  <entry>
    <title>BBC迷你剧《新福尔摩斯》</title>
    <url>/p/9772cc0b.html</url>
    <content><![CDATA[<p>非常喜欢英式的英语发音，最近在家里闲得，碰巧看到这部迷你剧的介绍。就下来看，第一集还没看完就喜欢上了，相当的精彩。强烈推荐，现在只出了第一季的三集。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>再见,2017.</title>
    <url>/p/1a97178c.html</url>
    <content><![CDATA[<p>2017，似乎并不顺利，但也顺利完成了难忘的婚礼。 2018，希望一切都好，一切都顺！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>再见，潘帕斯雄鹰</title>
    <url>/p/2fc12a62.html</url>
    <content><![CDATA[<p>已经尽力了。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>网站被黑了</title>
    <url>/p/eb0e5eb.html</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>上班无暇照料网站，今天XH发微信说网站登录不上了。打开一看，居然被重定位到了一些不可描述页面：</p><p><img src="http://pic.l2h.site/webwxgetmsgimg-512x1024.png" alt></p><h2 id="问题查找经过"><a href="#问题查找经过" class="headerlink" title="问题查找经过"></a>问题查找经过</h2><p>首先分别做了以下检查：</p><ul>
<li>登录阿里云后台查看域名解析，不存在被改写情况</li>
<li>登录到服务器查找主题页面被修改情况，也未见修改</li>
<li>修改数据库，禁用所有插件，并删除掉所有页面缓存，仍热有此问题</li>
</ul><p>后来根据重定向到的页面 setforconfigplease.com，到万能的Google找到了问题原因</p><a id="more"></a>




<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>简言之，网站的如下两个设定直接被改写成了黑客想要重定向的页面。</p>
<p><img src="http://pic.l2h.site/Image-2.png" alt></p>
<p>个人后台密码一直设置的非常严，且数据库也保护较好，为何会有设定被改的现象？Google说，最新的Easy WP SMTP插件有权限检查不严漏洞，导致普通用户可以构造攻击数据来改写WP_OPTION。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span> $is_import_settings = filter_input( INPUT_POST, <span class="string">'swpsmtp_import_settings'</span>, FILTER_SANITIZE_NUMBER_INT );</span><br><span class="line"><span class="number">302</span> <span class="keyword">if</span> ( $is_import_settings ) &#123;</span><br><span class="line"><span class="number">303</span> $err_msg = __( <span class="string">'Error occurred during settings import'</span>, <span class="string">'easy-wp-smtp'</span> );</span><br><span class="line"><span class="number">304</span> <span class="keyword">if</span> ( <span class="keyword">empty</span>( $_FILES[ <span class="string">'swpsmtp_import_settings_file'</span> ] ) ) &#123;</span><br><span class="line"><span class="number">305</span> <span class="keyword">echo</span> $err_msg;</span><br><span class="line"><span class="number">306</span> wp_die();</span><br><span class="line"><span class="number">307</span> &#125;</span><br><span class="line"><span class="number">308</span> $in_raw = file_get_contents( $_FILES[ <span class="string">'swpsmtp_import_settings_file'</span> ][ <span class="string">'tmp_name'</span> ] );</span><br><span class="line"><span class="number">309</span> <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">310</span>    $in = unserialize( $in_raw );</span><br><span class="line"><span class="number">311</span>   <span class="keyword">if</span> ( <span class="keyword">empty</span>( $in[ <span class="string">'data'</span> ] ) ) &#123;</span><br><span class="line"><span class="number">312</span>       <span class="keyword">echo</span> $err_msg;</span><br><span class="line"><span class="number">313</span>       wp_die();</span><br><span class="line"><span class="number">314</span>  &#125;</span><br><span class="line"><span class="number">315</span>   <span class="keyword">if</span> ( <span class="keyword">empty</span>( $in[ <span class="string">'checksum'</span> ] ) ) &#123;</span><br><span class="line"><span class="number">316</span>     <span class="keyword">echo</span> $err_msg;</span><br><span class="line"><span class="number">317</span>      wp_die();</span><br><span class="line"><span class="number">318</span>   &#125;</span><br><span class="line"><span class="number">319</span>  <span class="keyword">if</span> ( md5( $in[ <span class="string">'data'</span> ] ) !== $in[ <span class="string">'checksum'</span> ] ) &#123;</span><br><span class="line"><span class="number">320</span>       <span class="keyword">echo</span> $err_msg;</span><br><span class="line"><span class="number">321</span>     wp_die();</span><br><span class="line"><span class="number">322</span>  &#125;</span><br><span class="line"><span class="number">323</span>  $data = unserialize( $in[ <span class="string">'data'</span> ] );</span><br><span class="line"><span class="number">324</span>  <span class="keyword">foreach</span> ( $data <span class="keyword">as</span> $key =&gt; $value ) &#123;</span><br><span class="line"><span class="number">325</span>  update_option( $key, $value );</span><br><span class="line"><span class="number">326</span>  &#125;</span><br><span class="line"><span class="number">327</span>  set_transient( <span class="string">'easy_wp_smtp_settings_import_success'</span>, <span class="keyword">true</span>, <span class="number">60</span> * <span class="number">60</span> );</span><br><span class="line"><span class="number">328</span>  $url = admin_url() . <span class="string">'options-general.php?page=swpsmtp_settings'</span>;</span><br><span class="line"><span class="number">329</span>   wp_safe_redirect( $url );</span><br><span class="line"><span class="number">330</span>   <span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure>

<p>黑客正是如此更改了我的网站URL，导致访问被重定向到了他们指定的网址。</p>
<p>不仅如此，网站设置中的“允许用户注册”选项也被如此改写，而且被改成了用户注册默认即是管理员。这我才想起前两天收到邮件推送一个怪怪的新用户注册的邮件，由于当时正在工作给忽略了。T_T</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol>
<li>使用数据库命令先删除掉Easy WP SMTP插件（避免再次被人利用）</li>
<li>使用数据库命令更改siteurl和home回自己的网址<a href="https://www.l2h.site,此时就可以正常登录网站了" target="_blank" rel="noopener">https://www.l2h.site,此时就可以正常登录网站了</a><ul>
<li>注意你的网站如果启用了cache，需要先到后台删除例如autoptimize和wp super cache保存的cache</li>
<li>如果你的数据库开启了redis缓存，也要清空redis缓存</li>
</ul>
</li>
<li>到后台设置–&gt;常规里，禁用掉新用户注册，以及更改新注册用户默认身份为普通身份</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以往对网站插件更新都非常勤快，觉得使用最新的就是最好。不过这次经历告诉自己，能不要更新就不要更新，除非有非用不可的功能。害得自己今晚很喜欢的健身课都没去上。以上。</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title>L&amp;H的重庆小游--四川美术学院</title>
    <url>/p/6dc70651.html</url>
    <content><![CDATA[<p><a href="https://dimg05.c-ctrip.com/images/100a0l000000co6w36904_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/100a0l000000co6w36904_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg01.c-ctrip.com/images/100d0l000000cn5vz7DF3_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg01.c-ctrip.com/images/100d0l000000cn5vz7DF3_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg02.c-ctrip.com/images/100s0l000000ctqby356A_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg02.c-ctrip.com/images/100s0l000000ctqby356A_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg07.c-ctrip.com/images/100j0l000000co98m93DF_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg07.c-ctrip.com/images/100j0l000000co98m93DF_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg06.c-ctrip.com/images/10050l000000cphpd63CC_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/10050l000000cphpd63CC_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg07.c-ctrip.com/images/10040l000000cnh4f5A67_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg07.c-ctrip.com/images/10040l000000cnh4f5A67_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg02.c-ctrip.com/images/10050l000000cphp229BB_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg02.c-ctrip.com/images/10050l000000cphp229BB_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg09.c-ctrip.com/images/100k0l000000cpyanB6FF_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="http://pages.c-ctrip.com/gs_static/common/img/1x1.gif" alt></a></p>
<p><a href="https://dimg07.c-ctrip.com/images/100q0l000000cpt04D9D3_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg07.c-ctrip.com/images/100q0l000000cpt04D9D3_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg05.c-ctrip.com/images/100a0l000000co635B07F_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/100a0l000000co635B07F_R_800_10000_Q90.jpg" alt></a></p>
<p><img src="https://dimg02.c-ctrip.com/images/100k0l000000cpyanB6FF_R_800_10000.jpg" alt></p>
<p><a href="https://dimg06.c-ctrip.com/images/100q0l000000cpt8uEBD1_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/100q0l000000cpt8uEBD1_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg05.c-ctrip.com/images/100p0l000000cn847DB8B_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/100p0l000000cn847DB8B_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg06.c-ctrip.com/images/100k0l000000cpzge4D62_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/100k0l000000cpzge4D62_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg07.c-ctrip.com/images/100q0l000000cpu5s1294_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg07.c-ctrip.com/images/100q0l000000cpu5s1294_R_800_10000_Q90.jpg" alt></a><a href="https://dimg09.c-ctrip.com/images/10010l000000cycnvABCC_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg09.c-ctrip.com/images/10010l000000cycnvABCC_R_800_10000_Q90.jpg" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>四川美术学院</tag>
        <tag>川美</tag>
        <tag>重庆</tag>
      </tags>
  </entry>
  <entry>
    <title>久违了！</title>
    <url>/p/7b6ae9e6.html</url>
    <content><![CDATA[<p>最近更新较少，回访可能也不太及时。趁现在国庆放假，得几日闲时，所以写篇关于近日的总结性文字。 最近投简历，参加笔试面试，参加的头都大了。参加华赛二面被刷，参加腾讯一面被刷。还好节前这个华为走到了最后，等待通知。 这段时间深刻意识到自己的知识虽然掌握的广，却都不精通，基础欠佳带来的切肤之痛。所以，打算这个国庆不出去玩，认真看下书。仔细思考下下个阶段要做的事情。迎来国庆节过后新一轮的疯狂。所以，同志们，朋友们，祝福我。祝福你们 By the way，节日快乐！！！ 这个小地方我打算一直经营下去，所以我真心希望可以和每个到来的大家做朋友！！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>L&amp;H的重庆小游 -- 下浩</title>
    <url>/p/5952ce39.html</url>
    <content><![CDATA[<p><a href="https://dimg02.c-ctrip.com/images/100a0l000000cot10875F_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg02.c-ctrip.com/images/100a0l000000cot10875F_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg03.c-ctrip.com/images/100p0l000000cnpfy1ECF_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg03.c-ctrip.com/images/100p0l000000cnpfy1ECF_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg09.c-ctrip.com/images/100s0l000000cucksC836_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg09.c-ctrip.com/images/100s0l000000cucksC836_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg06.c-ctrip.com/images/10030l000000cqwj795AD_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/10030l000000cqwj795AD_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg05.c-ctrip.com/images/100k0l000000cqg59FF8C_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/100k0l000000cqg59FF8C_R_800_10000_Q90.jpg" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>重庆</tag>
        <tag>下浩老街</tag>
      </tags>
  </entry>
  <entry>
    <title>今.呵</title>
    <url>/p/dd4d20e1.html</url>
    <content><![CDATA[<p>今天是11.11号，好事的人给它赋予了一个神圣的名字：光棍节。 早上起床，收到一条短信，内容是祝我节日快乐。无奈。有人说:如果兄弟是手足，女友是衣服，那么我就是七手八脚地裸奔了19年。 呵呵，简直就是在揭我的短嘛。 一如既往地：我踟蹰，我努力，我追求，我放浪，我疯狂。 迷失？玩笑。 “夫天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为。”我做过什么，我得到了什么，我又失去了什么。没有付出我凭什么渴望回报？ 不知道是不是今天又是一顿聚餐，几瓶酒，几支歌呢？每次都仿佛在期待某个时刻一样的虔诚。是吗？不是吗？ 喜欢写完东西码标题，我今天试下，呵呵。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始爬草榴成人文学 (2) – 分析</title>
    <url>/p/6ca19b1d.html</url>
    <content><![CDATA[<p><a href="https://www.l2h.site/2019/07/08/scrapy%e7%88%ac%e5%8f%96%e8%8d%89%e6%a6%b4%e6%88%90%e4%ba%ba%e6%96%87%e5%ad%a6%e5%88%97%e8%a1%a8%e5%b9%b6%e5%88%86%e6%9e%90-1-%e7%88%ac%e5%8f%96/" target="_blank" rel="noopener">前文</a>介绍了Scrapy爬取CL的成人文学区文章列表，本文介绍如何进行一些简单的数据分析。本文为分析过程中记录的交互式笔记。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文对X榴成人文学区抓取文章标题2000条信息进行分析.抓取的数据格式为：</p><ul>
<li>lit_type</li>
<li>lit_title</li>
<li>lit_url</li>
<li>lit_writer</li>
<li>lit_submit</li>
<li>lit_comments</li>
<li>lit_last_comments</li>
</ul><a id="more"></a>


<p>存储在MongoDB实验云存储上。 使用pymongo前安装</p>
<blockquote>
<p>pip install pymongo dnspython</p>
</blockquote>
<p>先导入必要的库，并对画图做一些基本的配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> pandas.io.json <span class="keyword">import</span> json_normalize</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">plt.rc(<span class="string">'figure'</span>, figsize=(<span class="number">15</span>, <span class="number">15</span>))  <span class="comment">#把plt默认的图片size调大一点</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>&#125; = [<span class="string">'SimSun'</span>&#125;</span><br><span class="line">plt.rcParams[<span class="string">'font.serif'</span>&#125; = [<span class="string">'SimSun'</span>&#125;</span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>&#125; = <span class="literal">False</span></span><br><span class="line">plt.rcParams[<span class="string">"figure.dpi"</span>&#125; = <span class="literal">False</span> <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>

<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>从数据库中读取所有的文章数据，并格式化到<a href="https://pandas.pydata.org/" target="_blank" rel="noopener">Pandas</a>的DataFrame里</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = pymongo.MongoClient(<span class="string">"mongodb+srv://用户名:密码@xxxx.mongodb.net/test?retryWrites=true&amp;w=majority"</span>)</span><br><span class="line">db = client[<span class="string">'t66y'</span>&#125;</span><br><span class="line">sheets = db[<span class="string">'main'</span>&#125;</span><br><span class="line">data = sheets.find()</span><br><span class="line">items = pd.DataFrame(list(data))</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>对数据做一些筛选处理，前20个数据应该是网站的公告，丢掉了事。另外将一些文本格式的日期形式做一下转换，转换为datetime格式，将评论数量转换为数字格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items.drop([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">21</span>)&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line">items[<span class="string">'lit_submit'</span>&#125; = pd.to_datetime(items[<span class="string">'lit_submit'</span>&#125;)</span><br><span class="line">items[<span class="string">'lit_comments'</span>&#125; = pd.to_numeric(items[<span class="string">'lit_comments'</span>&#125;)</span><br><span class="line">items[<span class="string">'lit_title'</span>&#125; = items[<span class="string">'lit_title'</span>&#125;.str.strip()</span><br></pre></td></tr></table></figure>

<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>做完以上数据转化后我们简单做一些分析，首先看一下哪个作者是最高产的？原理是“东京热”网友</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items[<span class="string">'lit_writer'</span>&#125;.value_counts().head(<span class="number">20</span>).plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.09.png" alt></p>
<p>哪个时间段发布和评论小黄文最集中？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items[<span class="string">'lit_submit'</span>&#125;.value_counts().plot(kind=<span class="string">'line'</span>,subplots=<span class="literal">False</span>)</span><br><span class="line">items[<span class="string">'lit_last_comments'</span>&#125;.value_counts().plot(kind=<span class="string">'line'</span>,subplots=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.23.png" alt></p>
<p>评论看最热文章？可以看出连载文章是评率最多的，也许是因为作者用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items_title_idxed = items.set_index(<span class="string">'lit_title'</span>).sort_values(by=<span class="string">'lit_comments'</span>,ascending=<span class="literal">False</span>).head(<span class="number">10</span>)</span><br><span class="line">items_title_idxed[<span class="string">'lit_comments'</span>&#125;.plot(kind=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-08-%E4%B8%8B%E5%8D%883.35.50.png" alt></p>
<p>以上就是一些简单的分析。这些数据还可以做哪些分析？或许可以用自然语言处理的一些工具做如下处理</p>
<ul>
<li>哪类文章最受欢迎？</li>
<li>哪类文章创作率最高？</li>
<li>能不能自己创作小黄文？</li>
</ul>
<p>待续……</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>草榴</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始爬草榴成人文学 (3) – 聚类和PCA</title>
    <url>/p/15b089fb.html</url>
    <content><![CDATA[<p>本文继续上一章对爬到的数据按照文章标题进行分析。</p><p>首先使用结巴分词对爬到的标题进行分词，得到分词过后的带空格的标题</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg <span class="comment">#引入词性标注接口 </span></span><br><span class="line"><span class="keyword">import</span> codecs,sys</span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_titles</span><span class="params">(df)</span>:</span></span><br><span class="line">    strs = <span class="string">' '</span>.join(jieba.cut(df[<span class="string">'lit_title'</span>&#125;,cut_all=<span class="literal">False</span>))</span><br><span class="line">    <span class="keyword">return</span> strs</span><br><span class="line">  </span><br><span class="line">items[<span class="string">'split_title'</span>&#125; = items.apply(<span class="keyword">lambda</span> r: split_titles(r), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>接着使用TF-IDF按照标题产生每个标题对应的TFIDF向量（因为字典并不大，可以用来作为该标题的嵌入，参考<a href="https://www.l2h.site/2019/07/19/word-embedding-model/" target="_blank" rel="noopener">本博文章</a>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_extraction  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer  </span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer  </span><br><span class="line"></span><br><span class="line">corpus = items[<span class="string">'split_title'</span>&#125;.tolist()<span class="comment">#将文章标题视作TF-IDF的语料</span></span><br><span class="line">vectorizer=CountVectorizer()<span class="comment">#该类会将文本中的词语转换为词频矩阵，矩阵元素a[i&#125;[j&#125; 表示j词在i类文本下的词频  </span></span><br><span class="line">transformer=TfidfTransformer()<span class="comment">#该类会统计每个词语的tf-idf权值  </span></span><br><span class="line">tfidf=transformer.fit_transform(vectorizer.fit_transform(corpus))<span class="comment">#第一个fit_transform是计算tf-idf，第二个fit_transform是将文本转为词频矩阵  </span></span><br><span class="line">weight=tfidf.toarray()<span class="comment">#将tf-idf矩阵抽取出来，元素a[i&#125;[j&#125;表示j词在i类文本中的tf-idf权重</span></span><br></pre></td></tr></table></figure>

<p>对TFIDF嵌入处理后的向量进行PCA降维（降至2维，方便绘图）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">new_df = pd.DataFrame(weight)</span><br><span class="line">cls=KMeans(n_clusters=<span class="number">2</span>).fit(new_df)</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">new_pca = pd.DataFrame(pca.fit_transform(new_df), columns=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.scatter(new_pca[<span class="string">'A'</span>&#125;, new_pca[<span class="string">'B'</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-19-%E4%B8%8B%E5%8D%883.49.09.png" alt></p>
<p>按标题聚类并PCA降维后的文章分布</p>
<p>上图可以看出，有两类文章偏离较远，我们可以看看是什么文章：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list(new_pca[new_pca[<span class="string">'B'</span>&#125;&gt;<span class="number">0.6</span>&#125;.index):</span><br><span class="line">    new_items = items.reset_index()</span><br><span class="line">    print(new_items[<span class="string">'lit_title'</span>&#125;[i&#125;)</span><br></pre></td></tr></table></figure>

<p>打印这些一类文章的标题后我们发现，这是两篇文章被按照章节写成多篇了。</p>
<p>除此之外，还可以做什么？</p>
<ul>
<li>我们的语料库是文章标题本身，内容有限，分类其实是按照标题自身进行分类的。若我们的语料库是更大的词典，经过对大语料库进行训练后，人工提供分类“武侠类”、“现代类”等等，能否将相应文章准确分类？</li>
<li>能否抓取文章完整内容进行分词和聚类？避免教坏小朋友，留待大家讨论</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>草榴</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>关于11.11，我想说的</title>
    <url>/p/266310d2.html</url>
    <content><![CDATA[<p>今天走到体育馆，看到研究生入学考试现场报名确认的长龙，才突然想起三年已经过去了。 三年前的11.10号，周六，吹着北风，天很冷，收到同班同学的电话说，第二天就要现场确认。慌慌张张爬起来到楼下找了间网吧，查看自己的报名号和确认时间。第二天起了个大早（我想是五点半吧），辗转了2个小时来到望江进行现场确认。 转眼间三年就过去了，我曾经非常庆幸自己最终选择了这条道路，并最终进入川大。我不曾细数，这三年间究竟收获了什么，但是的确很多。我想如果没有报考这里，直接进入社会，自己会淹没在茫茫的人群中而不知所终吧。也许到头来吃尽苦头，最终会选择重回学校吧？ 如今，当我站在这个路口，逐渐清晰自己所选择的时候，又禁不住摩拳擦掌、跃跃欲试。我想，自信、乐观、诚恳的自己会在未来的道路上越来越得心应手吧。阿弥陀佛 当然，今天这般独一的日子，被人赋予了操蛋的含义。我表示，鸭梨不大，一切皆好。不过还好，也算是中国特色的节日，如果朋友都在，能出去庆祝也是不错的选择。大家还好不？</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>关于360和腾讯的论战</title>
    <url>/p/73827e3c.html</url>
    <content><![CDATA[<p>还是蛮佩服周鸿祎的，斗士！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>升級到Wordpress 4.9.8</title>
    <url>/p/eb1e4064.html</url>
    <content><![CDATA[<p>Wordpress後台最近一直在推送Gutenberg（古騰堡）編輯器。本想直接打開試試，發現Wordpress必須升級到新版才可。</p><p>做完備份，便做了升級，第一時間試用了古騰堡，發現與原生編輯器完全不同。但是各有利弊。</p><p>好處如下：</p><ol>
<li><p><strong>界面更大氣好看</strong></p>
<p><img src="http://pic.l2h.site/Gutenberg.png" alt></p>
<p>如下圖：</p>
</li>
<li><p><strong>所有文章標題、段落、圖像都是編輯區塊，增加內容更為方便</strong></p>
</li>
<li><p><strong>長文章編輯更加方便：工具欄鎖定在頂部，編輯過程中更改格式，不用翻到頂部再做修改。</strong></p>
</li>
<li><p><strong>支持嵌入Youtube、Tumblr等社交網站資源插入</strong></p>
<p><img src="http://pic.l2h.site/Guntenberg-social-links.png" alt></p>
</li>
<li><p><strong>支持嵌入按鈕</strong></p>
</li>
</ol><a id="more"></a>



<p>有以上諸多優勢，個人常用的插件“七牛云圖床”和代碼高亮插件在古騰堡下卻沒有辦法使用(不過後台支持轉回舊的編輯器)。看來要繼續摸索和實驗一段時間了。</p>
<p><img src="https://wordpress.org/gutenberg/files/2018/08/Builder.gif" alt></p>
<p>L&amp;H Site</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>Gutenberg</tag>
        <tag>古騰堡</tag>
      </tags>
  </entry>
  <entry>
    <title>冷静</title>
    <url>/p/a2472c1b.html</url>
    <content><![CDATA[<p>最近工作很忙 得到的体会是：</p>
<ul>
<li>当不断被推着走时，停下来想一下是否没把流程事先定好</li>
<li>责任还是要提前区分好</li>
</ul>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>几点</title>
    <url>/p/ae4369d1.html</url>
    <content><![CDATA[<p>洗个澡回来，路上突然想总结几点话： 1.和人发短信或者聊天，总是被回应“呵呵”，那么就停下来。对方要不对你没兴趣，要不对你的话题没兴趣。 2.参照第一点，我跟人说话大多数时间都是回的“哈哈” 3.参照前两点，别人说话实在没兴趣，还不如直接了当的说“我没兴趣，换个话题” 4.如果你喜欢的人对你忽冷忽热，那么恭喜你，你绝对备胎 5.当然第四点也有例外，或者只说明你没那么吸引他（她） 6.有人对你大献殷勤，要不就是喜欢你（同性的话除外），要不就是对你有所求，注意了 7.对第六点补充下，当然也不排除你对人家做了些好事，想要回报你   疯言疯语闲扯，笑看。。。 PS：院子里住了个les，今天看到换了个对象，跟上学期那个风格一样，只是人变了。。。（我咋这么八卦啊</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>卷积神经网络(CNN)的理解</title>
    <url>/p/bcfdcb18.html</url>
    <content><![CDATA[<p>机器学习的目标是可以让计算机像人一样对事物进行理解，近些年深度学习得到了深入的发展，并有了广泛地产业化应用。一些常见的机器学习应用包括音视频识别、音视频分类、自然语言处理（NPL）等。</p><p>卷积神经网络（<strong>Convolutional Neural Network，CNN</strong>）最早提出于1979年，于今时在机器学习领域得到了广泛地应用，特别是在执行图片分类、识别等任务时，有着绝佳的效果。这是因为其在处理大量数据集时，计算复杂度上有着很大的优势。</p><a id="more"></a>

<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><img src="http://pic.l2h.site/1.jpg" alt></p>
<p>神经网络的框架如图所示，它主要由以下几个部分组成：</p>
<ul>
<li>卷积</li>
<li>(ReLU)非线性化</li>
<li>池化</li>
<li>分类</li>
</ul>
<p>以上为卷积神经网络必不可少的部分，接下来我们试着对以上步骤分别进行理解（本文不涉及数学公式部分）。</p>
<h2 id="CNN深入理解"><a href="#CNN深入理解" class="headerlink" title="CNN深入理解"></a>CNN深入理解</h2><p>在对以上步骤进行介绍之前，我们先看一下计算机对视觉图像是如何进行理解的。如下图，对计算机来讲，每个图像都是以像素值作为元素的一组向量。每个像素点有RGB三种不同的<strong><em>通道</em></strong>，每个通道的取值为0-255的数字。而<strong>灰度</strong>图像，往往是只有一个通道的图像。为介绍的简便性，本文考虑只有一个通道的灰度图像。</p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>CNN的名称即来自于“卷积”这一步骤。后者的主要目标是从输入中提取出可以用于分类的特征，同时保留像素间的空间距离。</p>
<p>考虑如下图左5<em>5像素大小的灰度图像，其中像素值为0或1（注意，这只是为了说明问题的一个特殊例子。灰度图像的像素点取值范围仍是0-255），以及图右的3</em>3矩阵</p>
<ul>
<li><p><img src="http://pic.l2h.site/2-2.png" alt></p>
<p>图像像素点</p>
</li>
<li><p><img src="http://pic.l2h.site/3.png" alt></p>
<p>过滤矩阵</p>
</li>
</ul>
<p>卷积操作即是类似如下动图对5<em>5图像和3</em>3矩阵的操作。橘色的矩阵在绿色原始图像像素矩阵上进行1像素大小滑动（Stride），每次对叠加元素间的积求和到新的向量矩阵元素（下图粉色矩阵）。</p>
<p><img src="http://pic.l2h.site/4.gif" alt></p>
<p>在卷积神经网络概念中，橘色的3*3矩阵被成为“过滤器”或“核函数”，而滑动过滤器并计算粉色向量的过程成为“特征卷积”或者“特征映射”。即，我们使用橘色的矩阵作为了原始图像的特征映射器。</p>
<p>很明显，从动图可以看出，对同一个图像不同的过滤矩阵值会产品不同的特征映射矩阵。考虑下图输入图像，我们可以从下表中看出，不同的过滤矩阵，如何影响到卷积的效果：</p>
<p><img src="http://pic.l2h.site/5.png" alt></p>
<ul>
<li><p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-07-10-%E4%B8%8B%E5%8D%882.21.42.png" alt></p>
<p>不同卷积操作对原始图的影响</p>
</li>
</ul>
<p>从下图也可以很清楚地看到卷积操作的过程及产生的结果（两个不同的过滤矩阵，过滤出了同一图像的不同特征矩阵。）：</p>
<p><img src="https://wx2.sinaimg.cn/mw690/62d92af0ly1g4uq9zl5isg20dc07k7wm.gif" alt></p>
<p>在实际应用，CNN的训练过程会对过滤矩阵中的参数值进行学习（当然在这之前“我们”要负责选择过滤矩阵的数量、矩阵的大小以及网络的结构）。我们选择越多的过滤矩阵，卷积过程便得到越多的图像特征，这样网络识别图像的效果也越好。</p>
<p>卷积层的大小主要由以下三个参数来决定（学习开始前“我们”需要决定这些参数）：</p>
<ul>
<li>深度(Depth): 即卷积矩阵的数量，例如上图狗狗相片我们采取的Edge Detection、Box Blur矩阵等。不同的矩阵维度表示不同的特征。</li>
<li>步长(Stride)：卷积矩阵每次在原始图像像素矩阵上的滑动距离。例，2代表每次滑动2个像素的宽度</li>
<li>0填充(Zero-Padding)：有时需要在原始数据边界填充0作为被卷积的对象。此时称为宽卷积（Wide Convolution），反之称为窄卷积（Narrow Convolution）。0填充的一个作用是，当移动步长超过1时，有时移动会超出数据边界，此时适当做一些0填充来让移动可以顺利进行</li>
</ul>
<h3 id="非线性化-ReLU"><a href="#非线性化-ReLU" class="headerlink" title="非线性化(ReLU)"></a>非线性化(ReLU)</h3><p>卷积操作之后，会对数据进行非线性化。ReLU为常用非线性化函数（Rectified Linear Uni），下图为该函数的坐标轴表示：</p>
<p><img src="http://pic.l2h.site/screen-shot-2016-08-10-at-2-23-48-am.png" alt></p>
<p>ReLU对卷积化后的输出矩阵元素的负值进行处理，替换成0，主要目标便是将数据非线性化（因为真实世界中的数据往往也是非线性化的，而卷积是一个线性过程，需要对卷积后的数据做非线性处理）。</p>
<p>下图描述了ReLU操作对卷积操作后的特征矩阵的影响：</p>
<p><img src="http://pic.l2h.site/screen-shot-2016-08-07-at-6-18-19-pm.png" alt></p>
<p>也有一些其他非线性函数如Sigmoid和tanh（最朴素的神经网络里也会用到这些函数），ReLU在实际使用中性能优于这两个函数。</p>
<h3 id="池化过程-Polling"><a href="#池化过程-Polling" class="headerlink" title="池化过程(Polling)"></a>池化过程(Polling)</h3><p>空间池化（也成为“子抽样”）可以对卷积和非线性化的特征矩阵做有效降维，同时保持了矩阵的重要信息。池化主要用到的函数包括最大值(Max)、平均值(Average)、求和(Sum)等。</p>
<p>以最大值池化为例，我们在特征矩阵上定义空间近邻（如下图，2*2的窗口），取出其中每个窗口的最大元素，重新组成特征矩阵。若该层卷积选择了多个过滤窗口，那么我们对每个卷积化特征矩阵做池化处理得到池化后的特征矩阵。</p>
<p><img src="http://pic.l2h.site/screen-shot-2016-08-10-at-3-38-39-am.png" alt></p>
<p>下图显示了图片被池化后的效果：</p>
<p><img src="http://pic.l2h.site/screen-shot-2016-08-07-at-6-11-53-pm.png" alt></p>
<p>池化的主要作用就是有效降低输入数据的空间大小，节省计算量。其优势总结如下：</p>
<ul>
<li>不损失信息前提下，减小特征数据</li>
<li>减少神经网络需要计算的参数数量和计算量，因此可以有效抑制过拟合</li>
<li>减少输入数据因为转化变形等操作带来的影响</li>
</ul>
<p>以上过程介绍了构建CNN的基础成分卷积、非线性化和池化。这些过程的最终目的是得到与图片相关的、小数据量的、且能有效表达图像特征的特征矩阵。而这个特征矩阵的目的则是为最后一步，全连接神经网络的计算做准备，即我们提到的“分类”步骤</p>
<p>全连接神经网络的主要原理可以参考本站&lt;<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/" target="_blank" rel="noopener">神经网络和深度学习</a>&gt;一文的介绍，此处不做过多阐述。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结使用卷积神经网络进行机器学习的主要过程为：</p>
<ol>
<li>选择卷积神经网络的卷积、非线性化、池化等参数。同时初始化各个过程权值的初始值（可以随机化处理）</li>
<li>输入图像，并得到图片输出。</li>
<li>计算图片输出和实际输出的损失。</li>
<li>使用BP算法来优化神经网络，降低损失。</li>
</ol>
<p>欢迎留言探讨</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>去甲骨文试试</title>
    <url>/p/77ab6d3b.html</url>
    <content><![CDATA[<p>今天收到短信说Oracle简历投递21号就截止了，突然想去试下。看到上海部门的职位还跟自己做的sensor有关，那么就投一个试下吧，练练英语也可以。说不定蹭一下过了，哈哈哈。 顺便：趁着DDR3条子价格大跳水，周日在新蛋买了根kingston 2G 1333的条子，今天才收到出库的短信，让我再等两天，我好等啊我！！！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>又被黑了</title>
    <url>/p/71b89378.html</url>
    <content><![CDATA[<p>个人原因，很久没有关注网站。近日收到<a href="https://www.l2h.site/2019/03/21/%E7%BD%91%E7%AB%99%E8%A2%AB%E9%BB%91%E4%BA%86/" target="_blank" rel="noopener">博友留言</a> ，网站仍然会莫名其妙跳转。今日一看果不其然，网站被跳转到了hellofromhony[.]com</p><p>万能的Google查找，发现是Yuzo Relate Post插件的Bug（其实真的蛮好用的插件），导致黑客在WP_Option中插入非法的javascript跳转到上述站点</p><a id="more"></a>

<p><img src="http://pic.l2h.site/%E5%8F%88%E8%A2%AB%E9%BB%91%E4%BA%86.png" alt></p>
<p>插件作者目前关闭了插件，并提供的解决方案，表示日后会提供修正的插件。修正方法如下：</p>
<blockquote>
<p>– Remove / Uninstall the plugin immediately. <strong>立即卸载插件</strong><br>– Within your database go to the <code>wp_options</code> table and look for the value <code>yuzo_related_post_options</code> delete that record. <strong>删除<br>**`</strong>yuzo_related_post_options<strong>`</strong> 这个wp_option**<br>– Do not delete the table of visits <code>wp_yuzoviews</code>, this does not influence the problem.<br>Soon I will send an improved version of Yuzo for all users.</p>
</blockquote>
<p>总结：插件稳定的话，千万不要乱更新，也及时关注自己网站状况。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>各位博友，中秋快乐</title>
    <url>/p/874aad2.html</url>
    <content><![CDATA[<p>能和家人团圆是好事。不能和家人团圆的也和朋友呆在一起过中秋吧！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>吴克群签售会</title>
    <url>/p/d6e99f18.html</url>
    <content><![CDATA[<p>吴克群算是很大牌了，今天来我们学校签售新专辑，可惜我们提供的场地竟然知识一个小小的教室，而且学生都没有来满 小伙子还行，还是比较帅的（当然跟我比还是……） 照片： Loading…</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>喜欢上这首歌了《一分钟》</title>
    <url>/p/3cc50439.html</url>
    <content><![CDATA[<p>[embed]<a href="https://music.163.com/#/song?id=382235&amp;userid=289657006&amp;from=timeline[/embed]" target="_blank" rel="noopener">https://music.163.com/#/song?id=382235&amp;userid=289657006&amp;from=timeline[/embed]</a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>土博士找工作的一点感慨</title>
    <url>/p/5542c78e.html</url>
    <content><![CDATA[<p>本人沙雕土博士一枚。前段时间终于终于发够毕业所需SCI文章，自觉可以找个不错的单位。然鹅，给成都二本高校投的简历至今没有回音。导师又给推荐了一个二本高校博后工作。话说这个博后的待遇还是不错的，但是平台小，在站时间长，最后能不能留下来也是有巨大的疑问。鉴于读博期间的文章压力，现在对于做实验发文章还是有点焦虑感。以前实验安排最紧张的时候，早9晚12也是有的，外加几个月周末连轴转；做不出结果的时候，失眠也是常有。本来狠下心来做这个博后，结果一直联系的院长大人不咋理我了（囧）。前面投了好几个简历没有回信儿，信心被打击的不要不要的。现在不知道自己能干嘛，很迷茫。土博士由于没有海外经历，感觉就是高不成低不就。不过除了搞科研，发现自己好像也没有其他什么拿得出手的技能。现在每天都在看各种招聘网站，但是不知道自己除了科研还能做什么工作。Lambert好像不是很理解我现在的状态，他觉得女博士必须要去高校才是最好的出路，但是又不让我出国搞个海外经历。感觉要被他逼疯了。找不到工作，每天都处于焦虑中，每天都觉得在浪费时光。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>大端(Big Endian)与小端(Little Endian)简介</title>
    <url>/p/fa9a1c2b.html</url>
    <content><![CDATA[<p>小字节序：(比如x86体系) 数据的低字节放在低地址处，比如一个整型数0x12345678，在内存中的 分布为： ———– |  78  | xxxx_0000 ———– |  56  | xxxx_0001 ———– |  34  | xxxx_0002 ———– |  12  | xxxx_0003 ———– Little Endian 大字节序：(比如PowerPC体系) 数据的低字节放在高地址处，比如一个整型数0x12345678，在内存中的 分布为： ———– |  12  | xxxx_0000 ———– |  34  | xxxx_0001 ———– |  56  | xxxx_0002 ———– |  78  | xxxx_0003 ———– Big Endian</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>大话西游2仙履奇缘</title>
    <url>/p/986ce121.html</url>
    <content><![CDATA[<p>自从把三方协议签了后，便开始了感冒。一直没好，影响做事。抽空看了几部电影，其中回味了下经典中的经典《大话西游》。 想起小时看到大话西游中的场景，喜欢更多的是其中的无厘头搞笑。但是现在看来，它带给我的竟是些许莫名的伤感和感动。 至尊宝至始至终都想做个凡人，但是却逃不过宿命的安排，这一切都是命。紫霞说得好，猜中了开始，却猜不中这结局。。。。。 不想了，后边还有更多事情要做</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>循环神经网络(RNN)简单理解</title>
    <url>/p/19d2fc7e.html</url>
    <content><![CDATA[<p>循环神经网络(Recurrent Nerual Networks,简称RNN)近年来被业界视作处理序列数据以及做自然语言处理的灵丹妙药。其变种LSTM仍是当今最先进的数据处理模型之一。</p><p>理解RNN的工作原理，可帮助机器学习人员建立起有效的模型，更好地对数据进行有效的处理。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是RNN？首先让我们比较下传统前向神经网络与RNN的网络架构。</p><a id="more"></a>


<p><img src="https://blog.floydhub.com/content/images/2019/04/Slide3-1.jpg" alt></p>
<p>左：传统神经网络架构 右：RNN架构</p>
<p>从图中可以看出，两者的差异主要在于网络是如何接收输入数据的。</p>
<ul>
<li><strong>传统前向神经网络</strong>：接受固定数量（所有数据量）的输入，进行定量的输出</li>
<li><strong>RNN</strong>：并非一次性使用所有的数据作为输入。反之，RNN有多个步骤，每个步骤将一部分数据序列化输入，经过一系列计算产生输出，直到所有的序列结束。</li>
</ul>
<p>这样讲可能仍然难以理解，下把这张序列化的动图可以辅助大家更好地理解。</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/rnn-2.gif" alt></p>
<p>上图可以看到，每一步的计算会将上一步的计算输出对应的隐藏状态（Hidden State）作为一部分输入。由此看出，RNN对处理序列化相关的数据有天生的优势。</p>
<p>另外我们可以看到，RNN每一步的神经元计算，是采用相同的网络结构，这是RNN的另外一个重要特点。</p>
<h3 id="RNN网络的输入输出"><a href="#RNN网络的输入输出" class="headerlink" title="RNN网络的输入输出"></a>RNN网络的输入输出</h3><p>您可能会有疑问了：RNN输出来自于网络的哪一步？答案是，这取决于您要解决的问题是什么。例如，如果您用RNN做分类任务，那么您所需要的是从所有输入得到的最终输出；或者您要做单词预测任务，那么您会需要RNN网络序列的每一步都作出输出。</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/karpathy.jpeg" alt></p>
<p>RNN输出数据多种形式</p>
<p>上图可以看出，RNN是非常灵活的，可以根据您的需要制定RNN的网络模型，喂给网络不同类型的输入，得到不同的输出。</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/Slide6.jpg" alt></p>
<p>RNN多对一输出</p>
<p>上图示例中，所有时刻的输入，经过RNN网络，得到最后的输出结果。</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/Slide7.jpg" alt></p>
<p>RNN多对多输出</p>
<p>而本示例中（上图），RNN序列的每一步输出都是我们需要的。除此之外，在例如翻译任务中，我们可能在会先接受多个输入序列，产生一个输出。再根据这个输出，最后产生多个输出序列。如下图英语翻译为法语的示例：</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/Slide8.jpg" alt></p>
<p>RNN 翻译示例</p>
<h3 id="RNN单元内部工作原理"><a href="#RNN单元内部工作原理" class="headerlink" title="RNN单元内部工作原理"></a>RNN单元内部工作原理</h3><p>到这里，您可能对RNN网络的框架有个基本了解。不过具体每一个RNN单元是如何工作的呢？</p>
<p>首先我们看传给RNN序列下一步的隐藏状态是如何产生的。有如下公式：</p>
<p>$$<br>hidden_t = F(hidden_{t-1}, input_t)<br>$$</p>
<p>即当前步的隐藏状态，由上一步的隐藏状态加上这部分的输入经过函数F处理后产生。而第一步的隐藏状态，一般会在整个RNN初始化时人为设置为0。在最简单的RNN中，函数F一般为每个输入乘以对应的权重再用激活函数做非线性处理。激活函数一般有RELU、Sigmoid或tanh。下边公式为采用tanh作为激活函数：</p>
<p>$$ hidden_t = tanh(W_{hiddent}*hidden_{t-1},W_{input} * input_t) $$</p>
<p>而我们若需要在RNN单元每一步产生一个输出，那么这个输出一般由该步的隐藏单元做一个线性处理产生，例如：</p>
<p>$$ output_t = W_{output}* hidden_t $$</p>
<p>可以看出，上一个RNN单元的隐藏状态会被传递给下一个RNN单元，如此重复，直到运行到我们设定的停止条件。</p>
<p>当然，这是一个最简单的RNN网络形式。RNN网络还有许多相对复杂的变种（当然是为了针对性解决其他网络形式的一些问题而提出），例如LSTM、GRU等。</p>
<h3 id="RNN网络的训练"><a href="#RNN网络的训练" class="headerlink" title="RNN网络的训练"></a>RNN网络的训练</h3><p>RNN需要经过训练才能学习“”到更精准的拟合，从而得到我们想要的数据。</p>
<p><img src="https://blog.floydhub.com/content/images/2019/04/rnn-bptt-with-gradients.png" alt></p>
<p>RNN网络的权重更新</p>
<p>我们知道，神经网络通过学习和更新网络中的权重来接近最优解（见<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/" target="_blank" rel="noopener">本站文章</a>），RNN也不例外。通过一步步后传播算法来减小损失函数（Cost Function）最终得到最小值，RNN的后传播会需要前面RNN单元的数据，本文不作推导。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文对循环神经网络(RNN)的基本框架和原理做了介绍。为方便理解，略去的数学推导。接下来，计划对RNN网络的变形LSTM、GRU等做介绍，并增加Tensorflow代码实现。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐，so simple</title>
    <url>/p/66b7187d.html</url>
    <content><![CDATA[<p>昨天晚上再次去了英语角。 起初我是有点鄙夷这种地方的，觉得互相陌生的一堆人站到一起说一些话题，带着“improve one’s oral English”的目的。所以朋友说，起初我在那里总是很痛苦，我紧皱眉头，try to follow other’s step。 后来认识了很多不错的朋友，很多人都很有见识和主意：比如说这周参加某公司二面（群面、非技术面）败北，特地到英语角请教了一个HR的朋友，让他帮忙分析中间整个过程。从他的分析中还是学到了很多，而且这位朋友人真的不错，跟他在一起感觉到他真的很nice。和熟悉的不熟悉的朋友交流彼此的见闻。快乐享受每个chatting的瞬间，快乐又重新回来了。我不care自己的口语是不是真的很差劲（当然，私下提高还是有必要的），我也不管是不是真的听懂朋友在讲什么（其实现在大部分时间我还是听得懂的）。当然，英语角呢，也有不少美女。哈哈哈。 混乱写了一堆，其实我想说的是：跟随自己的内心走，真正的追逐快乐，那么自己才是一个快乐的人。我想我回归自我了。朋友说，我现在比从前更开朗了，这才对得起自己的名字：Lambert（我跟朋友说，是阳光开朗的意思）。 哈哈哈，同学们，共勉。还是那句话，可能最近忙，来不及恢复各位，更新也比较慢，望见谅。我希望可以在这个平台结交更多的朋友，而不是为流量而互访的机器。哈哈哈 By the way：昨天百度在我们学校开宣讲会，那个做演讲的高级技术总监，思路真是很清晰，回答问题真的狠抓重点，真是相当的牛人啊！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>我写我的日记</title>
    <url>/p/e2a9ef92.html</url>
    <content><![CDATA[<p>最近心情一直比较低沉，大致是因为纠结的感情和即将面临的工作应招。不知何时又被人标上“多愁善感”的标签，我想还是跟最近的经历有很大关系的吧。 感情就是这样，有时觉得能真心喜欢一个人实属不易，付出行动以及热忱的表达，也都收效甚微。因为毕竟感情是两厢情愿的事情，对方一句“还需多了解”便可以将满心的期望击的粉碎。你苦你悲，你无所适从，对方不可能会有任何体会。 不过还好，再痛苦再无奈，终会在本周内结束。来个干净利落吧。。。 纯发泄文字，朋友望见谅。心头之情不吐不快。。I’m fine</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>教你关闭微信朋友圈的广告</title>
    <url>/p/202c56aa.html</url>
    <content><![CDATA[<p>刷微信朋友圈时，是不是经常看到一些广告，有时还不小心点到上边？可以使用以下步骤关闭：</p><ul>
<li>电脑打开<a href="https://privacy.qq.com/advertisement.htm" target="_blank" rel="noopener">https://privacy.qq.com/advertisement.htm</a></li>
<li>在“二、如何管理您看到的广告”点击“<strong><em>管理</em></strong>”</li>
<li>此时会让您用微信扫码登录，按照提示登录即可</li>
<li>在“个性化服务设置”关闭“_<strong>根据您的信息展示广告</strong>_”即可</li>
</ul><a id="more"></a>

<p>注意，以上方法有效期半年，半年后需重新操作。不过不得不说微信对比其他社交软件满人性化，至少提供了可以关闭广告的方法。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>早安</title>
    <url>/p/29534c1b.html</url>
    <content><![CDATA[<p><img src="http://pic.l2h.site/l2hsited5343035-d2ab-4f26-bcb3-a03d29508f34.jpg" alt="早安" title="早安"><br><img src="http://pic.l2h.site/l2hsite085c25c7-256a-45cb-8334-0481c0efd026.jpg" alt="早安" title="早安"><br><img src="http://pic.l2h.site/l2hsite586ba946-b576-4475-806d-fa38130e2512.jpg" alt="早安" title="早安"><br><img src="http://pic.l2h.site/l2hsite0eec6389-d3b1-4064-ac5c-5a641f7ecb0f.jpg" alt="早安" title="早安"><br><img src="http://pic.l2h.site/l2hsitec606e1b5-9826-4d56-bd1b-6569ceff97b3.jpg" alt="早安" title="早安"></p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>时钟滴答</title>
    <url>/p/3875b6ac.html</url>
    <content><![CDATA[<p>又是凌晨，时针指向0：41。明明困了，却不想睡觉。打开QQ音乐，听王力宏的新专辑，索然无味。最近心里总是装了太多的事情，很难强迫自己睡个无所顾忌的大觉。 总是跟朋友提起“越长大越孤单”。我不知道怎么定义孤单这个词，但是心底的声音告诉我：我，是孤单的。 待在家里，好吃好喝，有家人的陪伴，有可爱小侄儿可以逗，有网络可以上。可是总有那么一丝羁绊不可释怀。很难说清这种感觉，也许苦涩也许无奈。 好哥们问：你困扰什么？答曰：就要找工作进入社会了。他说：说出这句话说明你还不成熟。该怎么说好呢，只能附之一笑。不在身边的朋友，很难分享心中的感觉，更无从理解内心的想法。 何时，变成孜然一身，孤军奋斗，其中艰辛可想而知。我想，还是需要学习，学会承受这种孤单吧。毕竟，真正的强者是隐忍磨砺出来的。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习为什么使用独热(One-hot Encoding)编码</title>
    <url>/p/bccdda5e.html</url>
    <content><![CDATA[<p>最近在看一些机器学习资料，发现使用起来真的蛮难。特征工程，如何有效地对数据进行预处理使得学习过程可以有效进行，是其中一个重要的难点。因为任何一个数据模型，都需要你准备相应的数据，错误的数据往往造成训练无法拟合（Fitting）。</p><p>在处理特征数据时，独热编码是一种常用的对离散特征进行处理的编码方式。本文根据个人理解，讨论为什么需要独热编码，它的好处是什么</p><a id="more"></a>

<h3 id="分类数据"><a href="#分类数据" class="headerlink" title="分类数据"></a>分类数据</h3><p>要了解独热编码啊，先理解什么是分类数据。顾名思义，这类数据往往不是直接以数值或向量化形式呈现的数据，其一般为具有实际含义的名称标签。例如，</p>
<ul>
<li>某一列数据表示为‘宠物’。相应的值有“狗”、“猫”、“兔子”等</li>
<li>表示“城市”的数据值有“北京”、“上海”、“成都”等</li>
</ul>
<p>这些数据值在特定机器学习训练中往往具有有限的类别。</p>
<h3 id="分类数据的问题"><a href="#分类数据的问题" class="headerlink" title="分类数据的问题"></a>分类数据的问题</h3><p>一些诸如“决策树”算法的学习方法，可以直接利用这些分类数据而无需进行数据转化。但更多的机器学习算法，需要进行的是数字或向量运算，没有办法直接处理这些文字型标签。这意味着，这些文字型的分类数据需要一定的转化，编程机器学习算法可以处理的数字型。</p>
<p><em>如何进行转化？</em></p>
<p>从程序员直觉上讲，很简单嘛，类似C语言的枚举类型，每种类型赋一个数字的值。例如，狗=1，猫=2，兔子=3，……</p>
<p>对一些学习场景，这种编码或许足够了。但是这种简单粗暴的编码方式，忽视掉了数据类别之间的距离。例如，狗和兔子之间的差异，并不会比狗和猫之间的差异大。但枚举方式进行编码，往往把这些特征值做了排序，与实际状况并不相符，最后导致学习的结果受到影响。</p>
<p>而解决这种问题的方式就是独热编码。某种特征有N种值，那么值就可以编码为1*N的向量，向量取值有N中，每种取值向量有且仅有一位为1。例如，狗=[1,0,0]，猫=[0,1,0]，兔子=[0,0,1]。可以看出，这三个值的距离是相等的。这就解决了枚举方式编码带来的问题。</p>
<h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><p>有许多现成的Python库可以进行独热编码:</p>
<ul>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/one_hot" target="_blank" rel="noopener">One-Hot</a></li>
<li><a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank" rel="noopener">scikit-learn</a></li>
<li>…..</li>
</ul>
<p>我们所需要做的就是根据相应的文档使用对应的API即可？</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文大概介绍了独热编码的原理和使用场景。一般来说：</p>
<ul>
<li>为什么使用独热编码：大部分机器学习算法需要数字输入输出，而文字型标签无法被处理，枚举方式的编码可能错误地体现特征值间关系</li>
<li>如何使用：SKlearn或Numpy有现成的API可以使用</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>独热编码</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习几个要素</title>
    <url>/p/43876d90.html</url>
    <content><![CDATA[<blockquote>
<p>本文为个人学习机器学习的一些入门级总结，若您是机器学习大神，可以直接留言点赞就好，嘿嘿。</p>
</blockquote><p>要实现一个机器学习功能，以下要素必不可少：</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是机器学习的灵魂，万物的基石，女娲造人的泥土。可以说，所有的机器学习都是围绕着数据来进行的。数据的作用：</p><ul>
<li>训练模型</li>
<li>验证模型有效性</li>
<li>分析模型</li>
</ul><p>Tensorflow在学习是，需要先为数据站位（Placeholder），主要作用是预留出学习过程中数据所需要占用的系统资源（内存）。例如下边代码tensorflow处理<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MINIST数据集</a>的预先占位：</p><a id="more"></a>




<p>mnist = read_data_sets(‘./‘,one_hot=True)</p>
<p>sess = tf.InteractiveSession()</p>
<p>x = tf.placeholder(“float”, [None, 784])<br>##省略与placeholder无关部分<br>for i in range(1000):<br>  batch_xs, batch_ys = mnist.train.next_batch(100)<br>  sess.run(train_step, feed_dict={x: batch_xs, y_: batch_ys})</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型表示采用什么样的模式训练数据，是神经网络（深度神经网络又分CNN、RNN等）、决策树算法、贝叶斯分类或者线性回归等等。这些模型在成熟的机器学习框架如Tensorflow或者Pytorch中都有实现（直接API调用）。例如下面例子是Tensorflow使用CNN训练的网络模型：</p>
<p>def cov2d(x, W):<br>  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=’SAME’)<br>def max_pool_2x2(x):<br>  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],<br>                        strides=[1, 2, 2, 1], padding=’SAME’)<br>#第一层卷积层<br>W_conv1 = weight_variable([5, 5, 1, 32])<br>b_conv1 = bias_variable([32])<br>x_image = tf.reshape(x, [-1,28,28,1])<br>h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)<br>h_pool1 = max_pool_2x2(h_conv1)</p>
<p>#第二层<br>W_conv2 = weight_variable([5, 5, 32, 64])<br>b_conv2 = bias_variable([64])<br>h_conv2= tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)<br>h_pool2 = max_pool_2x2(h_conv2)<br>#全连接层<br>W_fc1 = weight_variable([7 * 7 * 64, 1024])<br>b_fc1 = bias_variable([1024])<br>h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])<br>h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</p>
<p>#Dropout<br>keep_prob = tf.placeholder(“float”)<br>h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</p>
<p>#输出层<br>W_fc2 = weight_variable([1024, 10])<br>b_fc2 = bias_variable([10])</p>
<h3 id="优化算法（Optimizer）"><a href="#优化算法（Optimizer）" class="headerlink" title="优化算法（Optimizer）"></a>优化算法（Optimizer）</h3><p>优化算法体现的是学习的方法。例如一个学生，你是希望他死记硬背还是寓教于乐。当然，这个比喻可能不是很恰当。其实就是告诉整个训练模型，每一步采用什么算法更新权值。一些常用的优化算法如梯度下降法、Adam、SGD等等，在处理不同的数据时各有优劣。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>主要用于对输出进行非线性化处理。一些比较复杂的数据，不是简单一条线，或者多次方程就能拟合出来的。而模型的形式往往是(F=wT+b)这种线性方程，所以需要使用激活函数对输出做非线性化处理。一些常见的非线性化函数包括Sigmoid、tanh、RELU、Softmax等等</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上为机器学习的必不可少的构成单元，直接计算会涉及到非常多的公式推导。还好现成的机器学习框架帮大家封装好了以上实现，大家直接使用即可。说到底、回头看，机器学习其实就是数据工程。如何选择和预处理数据，并使用合理的模型进行训练，是机器学习成败的关键</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>痛苦的持久战</title>
    <url>/p/7fb792bf.html</url>
    <content><![CDATA[<p>各位博友，你们的评论抱歉很晚回复。。找工作过程是痛苦持久的，估计你们再看到我得11月结束吧，也许运气好会早点。。。可能会很久不访问回复，见谅见谅。。。。！！！！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>笔试后的鄙视</title>
    <url>/p/e812c66a.html</url>
    <content><![CDATA[<p>按说经常在这里记录生活也不太好。但是今天我还是想给大家分享下我的经验和感受。 自从签了MTK，心还没有怎么静下来。前天intel电话通知到科大去笔试，我勒个去，好远啊。就这样我还是去了，反正没事嘛，去了，整个笔试教室20个人，整个川大就我一个人。 昨下午接到通知，说今上午到香格里拉面试。结果就惨兮兮了。操作系统，内核的知识确实没接触过。完了以后说一周内等通知吧。有多次面试经验的我当然知道这就是让你回去啦。。。。我就说，确实今天没表现好，他说其实你笔试成绩还蛮好的（貌似我参加笔试成绩一直都很好，自己也有感觉），昨天在成电已经把那边学生面完了，今天就面你一个（恩，有的是时间折磨我啊，哈哈哈）。。。。 看来项目经验不够的确吃亏啊。所以我的感受就是，无论如何，linux和内核一定要学好，今天面试我那位老兄也这么跟我说：其实你在学校时间这么多，理应学个基本的操作系统和内核。没找工作的切记啊，等你把linux内核研究熟练了，你绝对就是面试的万金油。！！！！ 说了一堆乱七八糟，本来今天是去练口语的，碰到个中国朋友，好吧，就这样吧。。目前的工作也还不错。。再过一段时间，该把心情静下来了，就准备去入手了，笨鸟先飞嘛。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>终于给博客添加了TK域名</title>
    <url>/p/78a2d818.html</url>
    <content><![CDATA[<p>好久没写技术文章了，整个博客就是个水吧。。。今天写个不算技术的技术文章 大家都知道，太平洋某岛国提供<a href="https://web.archive.org/web/20101211175434/http://my.dot.tk/cgi-bin/amb/landing.dottk?nr=352181::8528415::1" target="_blank" rel="noopener">免费的.tk顶级域名</a>，但是Google企业套件貌似封掉了这个端口，因此我申请了N久的短域名久久不能使用。 今天，我在某网站上看到了一篇博客，可以用添加域名别名的方法添加该顶级域名。不敢私自保存，拿出来分享。希望Google大人手下留情。。 1.登陆google企业套件注册域名，开始直接用.tk注册是不行的，大家可以用<a href="https://web.archive.org/web/20101211175434/http://www.co.cc/" target="_blank" rel="noopener">www.co.cc</a>提供的免费域名代替。 2.注册好以后，apps管理后台-域名设置-域名-添加域名别名，然后再别名里边填入要添加的.tk域名。如我的<a href="https://web.archive.org/web/20101211175434/http://www.imlambert.tk/" target="_blank" rel="noopener">imlambert.tk</a>。根据要求进行验证。 3.接着，在<a href="https://web.archive.org/web/20101211175434/http://my.dot.tk/cgi-bin/amb/landing.dottk?nr=352181::8528415::1" target="_blank" rel="noopener">.tk域名网站</a>填入你的域名服务解析服务器地址。如我的是dnspod，填入dns的两个nsseverver 4.在dnspod网站添加域名imlambert.tk,设置www的CNAME为ghs.you8g.com,并设置mx交换记录（注册企业套件时会有提示） 5.在you8g对域名进行注册，如我添加的是<a href="https://web.archive.org/web/20101211175434/http://www.imlambert.tk/" target="_blank" rel="noopener">www.imlambert.tk</a>,接着等待google官方验证完成。整个过程就设置好了。 注：以上顺序并不需要严格执行。大家根据需要调整。 话说新注册的域名并不短，但是<a href="https://web.archive.org/web/20101211175434/http://www.imlambert.tk%20=i%E2%80%99m/" target="_blank" rel="noopener">www.imlambert.tk</a> =I’m lambert,因此比较好记。希望给我加了友链的同学更新下吧。当然不更新也可以，我原来的<a href="https://web.archive.org/web/20101211175434/http://www.lambert-w.co.cc/" target="_blank" rel="noopener">www.lambert-w.co.cc</a>和<a href="https://web.archive.org/web/20101211175434/http://lambert-scape.appspot.com/" target="_blank" rel="noopener">http://lambert-scape.appspot.com</a>仍可使用。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>翟天临被指论文涉嫌抄袭, 他到底惹了谁？</title>
    <url>/p/2a9e16be.html</url>
    <content><![CDATA[<p>博客一直以技术类和旅行类文章为主，很少对社会新闻发表评论。不过最近的<a href="http://k.sina.com.cn/article_5973732618_1640fed0a00100g6lc.html?from=ent" target="_blank" rel="noopener">一条消息</a>却让人难以抑制评论一番的冲动。</p><blockquote>
<p>1月31日，翟天临晒出北大博士后录用通知书，也让他“演员里学历最高的”和“博士里最会演戏的”双重人设再次加码；只是掌声尚未落下，他却因一句“知网是什么”引爆舆论，网友们众说纷纭，热度甚至碾压同期影视剧。</p>
</blockquote><a id="more"></a>

<p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike933%2C5%2C5%2C933%2C330/sign=b1530cd702f41bd5ce5ee0a630b3eaae/fc1f4134970a304ee9524b06ddc8a786c8175cde.jpg" alt></p>
<p>先看翟天临何许人也，以下引用自百度百科的介绍：</p>
<blockquote>
<p>翟天临，1987年2月15日出生于山东省青岛市，毕业于北京电影学院2006级表演本科班，2014级博士研究生，任职北京大学博士后，中国内地影视演员 [1-2] 。<br>2000年，翟天临主演<a href="https://baike.baidu.com/item/%E6%9D%9C%E7%90%AA%E5%B3%B0/3831601" target="_blank" rel="noopener">杜琪峰</a>导演的青春文艺片《<a href="https://baike.baidu.com/item/%E5%B0%91%E5%B9%B4%E5%BE%80%E4%BA%8B/8263057" target="_blank" rel="noopener">少年往事</a>》。2009年，参演由冯超执导的武侠喜剧电影《<a href="https://baike.baidu.com/item/%E7%9A%87%E5%AE%B6%E5%88%BA%E9%9D%92/7414594" target="_blank" rel="noopener">皇家刺青</a>》 [3] 。2011年，主演商战爱情剧《<a href="https://baike.baidu.com/item/%E9%87%91%E6%9E%9D%E7%8E%89%E5%8F%B6/7875097" target="_blank" rel="noopener">金枝玉叶</a>》 [4] 。2012年，主演医疗剧《<a href="https://baike.baidu.com/item/%E5%BF%83%E6%9C%AF/3955775" target="_blank" rel="noopener">心术</a>》，凭借该剧获第二届搜狐视频电视剧最佳男配角、最佳新人 [5] 。2013年，主演都市剧《<a href="https://baike.baidu.com/item/%E6%9D%9C%E6%8B%89%E6%8B%89%E4%B9%8B%E4%BC%BC%E6%B0%B4%E5%B9%B4%E5%8D%8E/4146775" target="_blank" rel="noopener">杜拉拉之似水年华</a>》 [6] ；随后，主演古装偶像剧《<a href="https://baike.baidu.com/item/%E5%85%B0%E9%99%B5%E7%8E%8B/7747145" target="_blank" rel="noopener">兰陵王</a>》 [7] 。2014年，主演年代商战剧《<a href="https://baike.baidu.com/item/%E5%A4%A7%E5%BD%93%E5%AE%B6/1033017" target="_blank" rel="noopener">大当家</a>》 [8] 。2015年，主演的抗日剧《<a href="https://baike.baidu.com/item/%E6%BD%9C%E8%A1%8C%E8%80%85/15979173" target="_blank" rel="noopener">潜行者</a>》播出。 [9] 2016年，作为单元男主参演古装神话剧《<a href="https://baike.baidu.com/item/%E9%9D%92%E4%B8%98%E7%8B%90%E4%BC%A0%E8%AF%B4/16766483" target="_blank" rel="noopener">青丘狐传说</a>》 [10] 。2017年，主演年代剧《<a href="https://baike.baidu.com/item/%E7%99%BD%E9%B9%BF%E5%8E%9F/16746175" target="_blank" rel="noopener">白鹿原</a>》；同年，参演三国题材战争权谋古装剧《<a href="https://baike.baidu.com/item/%E5%A4%A7%E5%86%9B%E5%B8%88%E5%8F%B8%E9%A9%AC%E6%87%BF%E4%B9%8B%E5%86%9B%E5%B8%88%E8%81%94%E7%9B%9F/20818349" target="_blank" rel="noopener">大军师司马懿之军师联盟</a>》 [11] </p>
</blockquote>
<p>作为影视演员，其也不乏获奖记录：</p>
<blockquote>
<p>影视类  </p>
<p>▪ 2019-01    <a href="https://baike.baidu.com/item/%E7%AC%AC4%E5%B1%8A%E4%BA%9A%E6%B4%B2%E5%BD%A9%E8%99%B9%E5%A5%96/23252084" target="_blank" rel="noopener">第4届亚洲彩虹奖</a>最佳电视剧男配角奖[66]    <a href="https://baike.baidu.com/item/%E7%99%BD%E9%B9%BF%E5%8E%9F/16746175" target="_blank" rel="noopener">白鹿原</a>    （获奖）<br>▪ 2018-10    第5届<a href="https://baike.baidu.com/item/%E6%96%87%E8%8D%A3%E5%A5%96/15890827" target="_blank" rel="noopener">文荣奖</a>最佳男配角    军师联盟    （获奖）<br>▪ 2018-05    <a href="https://baike.baidu.com/item/%E7%AC%AC24%E5%B1%8A%E4%B8%8A%E6%B5%B7%E7%94%B5%E8%A7%86%E8%8A%82/22411691" target="_blank" rel="noopener">第24届上海电视节</a>-<a href="https://baike.baidu.com/item/%E7%99%BD%E7%8E%89%E5%85%B0%E5%A5%96/11447" target="_blank" rel="noopener">白玉兰奖</a>最佳男配角[12]    白鹿原    （提名）<br>▪ 2018-01    2017年中国好演员推选表彰会暨2018中国好演员论坛中国好演员优秀演员奖、绿宝石奖、荣誉奖    （获奖）<br>▪ 2017-12    中德大使已经最受观众喜爱男演员[67]    （获奖）<br>▪ 2014-10    第19届<a href="https://baike.baidu.com/item/%E4%BA%9A%E6%B4%B2%E7%94%B5%E8%A7%86%E5%A4%A7%E5%A5%96/9810824" target="_blank" rel="noopener">亚洲电视大奖</a>最佳男主角[68]    <a href="https://baike.baidu.com/item/%E5%A4%A7%E5%BD%93%E5%AE%B6" target="_blank" rel="noopener">大当家</a>    （提名）<br>▪ 2013-10    《国剧盛典》演艺偶像[5]    <a href="https://baike.baidu.com/item/%E5%85%B0%E9%99%B5%E7%8E%8B" target="_blank" rel="noopener">兰陵王</a>    （获奖）<br>▪ 2012-12    第二届    搜狐视频电视剧盛典最佳新人    <a href="https://baike.baidu.com/item/%E5%BF%83%E6%9C%AF" target="_blank" rel="noopener">心术</a>    （获奖）<br>▪ 2012-12    华鼎奖电视剧最佳新锐男演员[16]    心术    （提名）<br>▪ 2012-11    第二届    搜狐视频电视剧盛典最佳男配角    心术    （获奖）</p>
<p>综合类  </p>
<p>▪ 2018-09    法国旅游推广大使[69]    （获奖）<br>▪ 2018-01-29    中国公益节公益人物奖[70]    （获奖）<br>▪ 2015    瑞丽伊人风尚盛典年度突破明星奖[71]    （获奖）<br>▪ 2015    第五届    中国公益节年度公益人物奖[72]    （获奖）<br>▪ 2014    第四届    中国公益节2014最佳公益精神奖[73]    （获奖）<br>▪ 2014    小资风尚盛典年度电视剧演艺风尚男艺人    （获奖）<br>▪ 2014    《时尚芭莎》全国巡展慈善大使的称号    （获奖）    </p>
</blockquote>
<p>作为演员，居然还拥有学霸人设，还有北京大学录用做博士后工作，简直是人生赢家。不过这样优秀的人才，竟然不知道CNKI知网。不得不让人怀疑其博士学历的水分。</p>
<p>鄙人作为SCU的小硕，而XH作为SCU的博士，深知博士毕业的难度。毕业最难的不是博士论文，而是要求必发的见刊学术论文。XH所在学院要求作为一作发表两篇英文SCI期刊（做实验、写论文、校对，加上经历审稿过程一篇文章最少也要半年以上）。鄙人作为小硕，毕业要求见刊两篇，其中一篇中文核心期刊，而这恰恰是翟天临的博士毕业要求，好不简单！</p>
<p>而正因为博士毕业之难，加上翟天临一句“知网是什么”，惹怒了为毕业苦苦奋斗的博士或者准博士。得罪谁不能得罪博士，翻出翟天临的毕业论文，居然有40%的重复率。现在学术界这么不堪吗？有名有钱就可以有文凭吗？作为国内最高学府的北大，录用博士后的标准又是什么？这样认真做研究的同学们心理如何接受，中国的学术水平又何时才能提高？</p>
<p>这件事情本质上，是社会公平问题。越有权势越有关系，你的资源也越多。不过话又说回来，一次次人设崩塌事件又让我们看到，互联网不仅仅是网络暴力的温床而已，它也可以让不公平的社会更加公平。</p>
<p>不得不说，这次，翟天临的博士学位和博士后身份，悬了！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>蜘蛛</title>
    <url>/p/754ea313.html</url>
    <content><![CDATA[<p>没有想到寝室养了这么大一只蜘蛛 你说它会不会在我梦中咬我？或者想把我变成蜘蛛人？</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>试用CleanMyMac替代者-腾讯柠檬</title>
    <url>/p/b16eb642.html</url>
    <content><![CDATA[<p>MacBook Air所剩空间无几，搜索了一圈，CleanMyMac好用，但是无奈找不到激活码。正版费用249，对我这种个人电脑使用量不太多的人，无疑购买有些不划算。</p>
<p>网上搜索一圈，发现企鹅家目前出了一个<a href="https://mac.gj.qq.com/" target="_blank" rel="noopener">Tencent Lemon</a>，正在限时内测，支持最新的Mac Mojave。</p>
<p><img src="http://pic.l2h.site/Tencent-Lemon.png" alt></p>
<p>简单试用了一下，功能虽然不多，但是界面极简。可以扫描到应用程序和系统缓存。想来应该够用。推荐给大家。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>选择</title>
    <url>/p/7b2c5414.html</url>
    <content><![CDATA[<p>总要做一些不得已的选择，希望有好的结果。</p>
<p>目标：</p>
<ul>
<li>早睡早起</li>
<li>锻炼身体</li>
<li>少玩手机</li>
<li>多些游历</li>
</ul>
<p>P.S. 谷歌的灭霸彩蛋挺好玩</p>
<p><img src="http://pic.l2h.site/mieba-1024x534.png" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
      <tags>
        <tag>选择</tag>
      </tags>
  </entry>
  <entry>
    <title>【分享】德哥的《荒岛余生》</title>
    <url>/p/bee35490.html</url>
    <content><![CDATA[<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2018-11-25-%E4%B8%8B%E5%8D%888.50.01-1024x332.png" alt></p>
<p>跟着H这个资深纪录片爱好者，求生系列节目也看了不少。不过，不太喜欢贝爷这种风格，反而更喜欢德哥（艾德.斯塔福特）– 第一个独自穿越亚马逊丛林的男人。</p>
<p>最近在B站发现Discovery这套纪录片，荒岛生存60天。推荐！</p>
<p><a href="https://www.bilibili.com/bangumi/media/md122412/?from=search&seid=15711135308651136184" target="_blank" rel="noopener">打开荒岛余生  
</a></p>
<p> 单挑荒野系列下载：</p>
<ul>
<li>单挑荒野：澳大利亚<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6sMS088D70ccubWt2fDMxMjQ5MzAwM3wyMDhBRjhFNkM1MkJFMDc1MjE5QjdEMzUyQTI4NzhGNnxoPUdNTEc0UUw2UlVXQUNaS05RRllHU1pGTVQyREZZN1gyfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6sMS088D70ccubWt2fDMxMjQ5MzAwM3wyMDhBRjhFNkM1MkJFMDc1MjE5QjdEMzUyQTI4NzhGNnxoPUdNTEc0UUw2UlVXQUNaS05RRllHU1pGTVQyREZZN1gyfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野：波札那<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6sqjU/cTHLm1rdnwzMzYzMTA4MTF8MThERTA2Q0RBNTVCOURERTE5MUEyMDA1NzY0NzQ2QTJ8aD1FMzVEV01EN0xaSzNUNDNYWlZLVzY3SlNEQ0lPWjZEVHwvWlo=" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6sqjU/cTHLm1rdnwzMzYzMTA4MTF8MThERTA2Q0RBNTVCOURERTE5MUEyMDA1NzY0NzQ2QTJ8aD1FMzVEV01EN0xaSzNUNDNYWlZLVzY3SlNEQ0lPWjZEVHwvWlo=</a></li>
</ul>
</li>
<li>单挑荒野：卢安达<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6wqywsrTvLm1rdnwyOTA5NzQ0MDZ8MUYwNTg1RDNCNTE4RTc5NzkyRUExQjBBNzJCMzU1MTZ8aD1BMkVOTVlQUTJFNjdRWlZCWkdUSlpPRkZMSTVYWFI1SnwvWlo=" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6wqywsrTvLm1rdnwyOTA5NzQ0MDZ8MUYwNTg1RDNCNTE4RTc5NzkyRUExQjBBNzJCMzU1MTZ8aD1BMkVOTVlQUTJFNjdRWlZCWkdUSlpPRkZMSTVYWFI1SnwvWlo=</a></li>
</ul>
</li>
<li>单挑荒野：罗马尼亚<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6wt7C7cTh0ccubWt2fDI3MjIwODg4NnxBODMzRTdFNDUwQzgxMDRBMkJGMjFDNzZFMzJGQTVCMXxoPVhaRkxKWURFR0dQU1pIU0wyQVpYM0FPR1ZONUNLSFRZfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6wt7C7cTh0ccubWt2fDI3MjIwODg4NnxBODMzRTdFNDUwQzgxMDRBMkJGMjFDNzZFMzJGQTVCMXxoPVhaRkxKWURFR0dQU1pIU0wyQVpYM0FPR1ZONUNLSFRZfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野：婆罗洲<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6xsXC3tbeLm1rdnwzMjQzNjQyMjF8MzI3NjFBNEZGMDM0RTQ0OUQ3NDk3OTRFMTNBRjRFNkV8aD1SUUdMU1UySTNST05JSDQzQjJXUzU2Vk5OQlA1T1BVM3wvWlo=" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6xsXC3tbeLm1rdnwzMjQzNjQyMjF8MzI3NjFBNEZGMDM0RTQ0OUQ3NDk3OTRFMTNBRjRFNkV8aD1SUUdMU1UySTNST05JSDQzQjJXUzU2Vk5OQlA1T1BVM3wvWlo=</a></li>
</ul>
</li>
<li>单挑荒野：生存的法则<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6yfq05rXEt6jU8i5ta3Z8Mjc3OTk1OTA5fDFDRDM1ODI5NkNERkQxOEQ3NEFGMDlFRkEwMURGMjNDfGg9SlhUTEM0UUxTSkZPV0hCTTJRWEVNQzZESFNYQlA0N0l8L1pa" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6yfq05rXEt6jU8i5ta3Z8Mjc3OTk1OTA5fDFDRDM1ODI5NkNERkQxOEQ3NEFGMDlFRkEwMURGMjNDfGg9SlhUTEM0UUxTSkZPV0hCTTJRWEVNQzZESFNYQlA0N0l8L1pa</a></li>
</ul>
</li>
<li>单挑荒野：泰国<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6zKm5+i5ta3Z8MzI5NzE0MTM0fDZEOUE2MjNDMzFDMzJFQzdFQkIyOEEwOTdBMjdEMDBFfGg9VUVYSFdNTzQzRUk2M0VLVDdKRUNFQ1gySkFSNjM0WUV8L1pa" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6zKm5+i5ta3Z8MzI5NzE0MTM0fDZEOUE2MjNDMzFDMzJFQzdFQkIyOEEwOTdBMjdEMDBFfGg9VUVYSFdNTzQzRUk2M0VLVDdKRUNFQ1gySkFSNjM0WUV8L1pa</a></li>
</ul>
</li>
<li>单挑荒野：委内瑞拉<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6zq/E2sjwwK0ubWt2fDMyNjYwNDExMnwxQUQ4NDY3MENGQjk5QkY3NTIxODM2NEIwMzUyMTZGQnxoPVVQNFVHRlFPUFpHUlE0RUNJTUZHWENLWjQzU09LRFFHfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO6zq/E2sjwwK0ubWt2fDMyNjYwNDExMnwxQUQ4NDY3MENGQjk5QkY3NTIxODM2NEIwMzUyMTZGQnxoPVVQNFVHRlFPUFpHUlE0RUNJTUZHWENLWjQzU09LRFFHfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野：亚利桑纳<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO60cfA+8mjxMkubWt2fDI1NTA1NjgxM3w4MEY1NTQyOTI5OUJFRThGM0RFODVDNUZBNkFDQzZBNXxoPVBYSFVINUNJNzdCU0FMNkdYQUs0SFFMWEFORTc1NzVBfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAgLSC1pcz0u8TSsKO60cfA+8mjxMkubWt2fDI1NTA1NjgxM3w4MEY1NTQyOTI5OUJFRThGM0RFODVDNUZBNkFDQzZBNXxoPVBYSFVINUNJNzdCU0FMNkdYQUs0SFFMWEFORTc1NzVBfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野第二季第一集<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612tK7vK8ubWt2fDM0MzQ0NTc5MHwwRDc2NDA1QUVDQzA3OTI4NkMxNzhGN0ZBOTZCMTQ3N3xoPUFQSDRSRlJIQU5XRVZMWDdURDNTTURaUEdFUUNLNjdPfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612tK7vK8ubWt2fDM0MzQ0NTc5MHwwRDc2NDA1QUVDQzA3OTI4NkMxNzhGN0ZBOTZCMTQ3N3xoPUFQSDRSRlJIQU5XRVZMWDdURDNTTURaUEdFUUNLNjdPfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野第二季第二集<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612rb+vK8ubWt2fDQyMzE4MDUwMnxDODQxRkRGNDA5ODlCNDZDRTJGNTM2QTlFM0RFMzY1OHxoPUFSM1IyUTJNQ1lLRUw3TFBGNk9IU1lQNTVXQkNUWEROfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612rb+vK8ubWt2fDQyMzE4MDUwMnxDODQxRkRGNDA5ODlCNDZDRTJGNTM2QTlFM0RFMzY1OHxoPUFSM1IyUTJNQ1lLRUw3TFBGNk9IU1lQNTVXQkNUWEROfC9aWg==</a></li>
</ul>
</li>
<li>单挑荒野第二季第三集<ul>
<li><a href="thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612sj9vK8ubWt2fDM3NDE4ODU1OHwwRDNGQjNDRjE4OTAxOUQzQzIzQTI5RjEwNkU3NUI4RHxoPUVJRU5UVDdIQkFTR1c2VUZJSEsyQlpLSElGVVY2VUZOfC9aWg==" target="_blank" rel="noopener">thunder://QUFlZDJrOi8vfGZpbGV8zL3L98a1tcAttaXM9LvE0rC12rb+vL612sj9vK8ubWt2fDM3NDE4ODU1OHwwRDNGQjNDRjE4OTAxOUQzQzIzQTI5RjEwNkU3NUI4RHxoPUVJRU5UVDdIQkFTR1c2VUZJSEsyQlpLSElGVVY2VUZOfC9aWg==</a></li>
</ul>
</li>
<li>单挑绝境荒野系列<ul>
<li><a href="https://pan.baidu.com/s/197CflQ5ITBGQO8mMKIFqOA" target="_blank" rel="noopener">https://pan.baidu.com/s/197CflQ5ITBGQO8mMKIFqOA</a> 提取码: drj2</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>求生</tag>
        <tag>荒野求生</tag>
      </tags>
  </entry>
  <entry>
    <title>English Class Presentation - AirbNb</title>
    <url>/p/8b69a399.html</url>
    <content><![CDATA[<p>Good evening, everyone. I am Lambert.Wang. I’m a common user of AirbNb. Today I’m gonna introduce the famous house sharing website to you. I’ve divided my talk into 4 parts. First, I will give you some basic information about the company. Then I will talk about their vision, goals and strategic partnerships. Next, I will tell you about the customer base and financial highlights. Finally, I will present other information. My presentation will last 4 minutes. I’m happy to field questions at the end of the presentation. Let’s start with company history. AirbNb is founded by Brian Chesky and Joe Gebbia in San Francisco in 2007. Now it has over 3,000,000 lodging listings in 65,000 cities and 191 countries. Right, so the company mission is to help creating a world where you can belong anywhere and where people can live a place, instead of just traveling to it. AirbNb doesn’t provide houses itself. Instead, registered house owners from all over the world are the main partners and AirbNb charges 3%-5% host service fee from them. Now let’s move on to customer base. Well, AirbNb welcomes people from all over the world at any age to use the website for finding their suitable place to live. At most time, customers are at their 20’s to 60’s. Unfortunately, since AirbNb hasn’t started its IPO, the avenue hasn’t been exposed. But considering it fast growth, the profit YoY should be considerable. Finally, the official website of AirbNb is <a href="http://www.airbnb.com" target="_blank" rel="noopener">www.airbnb.com</a>, once you sign up, you will get  a coupon that values 200 RMB. If you use my user-code to register, both you and me will get the coupon. The coupon could be used when you reservation fee is higher than 1000 OK. So this is my presentation and thank you for listening. Any question is welcomed.</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>English Class Presentation - Sled Dogs</title>
    <url>/p/15121cb.html</url>
    <content><![CDATA[<p>[pdf-embedder url=”<a href="http://www.l2h.site/wp-content/uploads/2017/10/Final-Presentation.pdf&quot;]" target="_blank" rel="noopener">http://www.l2h.site/wp-content/uploads/2017/10/Final-Presentation.pdf&quot;]</a> Good evening. Ladies and gentlemen. My name is Lambert. My topic today is about dogs. Have you seen the movie “Eight Below”? It tells how eight sled dogs tried to live in the harsh condition of Antarctic after left behind by a scientific expedition team in the storm. After 5 months when the team came back, 6 of them survived. We all know Antarctic is extremely cold and lack of resource, but who are they, and what makes them survive? You may find the answer from the three kind of dogs that I’m gonna introduce. First of all, I will talk about Siberian Husky. Next, I will introduce Alaskan Malamute. Finally, I will tell you about Samoyed. I will be glad to issue questions at the end of the presentation. Now, Siberian Husky. OK. So much for Husky. We’ll now move on to Malamute. We’ve looked at Malamute. Let’s look now at  Samoyed. That’s all I have to say about sled dogs.</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>周边美食推荐</title>
    <url>/p/254f3134.html</url>
    <content><![CDATA[<p>[pdf-embedder url=”<a href="http://pic.l2h.site/food.pdf&quot;]" target="_blank" rel="noopener">http://pic.l2h.site/food.pdf&quot;]</a> 大家也可以留言推荐您觉得最好吃的成都美食哦 :oops:</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
      <tags>
        <tag>成都</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>《权力的游戏》第八季（最终季）预告片</title>
    <url>/p/97339be2.html</url>
    <content><![CDATA[<p><img src="http://pic.l2h.site/Game-of-Thrones-Final-Season-1024x613.png" alt></p><p>马丁大叔的原著无限期烂尾，好在HBO没有让我们失望。苦等了两年，最终季终于快要上映了。从预告片来看，上映时间是<strong>4.14号</strong>（美国当地时间），这样看来我们能看到大概实在<strong>4.16号</strong>左右。这一季看点：</p><ul>
<li>冰龙和火龙的对决</li>
<li>夜王的身份</li>
<li>龙妈和囧雪的姑侄感情</li>
<li>…….</li>
</ul><p>我写不完了，这么多坑，能填的完不？放上预告片（下载自Youtube，上传到Youku）：</p><a id="more"></a>



<p>[embed]<a href="https://v.youku.com/v_show/id_XNDA5MDcyMTQ0OA==.html?spm=a2hzp.8244740.0.0[/embed]" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDA5MDcyMTQ0OA==.html?spm=a2hzp.8244740.0.0[/embed]</a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>权力的游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>基因编辑婴儿的伦理问题【ZZ】</title>
    <url>/p/5ae31bcc.html</url>
    <content><![CDATA[<p>今天免疫艾滋病基因编辑婴儿出生的新闻刷屏了。转载一篇凤凰网的评论：</p><p><a href="http://tech.ifeng.com/a/20181126/45236568_0.shtml" target="_blank" rel="noopener">原文链接  
</a></p><p><img src="http://e0.ifengimg.com/01/2018/1126/00E86A87F27E7B599DAB2AD9AF40618D2D3936D6_size46_w1024_h572.jpeg" alt></p><p>今早，一条爆炸性的新闻在国内生物科学界传开，南方科技大学的副教授贺建奎，突然在“第二届国际人类基因组编辑峰会”召开的前一天宣布，一对基因编辑婴儿已经于11月在中国诞生。通过特定的基因修改，她们出生之后“即能天然抵抗艾滋病”，这也是世界首例免疫艾滋病的基因编辑婴儿。</p><a id="more"></a>



<p>基因编辑向来会牵扯到伦理问题，贺建奎团队为此提供的伦理审核资料来自深圳一家不知名的医院——和美妇儿科医院。目前，该医院已经被证明的确属于“莆田系”医院，其创始人名为林玉明，的确是莆田系人士，并且曾在采访时明确表达自己是“莆系医院”。</p>
<p>消息一出，，国内生物医学界普遍持负面的态度，而普通群众则纷纷看不懂其中的过程。接下来，虎嗅就来为你解释一下为什么这次事件应该被黑。</p>
<p>所采用的基因编辑技术并不算突破</p>
<p><img src="http://e0.ifengimg.com/03/2018/1126/D290F172776C04FA015CDF4854FBDA8DEA4DA7D4_size440_w1000_h1027.png" alt></p>
<p>CRISPR工作原理（图自CUP）</p>
<p>这次婴儿基因编辑所采用的的技术名为“CRISPR/Cas9”。“CRISPR/Cas9”是目前研究最深入、应用最成熟的“基因工具”，整体原理上借助了基因的运转机制（基因最终指导蛋白质的形成），来对基因特定的片段进行编辑，其最大的突破在于编辑的环境条件很低，只需要在实验室中进行即可。</p>
<p>而在这次编辑中，贺建奎团队所做的主要是去除了“CCR5”基因片段上的32个碱基片段（基因的基础组成），使其便成为“CCR5 Δ32（三角形念‘Delta’）”，最终影响生成的蛋白质物质。</p>
<p>在基础原理之上，宏观的操作并不复杂，只比常规试管婴儿多一个步骤：在受精卵使其，将特定的物质，通过极细的针注射到单细胞的受精卵里面。</p>
<p>需要注意的是，本次采用的试管婴儿技术的确很成熟，但基因编辑技术至今没有尝试对人类基因进行编辑，是否能保持其他物种中的准确率仍不可知。在其上交给深圳医院的伦理审查申请书中，就专门标注了“要针对基因编辑脱靶进行监测”，但此前人类基因编辑并没有成功监测脱靶（编辑了不应该编辑的基因片段）的案例，而贺建奎团队也没有详细说明这个监测的过程和结果。</p>
<p>整体而言，基因编辑婴儿案例中基本使用的都是成熟的生物技术，部分全新的技术也并没有进行详细的说明解释</p>
<p>“CCR5 Δ32”基因防艾滋，靠谱么？</p>
<p>这一基因也不是本次案例的成果，而是一种普遍存在于白种人人群的基因序列，是自然界变异而生的一种基因。</p>
<p>根据虎嗅采访到的业内生物医学界人士解释：这种基因最近1000年左右才在白种人群众传播开来，它的出现，极有可能是欧洲数次大型瘟疫（典型的如天花）的结果，在这个过程中，拥有“CCR5 Δ32”基因的人被筛选出来。</p>
<p>之后人们逐渐发现白种人中拥有“CCR5 Δ32”基因的人，能够比较有效地防止“HIV-1（艾滋病病毒1型）”的传染，而“HIV-1”也是目前全球内主要传播和感染率较高的艾滋病病毒。</p>
<p>但目前国际上的确对于基因防控艾滋病没有太深入的研究，业内人士向虎嗅表示：“‘CCR5 Δ32’能否在白种人之外起到同样的艾滋病阻断作用没有人知道，是否会产生副作用也没人知道。”  </p>
<p>基因编辑婴儿防艾滋，为啥要这样做？</p>
<p><img src="http://e0.ifengimg.com/04/2018/1126/89771E4560EB412465B8FF26644F36B5918C923D_size37_w1000_h600.jpeg" alt></p>
<p>艾滋病病毒</p>
<p>就目前而言，婴儿防艾滋主要是因为父母已经感染，遂采取措施防止下一代感染。除了基因编辑以外，服用阻断药物也是一个方法。根据2015年中国疾控中心的相关论文，母婴之间的艾滋病阻断花费在8.3-5万元，并且成功率高达98%以上。  </p>
<p>相比之下，基因编辑方式中，虽然编辑基因这一环节成本很低，但是其必须在体外对受精卵进行一系列操作，同时还要保持受精卵的活性，最终还要将受精卵重新放回子宫中。整体花费上往往要超过10万，并不会更划算。</p>
<p>从原理上说，本次基因编辑婴儿的目的是“改变特定的蛋白质”，而阻断药物则是“用特定的蛋白质、提前和病毒对应的蛋白质结合”，原理上比较接近于“挖墙脚”。</p>
<p>两种方式的最终目的都是想让婴儿不被传染上艾滋病，根据澎湃新闻报道，贺建奎曾在美联社的报道中明确表示：“参与该项目的所有父亲都感染了艾滋病毒，而母亲都没有。”他同时还特别表示：“因编辑的目的不是为了防止小的传播风险，而是为感染艾滋病毒的夫妇提供一个机会，让他们有机会生下一个可能免受类似命运影响的孩子。”</p>
<p>有一点必须提到的是，试管婴儿还可以用于不孕不育的治疗，同时也是代孕的必须环节。目前后者在国内是违反相应法规的。</p>
<p>重点，严重缺失的过程</p>
<p>此次贺建奎团队在宣布成果之前所进行的伦理审核是一个大家讨论的重点，根据国家卫计委2016年出台的《涉及人的生物医学研究伦理审查办法》中的第十四条，所有医疗卫生机构的伦理委员会都必须向卫计委登记备案，目前无法确认深圳和美妇儿科医院是否有完善该手续。</p>
<p>而就在数分钟之前，南方都市报的记者从深圳和美妇儿科医院前医务部主任秦苏骥了解到：他那段时间也在伦理委员会担任委员，但对于这项申请并没有印象。而文件中出现了签名的在职前同事们除了表示没印象之外，还表示签名不是自己的。</p>
<p>除此之外，贺建奎团队宣布消息的方式也让业内人士诧异，其对虎嗅表示：“一上来就给熟饭，这真的是太粗暴了。这个操作的计划之前也完全没有对外公布，临床试验的注册更是不知道怎么通过的，更不要讲什么‘同行评审’了，完全就是胡闹”。</p>
<p>骤然打开的潘多拉魔盒</p>
<p><img src="http://e0.ifengimg.com/04/2018/1126/BB6991EE1451498CEB4E6E73F35D6EA15DD387F3_size55_w1000_h663.jpeg" alt></p>
<p>基因技术发展已经多年，在各类动物上已经进行了多种多样的试验，但是大家对于在人类身上实践基因技术仍十分谨慎。</p>
<p>据某不具名国内民营基因从业人士表示：“基因技术就是一把刀，一把特别特别锋利的刀，你拿的时候都要小心划伤自己，更不要提有个人突然告诉你他刚才拿着它杂耍了一番。”</p>
<p>而在数分钟前，贺建奎本人也发布了一个视频回应质疑，他表示：“基因编辑只是想帮助致命遗传病家庭，这些父母眼睁睁地看着孩子饱受遗传疾病的痛苦。”同时他还特别表示，“我拒绝基因增强、性别选择或者改变皮肤眼睛的颜色，因为这些不能算是对孩子真正的爱。”</p>
<p>他所描述的其他基因修改可能也正是被业内人士批评最凶的一点——他明显明白动人类基因这件事需要多谨慎，而且还说出了只想治病、不想变成人类定制。但他这种“先斩后奏”，同时为人类增加“能力（抗病性）”的做法就是在打开“潘多拉”的魔盒。</p>
<p>一来我们暂且无法检测这次的基因编辑婴儿是否真的形成了艾滋病传染抵抗力（要测试必须植入病毒），二来这批婴儿未来的副作用影响是否会出现，以及是否能够监测出所有的变化同样疑问重重。</p>
<p>虎嗅采访的数位行业内人士普遍都表示，基因技术的确已经比较先进，但人类接受基因技术、合理运用基因技术必然需要一个合适的过程。而此次的事件，无疑已经对普通民众的观念，还有相关机构的审核管理产生了巨大的压力。这必将为基因技术的进一步应用和普及产生一定的影响。</p>
<p>所以不管是否最终这次的婴儿能够具备艾滋病抵抗力，又或者是能开创人类应用基因技术的世代，这种“冒险且不负责任”的做法都应该值得“被黑”。</p>
<p>因为用过播放器的人都知道：快进键旁边，往往就是终止键</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>为你的博客开出地狱模式</title>
    <url>/p/6ae84648.html</url>
    <content><![CDATA[<h1 id="双击会有惊喜哦！"><a href="#双击会有惊喜哦！" class="headerlink" title="双击会有惊喜哦！"></a>双击会有惊喜哦！</h1><p>引用自<a href="https://maicong.me/t/250" target="_blank" rel="noopener">麦葱的博客 </a> ， 对源码做了一点修改提升手机平板上的点击体验。目前本站只有本篇博文有此效果 ![为你的博客开出地狱模式](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-20 下午8.53.10.png “为你的博客开出地狱模式”)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span></span><br><span class="line"><span class="xml"> var __timeout;</span></span><br><span class="line"><span class="xml"> var __lastTap = 0;</span></span><br><span class="line"><span class="xml"> var __tapNum = 0;</span></span><br><span class="line"><span class="xml"> var hell = function hell() &#123;</span></span><br><span class="line"><span class="xml"> var hell = document.getElementById('hell');</span></span><br><span class="line"><span class="xml"> if (hell) &#123;</span></span><br><span class="line"><span class="xml"> hell.parentNode.removeChild(hell);</span></span><br><span class="line"><span class="xml"> &#125; else &#123;</span></span><br><span class="line"><span class="xml"> var style = document.createElement('style');</span></span><br><span class="line"><span class="xml"> style.id = 'hell';</span></span><br><span class="line"><span class="xml"> style.textContent = 'body&#123; background:black; -webkit-transform: scale(-1,1); -ms-transform: scale(-1,1); transform: scale(-1,1); -webkit-filter: sepia(0) saturate(0) invert(1) brightness(1) contrast(1); filter: sepia(0) saturate(0) invert(1) brightness(1) contrast(1); &#125;';</span></span><br><span class="line"><span class="xml"> document.head.appendChild(style);</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"> &#125;;</span></span><br><span class="line"><span class="xml"> document.addEventListener('dblclick', hell, false);</span></span><br><span class="line"><span class="xml"> document.addEventListener('touchend', function () &#123;</span></span><br><span class="line"><span class="xml"> var currentTime = new Date().getTime();</span></span><br><span class="line"><span class="xml"> var tapInt = currentTime - __lastTap;</span></span><br><span class="line"><span class="xml"> ++__tapNum;</span></span><br><span class="line"><span class="xml"> clearTimeout(__timeout);</span></span><br><span class="line"><span class="xml"> if (tapInt <span class="tag">&lt; <span class="attr">500</span> ) &#123;</span></span></span><br><span class="line"><span class="xml"> if (tapInt &gt; 0) &#123;</span></span><br><span class="line"><span class="xml"> if(0 == __tapNum%2) &#123;</span></span><br><span class="line"><span class="xml"> hell();</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"> &#125;</span></span><br><span class="line"><span class="xml"> __lastTap = currentTime;</span></span><br><span class="line"><span class="xml"> &#125;);</span></span><br><span class="line"><span class="xml">&#125;)();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>民宿经营 -- L&amp;H Site 装修体会</title>
    <url>/p/ed3e5bd2.html</url>
    <content><![CDATA[<p>原文发表在知乎</p>
<p><a href="https://www.zhihu.com/question/30253115/answer/290164904" target="_blank" rel="noopener">作为 Airbnb 房东，你对自己出租的空间有哪些装点心得？ - 知乎</a></p>
<p><img src="https://static.zhihu.com/static/favicon.ico" alt> <a href="https://www.zhihu.com/question/30253115/answer/290164904" target="_blank" rel="noopener"> www.zhihu.com</a></p>
<p>做民宿刚满一年，分享几点心得： </p>
<ol>
<li>房子基装一定要选好品牌，省去维护烦恼 我们家是去年购买的二手房，原房东是自住的，所以基础装修比较好。马桶，淋浴等都是用科勒的，看上去就厚重，结实。后续也没有额外投入，省心！ </li>
<li>软装要有自己的风格 我们房间在成都，标志就是四川的大熊猫啦。所以卧室在原装修白墙的基础上，选择了熊猫的壁纸。卫生间马桶也有粘熊猫的马桶贴。 另外，更换了卧室和客厅原来的吸顶灯。虽然原来是欧普的，质量很好，但是与我们期望的格调不搭，有点偏中年风。换成了宜家最基础款的麦勒迪吊灯，灯泡也换成了宜家暖色的LED高流明灯泡 </li>
<li>与装修无关：房间消耗品也请尽量选择高质量的品牌 不要贪图便宜买低价的纸巾、洗发水、沐浴液等，省掉小钱的同时，带来的是客人入住感受的降低。 </li>
<li>对兼职房东很重要：若要远程管理，请配上智能门锁。 我们是兼职搞的民宿。自己到淘宝买的果加门锁（后来发现小猪，途家房东都可以低价申请丁丁或者果加门锁，很方便），因为房间位置非常好找，不用亲自迎接客人，全程自助服务。 房间维护方式为申请小猪管家帮忙打扫（一般会请熟人，不用每次交代），自己只需定期去补充生活用品。 房间提供一些额外的需求品，如公交卡、门禁卡、雨伞等 暂时就这么多。目前认为自己的客厅装点比较差，也希望花时间去改进。欢迎各位交流。</li>
</ol>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
      <tags>
        <tag>airbnb</tag>
        <tag>L2H</tag>
        <tag>小猪</tag>
        <tag>民宿</tag>
        <tag>装修</tag>
        <tag>途家</tag>
      </tags>
  </entry>
  <entry>
    <title>L&amp;H的阆中之行</title>
    <url>/p/92f7e8b3.html</url>
    <content><![CDATA[<p>阆中，位于四川西北部，距离成都262公里，距重庆279公里。从地图上看，与这两个大城市呈一个等腰三角形。阆中地理位置优越，是古代军事要地，三国名将张飞曾在此驻防。</p><p><strong><img src="https://dimg02.c-ctrip.com/images/100p0k000000b4bvw3E02_R_800_10000.jpg" alt></strong></p><p>今年由于事情繁多，一直没有真正出过门，简直憋坏了。趁着周末，和老婆商量来一次近距离自由行，在乐山和阆中摇摆了一天。考虑到最近央视看到的宣传片，最终敲定阆中。</p><a id="more"></a>


<p> 直接买了动车票周六当天往返。由于往返阆中只有这么两班时间合适的动车，而自己所住地方较远。所以关掉两天房态，自己住小站民宿。</p>
<p>早上六点半出门，打车20分钟到达东站（18元）。额，起早了，足足等了将近一个小时才出发。</p>
<p><img src="https://dimg02.c-ctrip.com/images/100e0k000000b5vtaDA9A_R_800_10000.jpg" alt> 由于成都下了一整周的雨，出门前还担心下雨影响游玩，没想到到了阆中居然完全放晴（也多亏自己多年来出门旅行从来都是晴天的奇妙记录），顿时心情大好。阆中动车站是在郊区，下图为下车后所拍（有没有种小清新的感觉？） 。</p>
<p><a href="https://dimg09.c-ctrip.com/images/100w0k000000balsrC12C_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg09.c-ctrip.com/images/100w0k000000balsrC12C_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg08.c-ctrip.com/images/10010k000000b9jm1F836_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg08.c-ctrip.com/images/10010k000000b9jm1F836_R_800_10000_Q90.jpg" alt></a></p>
<p>公交车（2元）到达景区，标准的古镇建筑风格，依山傍水。</p>
<p>古镇本身不收费，但古镇内的古建筑（张飞庙、中天楼、贡院等收费），套票120。我们是在携程提前几天预定，价格100一张（还包含了4A级风景区天宫院门票，距离古镇17公里，可惜由于当天起床太早觉得累就没去）</p>
<p><img src="https://dimg08.c-ctrip.com/images/100u0k000000b487q2F2E_R_1024_10000_Q90.jpg" alt></p>
<p>华光楼上所照</p>
<p><a href="https://dimg06.c-ctrip.com/images/100n0k000000b4db28967_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/100n0k000000b4db28967_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg05.c-ctrip.com/images/10090k000000b838aEF94_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/10090k000000b838aEF94_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg02.c-ctrip.com/images/100h0k000000b5ff2ABFF_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg02.c-ctrip.com/images/100h0k000000b5ff2ABFF_R_800_10000_Q90.jpg" alt></a></p>
<p>楼内陡直的楼梯，女房东吓坏了</p>
<p><img src="https://dimg06.c-ctrip.com/images/100r0k000000b4azq53B3_R_1024_10000_Q90.jpg" alt></p>
<p>古镇街道，到处是卖醋的，遍地酸爽</p>
<p><a href="https://dimg05.c-ctrip.com/images/100k0k000000b55u7555E_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg05.c-ctrip.com/images/100k0k000000b55u7555E_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg03.c-ctrip.com/images/10020k000000b8bcwE812_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg03.c-ctrip.com/images/10020k000000b8bcwE812_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg01.c-ctrip.com/images/100s0k000000baalx615D_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg01.c-ctrip.com/images/100s0k000000baalx615D_R_800_10000_Q90.jpg" alt></a></p>
<p><a href="https://dimg06.c-ctrip.com/images/10080k000000b5snt1E22_R_1024_10000_Q90.jpg" title="点击查看原图" target="_blank" rel="noopener"><img src="https://dimg06.c-ctrip.com/images/10080k000000b5snt1E22_R_800_10000_Q90.jpg" alt></a></p>
<p><img src="https://dimg02.c-ctrip.com/images/10080k000000b5tcu6519_R_800_10000.jpg" alt></p>
<p><img src="https://dimg02.c-ctrip.com/images/10030k000000b7g8b0405_R_800_10000.jpg" alt></p>
<p>最后附上自己靓照一张 <img src="https://dimg02.c-ctrip.com/images/10010k000000b9lqj3A0B_R_800_10000.jpg" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>周末游</tag>
        <tag>四川</tag>
        <tag>阆中</tag>
      </tags>
  </entry>
  <entry>
    <title>L&amp;H Site客人留言I</title>
    <url>/p/f4bb20e1.html</url>
    <content><![CDATA[<p>虽然做民宿很辛苦，偶尔也会产生将房子直接长租出去的想法。但是看到客人留言薄的留言，满满的感动，有了继续前进的动力。现在贴上部分客人的留言：<br><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231654_meitu_2.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"> </p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231704_1_meitu_3.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"></p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231717_1_meitu_4.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"></p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231734_1_meitu_5.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"></p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231743_1_meitu_6.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"></p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20180420_231748_1_meitu_7.jpg" alt="L&amp;H Site客人留言I" title="L&amp;H Site客人留言I"></p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>L&amp;H的201809香港2日行-与台风山竹的擦肩而过</title>
    <url>/p/eabdf665.html</url>
    <content><![CDATA[<p>此行香港 ，有一直以来的向往，也有自己的小小私心。总之，订上川航的机票，办好通行证签注，没做任何规划变匆忙前来。 <strong>整体的感受</strong>： 香港 的吃住行成本高，因为免税关系，穿着成本相对内地要低不少。但是人多，街头总是有各色人种匆匆地攒动着自己，压缩着本地人本就狭窄的生活空间。加上炎热的天气，极大降低着旅行体验，和当地人的生活体验。 因为建城早，道路规划狭窄，但因为驾驶员极其遵守交规，从不乱变道。因为车速快，且没有几乎自行车和电瓶车，行人亦更遵守规则，总体交通却更通畅。 总之， 香港给我的感觉：一个不是特别生活的人均素质高的现代化老城市。 <strong>以下为游记</strong>： 周四下午到达 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> ，住宿在佐敦，地理位置，交通等非常方便，步行到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10892.html" target="_blank" rel="noopener">维多利亚</a> 港只要15分钟。 图为400多一晚的民宿房，像鸽子笼有没有？</p><a id="more"></a>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486835.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/16/DB/wKgED1uoikeALptLABh36BYIxCo27.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486848.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/16/E3/wKgED1uoikqARP2ZABfB2mAWsOI19.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>鱼丸面：面的碱味很大，也很清淡，吃惯了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/12703.html" target="_blank" rel="noopener">四川</a> 味道的我们有点吃不惯</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486228.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/16/40/wKgED1uoic2ACx3_ABeCQgO7S_A69.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>晚上八点， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10892.html" target="_blank" rel="noopener">维多利亚</a> 港，参观中环建筑的灯光秀</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486854.html" target="_blank" rel="noopener"><img src="https://n2-q.mafengwo.net/s12/M00/16/EA/wKgED1uoik2AZ6Y_AAjRWAhIWwc41.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486850.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/16/E5/wKgED1uoikuAaH5tAAiy-y8N6DA61.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486261.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/16/48/wKgED1uoidOAUy61ABYeN9s61jA63.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491192.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/1A/EA/wKgED1uojcqAI75DAB35pthwFEY46.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>街头随拍：网红打卡冰激凌车，冰激凌10元一个，味道超甜</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378488817.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/18/BC/wKgED1uojBOACx3mAA4q2RTab3s69.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>街头随拍</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486197.html" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s12/M00/16/3B/wKgED1uoicWAQ5qqABbH0rrlEzE70.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> 果然是金融中心，遍地可见银行保险等金融机构。</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491970.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/1B/96/wKgED1uojkWACSxWABosUHiEXzI12.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>中环街头</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491979.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/1B/99/wKgED1uojkiAJQW_AAwHCzfZWjU14.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63005.html" target="_blank" rel="noopener">九龙</a> 半岛酒店</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491417.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/1B/24/wKgED1uojfCAbFksAByfuPF2fHw63.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63005.html" target="_blank" rel="noopener">九龙</a> ，尖沙咀附近</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486253.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/16/46/wKgED1uoidCAd8iHABxD9AuUuZc33.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491497.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/1B/2A/wKgED1uojfSAJ7YaAAsNZB_jE5U70.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378499023.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/21/8F/wKgED1uokm6AfoRkAAqioqLJALQ49.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486749.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/16/C6/wKgED1uoijiAReOyAB-ZrKg2wog46.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486210.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/16/3D/wKgED1uoicqAZj8EAB_aeSO1DhE36.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>著名网红打卡地，鰂鱼涌。也是变形金刚4取景点。因为过多游客涌入，对居民生活带来极大干扰。居民已经与政府制定制度不允许游客进入。</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486772.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/16/CA/wKgED1uoijqAdYJ-AAvBGRSlUkU07.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> 中文大学，离闹市区较远，在一座山上。因为学校很大，校园内得坐交通车</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491720.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/1B/51/wKgED1uojhOAIshjAB5vnkIqhoU52.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378491725.html" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s12/M00/1B/53/wKgED1uojhWAMk9XAA4QKSLn2C417.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>中环的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> 大学，面积就小中文大学很多了。历史相对更久，整个学校以民国时期老建筑为主，徜徉在内感觉也更舒服</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486786.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/16/CD/wKgED1uoij2AJ2ehAB0EstJv2Zg93.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486815.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/16/D1/wKgED1uoikCALHRnAA25xMKYOgA36.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378489218.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/19/3B/wKgED1uojH2AfaGyAB9CTiMt0hU58.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378489228.html" target="_blank" rel="noopener"><img src="https://n2-q.mafengwo.net/s12/M00/19/3F/wKgED1uojICANIYgABt9FLj2wfY84.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486823.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/16/D6/wKgED1uoikSAOz-OAB91C-H-_Ig41.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>太 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17730.html" target="_blank" rel="noopener">平山</a> 顶， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> 全景一览无余</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486189.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/16/3A/wKgED1uoicOAP_jvABiPM-TZ_go47.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378490908.html" target="_blank" rel="noopener"><img src="https://p2-q.mafengwo.net/s12/M00/1A/B5/wKgED1uoja-AN2ggAAtzA-4kYBo67.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378490917.html" target="_blank" rel="noopener"><img src="https://p3-q.mafengwo.net/s12/M00/1A/B8/wKgED1uojbKAZy0yABO2t64xRFQ17.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>最爱的地方，也是著名网红打卡点，石澳健康院，大家熟悉吗？星爷的喜剧之王取景点</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378500096.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/22/50/wKgED1uokueAPi2XAAdZSjuHXKU60.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378500101.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/22/51/wKgED1uokuiAToL8AAajZ5z7nzk47.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378488807.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/18/B8/wKgED1uojA-AANZqABubipeammw68.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378492143.html" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s12/M00/1B/BE/wKgED1uojmiAdrNoAAcm-CNyye404.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>传说中的米其林一星餐厅，甘牌烧鹅。价格小贵，味道一般。考虑到其服务态度与味道，川内很多餐厅可获米其林评级。</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486286.html" target="_blank" rel="noopener"><img src="https://p4-q.mafengwo.net/s12/M00/16/53/wKgED1uoidmATQG4ABRQ7_RyZ-Y52.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486277.html" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s12/M00/16/4D/wKgED1uoidaAF5qXABeBshxNULo46.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>最后，重点是山竹。原定周日9月16返回 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> ，因为传说中 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10189.html" target="_blank" rel="noopener">香港</a> 经历的台风之王的关系，不得不改签早一天返回的机票。而且只有会 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10208.html" target="_blank" rel="noopener">重庆</a> 的票了。 这里要大赞一下AirbNb,因为提前返回住宿不得不退订。在房东不同意退款的前提下，补给了我一晚上房费！强烈推荐！</p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378498238.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/21/0C/wKgED1uokhiALQ6oAAlr7Dq-bWg18.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378500960.html" target="_blank" rel="noopener"><img src="https://p1-q.mafengwo.net/s12/M00/22/D8/wKgED1uok1aAWJpQAAPxSzHSd1Y75.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378500962.html" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s12/M00/22/DA/wKgED1uok1eAC5nUAAGQTZf1lbg63.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486299.html" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s12/M00/16/55/wKgED1uoidmAdyqNAAM5TpCTDCs21.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/10189/scenery_10615506/378486303.html" target="_blank" rel="noopener"><img src="https://b3-q.mafengwo.net/s12/M00/16/58/wKgED1uoidqAKDrXAAHDXQwLdsQ09.jpeg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>香港</tag>
      </tags>
  </entry>
  <entry>
    <title>假打</title>
    <url>/p/256b71dc.html</url>
    <content><![CDATA[<p>  李伯清是四川刘德华，全民男神，这个段子把我笑疼了，百看不厌。 假打，原来就是假装打电话的意思，哈哈哈。耐心等35秒广告，有惊喜 :mrgreen: P.S. 图片骗赞<a href="https://v.qq.com/x/page/q0674ep1t8b.html" target="_blank" rel="noopener">https://v.qq.com/x/page/q0674ep1t8b.html</a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
      <tags>
        <tag>李伯清</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备驱动模型-- 数据结构Kset/KObject</title>
    <url>/p/84af2ef0.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kset和kobject是Linux设备驱动模型中的核心数据结构，其主要作用是将系统中的设备抽象出来，以树状结构组织，方便系统统一管理。</p><p>而这个统一管理的地方，就是sysfs，先放一张示例图，阐明一下kset和kobj的关系:</p><ul>
<li>kset指向的是设备驱动模型中sysfs中的目录</li>
<li>kobject指向的是目录中的子节点（注意：目录本身也是节点）</li>
<li>sysfs子目录每一项kobj是使用该级目录对应kset的下的链表连接</li>
</ul><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   kset(/sys/bus)</span><br><span class="line">                    +--------+</span><br><span class="line">                    | kobj   |</span><br><span class="line">                    |        |</span><br><span class="line">                    +--------+</span><br><span class="line">                    | list   |</span><br><span class="line">       +------------+--------+</span><br><span class="line">       |</span><br><span class="line">       |</span><br><span class="line">       |                      /sys/bus/pci</span><br><span class="line">       v                       +--------+</span><br><span class="line">/sys/bus/term1   /sys/bus/term2|        |</span><br><span class="line">  +--------+     +--------+    |  kobj  |</span><br><span class="line">  |        |     |        +---&gt;+        |</span><br><span class="line">  | kobj   +----&gt;+ kobj   |    +--------+</span><br><span class="line">  |        |     |        |    | list   |</span><br><span class="line">  +--------+     +--------+    +---+----+</span><br><span class="line">                                   |</span><br><span class="line">                                   v</span><br><span class="line">                        /sys/bus/pci/term3</span><br><span class="line">                               +--------+</span><br><span class="line">                               | kobj   |</span><br><span class="line">                               +--------+</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>kobject的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kset</span>		*<span class="title">kset</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>	*<span class="title">ktype</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kernfs_node</span>	*<span class="title">sd</span>;</span> <span class="comment">/* sysfs directory entry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>		<span class="title">kref</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_KOBJECT_RELEASE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span>	<span class="title">release</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ul>
<li>name: 在sysfs下的名称</li>
<li>entry: kobject链表项，将该kobject串入链表</li>
<li>parent: 父级kobject</li>
<li>kset: 所属的kset</li>
<li>ktype: kobject对应的属性</li>
<li>sd: sysfs对应的目录项</li>
<li>kref: 原子操作引用计数</li>
<li>state_initialized : 是否初始化</li>
<li>state_in_sysfs: 该Kobject是否已在sysfs中呈现</li>
<li>state_add_uevent_sent/state_remove_uevent_sent: 记录是否已经向用户空间发送ADD uevent，如果有，且没有发送remove uevent，则在自动注销时，补发REMOVE uevent，以便让用户空间正确处理</li>
<li>uevent_suppress: 是否 忽略所有上报的uevent事件</li>
</ul>
<p>kobj_type也定义在kobject.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">release</span>)(struct kobject *kobj);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_ops</span> *<span class="title">sysfs_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> **<span class="title">default_attrs</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_ns_type_operations</span> *(*<span class="title">child_ns_type</span>)(<span class="title">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">namespace</span>)(struct kobject *kobj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>release: 释放kobject所使用资源的回调函数</li>
<li>sysfs_ops: 顾名思义，与sysfs相关的操作</li>
<li>default_attrs: 保存类型属性的列表</li>
<li>chind_ns_types/namespace: 文件系统命名空间相关参数</li>
</ul>
<p>而kset的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释如下：</p>
<ul>
<li>list: 该kset下所有的kobject的链表</li>
<li>list_lock: 链表访问的自旋锁</li>
<li>kobj: kset对应的kobject</li>
<li>uevent_ops: uevent事件上报相关操作</li>
</ul>
<h2 id="kobject和kset操作"><a href="#kobject和kset操作" class="headerlink" title="kobject和kset操作"></a>kobject和kset操作</h2><h3 id="kobject操作"><a href="#kobject操作" class="headerlink" title="kobject操作"></a>kobject操作</h3><p>kobject相关操作定义在 include/linux/kobject.h中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(struct kobject *kobj, struct kobj_type *ktype)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(struct kobject *kobj, struct kobject *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(struct kobject *kobj,</span></span></span><br><span class="line"><span class="function"><span class="params">			 struct kobj_type *ktype, struct kobject *parent,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(struct kobject *kobj)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct kobject * __must_check <span class="title">kobject_create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct kobject * __must_check <span class="title">kobject_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,struct kobject *parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> __must_check <span class="title">kobject_rename</span><span class="params">(struct kobject *, <span class="keyword">const</span> <span class="keyword">char</span> *new_name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> __must_check <span class="title">kobject_move</span><span class="params">(struct kobject *, struct kobject *)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>kobject_init： 已经分配好kobject的前提下，将kobj内的相关字段初始化。ktype为kobj的属性</li>
<li>kobject_add: 将该kobject加入到 sysfs树里</li>
<li>kobject_init_and_add： 同时调用kobject_init 和 kobject_add</li>
<li>kobject_del：将kobject从 sysfs树里去掉</li>
<li>kobject_create/kobject_create_and_add：向内核申请kboject空间，ktype使用系统全局的dynamic_kobj_ktype</li>
<li>kobject_rename: 修改kobject在sysfs树的名称</li>
</ul>
<h3 id="kset操作"><a href="#kset操作" class="headerlink" title="kset操作"></a>kset操作</h3><p>kset相关操作如下（同样定义在 include/linux/kobject.h 中）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">kset_init</span><span class="params">(struct kset *kset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> __must_check <span class="title">kset_register</span><span class="params">(struct kset *kset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(struct kset *kset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct kset * __must_check <span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct kset_uevent_ops *u,struct kobject *parent_kobj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kset *<span class="title">to_kset</span><span class="params">(struct kobject *kobj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kset *<span class="title">kset_get</span><span class="params">(struct kset *k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kset_put</span><span class="params">(struct kset *k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct kobj_type *<span class="title">get_ktype</span><span class="params">(struct kobject *kobj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> struct kobject *<span class="title">kset_find_obj</span><span class="params">(struct kset *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>kset_init: 与kobject类似，将已经分配空间的kset初始化</li>
<li>kset_register: 初始化一个kset，加入到sysfs树里</li>
<li>kset_unregister: 将kset从sysfs树里移除，并将对应kobject删除</li>
<li>kset_create_and_add: 创建kset并加入sysfs树里</li>
<li>to_kset：从kobject找到对应kset</li>
<li>kset_get: 增加kset对应kobject引用记数</li>
<li>kset_put: 释放对kset对应kobject的 引用记数</li>
<li>get_ktype: 从kobject得到ktype</li>
<li>kset_find_obj: 从set下找到对应名称的kboject</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>待添加</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>KOBJ</tag>
        <tag>KSET</tag>
        <tag>设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断学习笔记(1)</title>
    <url>/p/b98bc7cc.html</url>
    <content><![CDATA[<h1 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h1><p>CPU获取外设状态变化有两种方式:</p><ul>
<li>Polling：不断跟外设询问它的状态</li>
<li>当外设状态变化后主动通知CPU</li>
</ul><p>CPU要负责处理系统中各种各样的业务，如果频繁地轮询外设状态，必然会对整个系统的吞吐量产生影响，影响操作系统的正常运作。 中断便是外设通知CPU其状态变化的一种机制。CPU会有中断线，由中断控制器的输出线连接。中断控制器作用：</p><a id="more"></a>


<ul>
<li>中断优先级处理</li>
<li>接收中断控制器ACK</li>
<li>分发中断</li>
</ul>
<p>中断控制器连接到MCU的中断输入引脚（在ARM就是IRQ-Interrupt Request or FIQ-Fast Interrupt Request信号线）。中断控制器驱动负责Kernel中断号与物理中断号的Mapping。 当外设没有变化的时候，CPU可以专心地处理其他事务。外设准备好资料时，通过中断控制器通知CPU，CPU再对其进行相应的处理。</p>
<h1 id="Linux的中断处理"><a href="#Linux的中断处理" class="headerlink" title="Linux的中断处理"></a>Linux的中断处理</h1><h2 id="顶半部（Top-Half）和底半部（Bottom-Half）"><a href="#顶半部（Top-Half）和底半部（Bottom-Half）" class="headerlink" title="顶半部（Top Half）和底半部（Bottom Half）"></a>顶半部（Top Half）和底半部（Bottom Half）</h2><p>中断会将正在运行的程序给打断（操作系统会保留相应的执行数据以便返回）。外设中断有时要处理的数据量很大，为了避免中断处理长期占用CPU导致系统中其他事务无法正常进行，Linux将中断处理分为顶半部和底半部。顶半部主要负责响应中断，处理该外设一些必须的业务，同时将需要复杂处理的事务放到底半部执行。 Linux中中断的顶半部是不能被Block的，原因： <em>操作系统并没有为中断分配相应的进程管理单元，当中断服务例程因为发生Block而被系统Schedule出去后，便无法再返回到该中断服务例程。而因为中断被调度出的进程，被schedule后却不能得到调度。</em> 实现底半部有多种方式，常用的是Tasklet（特殊的软中断）和Workqueue（内核线程）</p>
<h3 id="软中断和Tasklet"><a href="#软中断和Tasklet" class="headerlink" title="软中断和Tasklet"></a>软中断和Tasklet</h3><p>当中断上半部执行结束后，操作系统会调度执行软中断。具体实现以linux-4.x为例：</p>
<p>./kernel/softirq.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_do_IRQ</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct pt_regs *regs)</span>                <span class="comment">//中断向量表调用相应的IRQ处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> = <span class="title">set_irq_regs</span>(<span class="title">regs</span>);</span>                      <span class="comment">//保留中断现场</span></span><br><span class="line"></span><br><span class="line">    irq_enter();                                                        <span class="comment">//进入中断处理前的必要处理，如关闭硬件中断,关闭抢占（preempt），禁止ksoftirqd启动处理（softirq）-- 因为稍后会看到，中断结束后会做处理</span></span><br><span class="line">    generic_handle_irq(irq);                                            <span class="comment">//执行外设驱动注册的irq handler</span></span><br><span class="line">    irq_exit();                                                         <span class="comment">//进入到irq_exit</span></span><br><span class="line">    set_irq_regs(old_regs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ARCH_IRQ_EXIT_IRQS_DISABLED</span></span><br><span class="line">    local_irq_disable();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    account_irq_exit_time(current);</span><br><span class="line">    preempt_count_sub(HARDIRQ_OFFSET);                                 <span class="comment">//打开抢占</span></span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())                    <span class="comment">//如果有软中断pending，执行softirq</span></span><br><span class="line">        invoke_softirq();</span><br><span class="line">    tick_irq_exit();</span><br><span class="line">    rcu_irq_exit();</span><br><span class="line">    trace_hardirq_exit(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，软中断是在中断处理进程退出后，立即执行。软中断处理函数，会检查当前系统中有哪些软中断，然后循环执行。因为系统仍有很多任务要处理，包括之前被抢占的任务，因此kernel不会无限度的将时间片都留给软中断。它设置了一个软中断循环执行的最大次数。当超过这个次数后，就退出软中断执行，并将内核线程ksoftirqd叫起。 ksoftirqd是内核线程，他与系统中其他线程包括用户态进程一起接受系统调度。因此保证了未完成的软中断也可再后来继续执行完毕。 Tasklet是一种特殊的软中断。Workqueue是一种特殊的内核线程。它们都是实现中断下半部的方式。具体用法可在有使用需求时查看。</p>
<h2 id="irq-在多处理器系统的分发"><a href="#irq-在多处理器系统的分发" class="headerlink" title="irq 在多处理器系统的分发"></a>irq 在多处理器系统的分发</h2><ul>
<li>中断亲和力：多处理系统中，操作系统会按照一定策略把中断分配到各CPU Core来处理。中断亲和力高的CPU Core，操作系统会倾向于把中断交给其处理</li>
<li>通过修改/proc/irq/smp_affinity 可以改变Linux的中断亲和力</li>
<li>内核线程kirqd：周期性执行do_irq_balance()。Track最近时间间隔每个Core的接收中断次数，动态做Balance</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中断</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断学习笔记(2) -- 嵌入式设备中断</title>
    <url>/p/33f60ab2.html</url>
    <content><![CDATA[<p>在<a href="http://www.l2h.site/linux-interrupt-1/" target="_blank" rel="noopener">Linux中断学习笔记(1)</a>提到，外设通过中断控制器连接到CPU的中断线。嵌入式系统也不例外。</p><h2 id="ARM嵌入式系统GIC架构"><a href="#ARM嵌入式系统GIC架构" class="headerlink" title="ARM嵌入式系统GIC架构"></a>ARM嵌入式系统GIC架构</h2><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0176c/ar01s03s01.html" target="_blank" rel="noopener">ARM官网</a>所举图为例：ARM的中断控制器GIC（General Interrupt Controller）将从外设输入的中断通过CPU的IRQ信号线（ARM中主要为FIQ和IRQ）连接到系统中各CPU。</p><a id="more"></a>

<p>图1. GIC 简单结构图</p>
<p><img src="http://pic.l2h.site/l2hsiteImage%203.png" alt="Linux中断学习笔记(2) -- 嵌入式设备中断" title="Linux中断学习笔记(2) -- 嵌入式设备中断"> </p>
<p>中断控制器允许级联，一个有中断级联的终端流程如下图所示。次级GIC将中断信号通知到主GIC后，主GIC再通知CPU，CPU读各级中断控制器的Ack Register得到中断号，并开始执行相应的中断例程。执行完后，<strong>直接</strong>写次级中断控制器的寄存器标记中断服务结束。</p>
<p>图2. GIC中断服务级联</p>
<p><img src="http://pic.l2h.site/l2hsiteImage%204.png" alt="Linux中断学习笔记(2) -- 嵌入式设备中断" title="Linux中断学习笔记(2) -- 嵌入式设备中断"><br>参见MT6577 GIC中断控制器的DTS声明（以arch/arm/boot/dts/mt6592.dtsi为例）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sysirq: interrupt-controller@<span class="number">10200220</span> &#123;</span><br><span class="line">    compatible = <span class="string">"mediatek,mt6592-sysirq"</span>, <span class="string">"mediatek,mt6577-sysirq"</span>;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="meta-string">&lt;3&gt;;</span></span></span><br><span class="line">    interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">    reg = &lt;<span class="number">0x10200220</span> <span class="number">0x1c</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gic: interrupt-controller@<span class="number">10211000</span> &#123;</span><br><span class="line">    compatible = <span class="string">"arm,cortex-a7-gic"</span>;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    <span class="meta">#interrupt-cells = <span class="meta-string">&lt;3&gt;;</span></span></span><br><span class="line">    interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">    reg = &lt;<span class="number">0x10211000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">          &lt;<span class="number">0x10212000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">```C</span><br><span class="line">Linux操作系统通过加载DTS将GIC的硬件信息装载到特定内存位置，GIC的驱动程序运行时通过DTS的API读取到这些硬件信息（例如寄存器地址）来控制中断的处理。</span><br><span class="line"></span><br><span class="line">物理中断号的映射</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">GIC驱动程序初始化时，会向系统申请中断描述符。中断描述符是全局变量，外设驱动request_irq传入的第一个参数便是中断描述符的索引。外设根据DTS中对应的物理中断号和其所在的中断Domain，便可以得到外设的虚拟中断id（即中断描述符的索引）</span><br><span class="line">```C</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init</span><br><span class="line">gic_of_init(struct device_node *node, struct device_node *parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> __iomem *cpu_base;</span><br><span class="line">    <span class="keyword">void</span> __iomem *dist_base;</span><br><span class="line">    u32 percpu_offset;</span><br><span class="line">    <span class="keyword">int</span> irq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!node))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    dist_base = of_iomap(node, <span class="number">0</span>);</span><br><span class="line">    WARN(!dist_base, <span class="string">"unable to map gic dist registers\\n"</span>);</span><br><span class="line"></span><br><span class="line">    cpu_base = of_iomap(node, <span class="number">1</span>);</span><br><span class="line">    WARN(!cpu_base, <span class="string">"unable to map gic cpu registers\\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Disable split EOI/Deactivate if either HYP is not available</span></span><br><span class="line"><span class="comment">     * or the CPU interface is too small.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (gic_cnt == <span class="number">0</span> &amp;&amp; !gic_check_eoimode(node, &amp;cpu_base))</span><br><span class="line">        static_key_slow_dec(&amp;supports_deactivate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (of_property_read_u32(node, <span class="string">"cpu-offset"</span>, &amp;percpu_offset))</span><br><span class="line">        percpu_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __gic_init_bases(gic_cnt, <span class="number">-1</span>, dist_base, cpu_base, percpu_offset,</span><br><span class="line">             &amp;node-&gt;fwnode);       <span class="comment">//执行GIC相关初始化</span></span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __init __gic_init_bases(<span class="keyword">unsigned</span> <span class="keyword">int</span> gic_nr, <span class="keyword">int</span> irq_start,</span><br><span class="line">			   <span class="keyword">void</span> __iomem *dist_base, <span class="keyword">void</span> __iomem *cpu_base,</span><br><span class="line">			   u32 percpu_offset, struct fwnode_handle *handle)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...................</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 计算GIC支持的IRQ数量</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) &amp; <span class="number">0x1f</span>;</span><br><span class="line">	gic_irqs = (gic_irqs + <span class="number">1</span>) * <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">if</span> (gic_irqs &gt; <span class="number">1020</span>)</span><br><span class="line">		gic_irqs = <span class="number">1020</span>;</span><br><span class="line">	gic-&gt;gic_irqs = gic_irqs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handle) &#123;		<span class="comment">/* DT/ACPI */</span></span><br><span class="line">		gic-&gt;domain = irq_domain_create_linear(handle, gic_irqs,</span><br><span class="line">						       &amp;gic_irq_domain_hierarchy_ops,</span><br><span class="line">						       gic);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;		<span class="comment">/* Legacy support */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For primary GICs, skip over SGIs.</span></span><br><span class="line"><span class="comment">		 * For secondary GICs, skip over PPIs, too.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (gic_nr == <span class="number">0</span> &amp;&amp; (irq_start &amp; <span class="number">31</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			hwirq_base = <span class="number">16</span>;</span><br><span class="line">			<span class="keyword">if</span> (irq_start != <span class="number">-1</span>)</span><br><span class="line">				irq_start = (irq_start &amp; ~<span class="number">31</span>) + <span class="number">16</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			hwirq_base = <span class="number">32</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gic_irqs -= hwirq_base; <span class="comment">/* calculate # of irqs to allocate */</span></span><br><span class="line"></span><br><span class="line">		irq_base = irq_alloc_descs(irq_start, <span class="number">16</span>, gic_irqs,</span><br><span class="line">					   numa_node_id());</span><br><span class="line">                <span class="comment">//为中断控制器分配gic_irqs个中断描述符（数量如前计算）</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR_VALUE(irq_base)) &#123;</span><br><span class="line">			WARN(<span class="number">1</span>, <span class="string">"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n"</span>,</span><br><span class="line">			     irq_start);</span><br><span class="line">			irq_base = irq_start;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gic-&gt;domain = irq_domain_add_legacy(<span class="literal">NULL</span>, gic_irqs, irq_base,</span><br><span class="line">					hwirq_base, &amp;gic_irq_domain_ops, gic);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kernel初始化时，会去枚举DTS，根据每一个设备的中断domain以及DTS中描述的物理中断号来与系统中的唯一irq编号virq做映射（在DTS枚举时，会根据设备的中断描述来申请系统中唯一的中断描述符）</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中断</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步之RCU（2）</title>
    <url>/p/5897b798.html</url>
    <content><![CDATA[<blockquote>
<p>本欲根据自己的理解来写RCU，无奈时间有限，且目前工作内容着重逻辑、架构思考，少接触直接编程。为避免误人子弟，_<strong>从如下文章转载</strong>_：欢迎大家留言交流<br>《<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652662265&idx=1&sn=4e0ec525316720553666482ec4bd9756&chksm=810f2f64b678a672f9573d0374786f5cb1acbb08fdfe3881fac6275145471ad5fc39aa4bb03e&scene=21#wechat_redirect" target="_blank" rel="noopener">谢宝友:深入理解RCU</a> 》，请尊重原文作者劳动成果</p>
<p>本转载系列文章：<a href="https://www.l2h.site/2019/01/19/linux-rcu-zz-1/" target="_blank" rel="noopener"><br>LINUX内核同步之RCU</a></p>
<p>Linux内核同步之RCU（2）</p>
</blockquote><h2 id="系列四：-用法"><a href="#系列四：-用法" class="headerlink" title="系列四： 用法"></a>系列四： 用法</h2><h3 id="1-RCU的用法"><a href="#1-RCU的用法" class="headerlink" title="1. RCU的用法"></a>1. RCU的用法</h3><a id="more"></a>
<p>RCU最常用的目的是替换已有的机制，如下所示：</p>
<ul>
<li>读写锁</li>
<li>受限制的引用计数机制</li>
<li>批量引用计数机制</li>
<li>穷人版的垃圾回收器</li>
<li>存在担保</li>
<li>类型安全的内存</li>
<li>等待事物结束</li>
</ul>
<h4 id="RCU是读写锁的替代者"><a href="#RCU是读写锁的替代者" class="headerlink" title="RCU是读写锁的替代者"></a>RCU是读写锁的替代者</h4><p>在Linux内核中，RCU最常见的用途是替换读写锁。在20世纪90年代初期，Paul在实现通用RCU之前，实现了一种轻量级的读写锁。后来，为这个轻量级读写锁原型所设想的每个用途，最终都使用RCU来实现了。</p>
<p>RCU和读写锁最关键的相似之处，在于两者都有可以并行执行读端临界区。事实上，在某些情况下，完全可以用对应的读写锁API来替换RCU的API，反之亦然。</p>
<p>RCU的优点在于：性能、不会死锁，以及良好的实时延迟。当然RCU也有一点缺点，比如：读者与更新者并发执行，低优先级RCU读者也可以阻塞正等待优雅周期(Grace Period)结束的高优先级线程，优雅周期的延迟可能达到好几毫秒。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bysdkXxFAH9NI7yIfJoXclytKTXOJibibV2WvaIaahuIdIRzAtDsczV7dibd2ur5hkPAQNGWxBeIy6Ysg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>上图是不是略显奇怪，RCU读端延迟竟然小于一个CPU周期？这不是开玩笑，因为有某些实现中（例如，服务器Linux），RCU读端就完全是一个空操作。当然，在这样的实现中，它可能会包含一个编译屏障，因此也会对性能产生那么一点点影响。</p>
<p>请注意，在单个CPU上读写锁比RCU慢一个数量级，在16个CPU上读写锁比RCU几乎要慢两个数量级。随着CPU数量的增加，RCU的扩展性优势越来越突出。可以这么说，RCU几乎就是水平扩展，这可以在上图中看出来。</p>
<p>当内核配置了CONFIG_PREEMPT的时候，RCU仍然超过了读写锁一到三个数量级，如下图所示。请注意：读写锁在CPU数目很多时的陡峭曲线。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bysdkXxFAH9NI7yIfJoXclytfjgic2vaJ8wVbQ5XCibr8tAwnd8ibOd4SLXekbkyuyWDR1VZKZ2jYLNeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>当然，上图中的临界区长度为0，这夸大了读写锁的性能劣势。随着临界区的加大，RCU的性能优势也不再显著。在下图中，有16个CPU，y轴代表读端原语的总开销，x轴代表临界区长度。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bysdkXxFAH9NI7yIfJoXclytculGoibBmGCvgfupv1RYEfLquRyxZGANshHmhLtB7Qz3xtKmOOMcxMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>然而，一般说来，临界区都能在几个毫秒内完成，所以总的来说，在性能方面，测试结果对RCU是有利的。</p>
<p>另外，RCU读端原语基本上是不会死锁的。因为它本身就属于无锁编程的范畴。</p>
<p>这种免于死锁的能力来源于RCU的读端原语不阻塞、不自旋，甚至不存在向后跳转语句，所以RCU读端原语的执行时间是确定的。这使得RCU读端原语不可能形成死锁循环。</p>
<p>RCU读端免于死锁的能力带来了一个有趣的后果：RCU读者可以恣意地升级为RCU更新者。在读写锁中尝试这种升级则会有可能造成死锁。进行RCU读者到更新者升级的代码片段如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  rcu_read_lock();</span><br><span class="line"><span class="number">2</span>  list_for_each_entry_rcu(p,  &amp;head,  list_field)  &#123;</span><br><span class="line"><span class="number">3</span>     do_something_with(p);</span><br><span class="line"><span class="number">4</span>     <span class="keyword">if</span>  (need_update(p))  &#123;</span><br><span class="line"><span class="number">5</span>         spin_lock(my_lock);</span><br><span class="line"><span class="number">6</span>         do_update(p);</span><br><span class="line"><span class="number">7</span>         spin_unlock(&amp;my_lock);</span><br><span class="line"><span class="number">8</span>     &#125;</span><br><span class="line"><span class="number">9</span>  &#125;</span><br><span class="line"><span class="number">10</span>  rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<p>请注意，do_update()是在锁的保护下执行，也是在RCU读端的保护下执行。</p>
<p>RCU免于死锁的特性带来的另一个有趣后果是RCU不会受优先级反转问题影响。比如，低优先级的RCU读者无法阻止高优先级的RCU更新者获取更新端锁。类似地，低优先级的更新者也无法阻止高优先级的RCU读者进入RCU读端临界区。</p>
<p>另一方面，因为RCU读端原语既不自旋也不阻塞，所以这些原语有着极佳的实时延迟。而自旋锁或者读写锁都存在不确定的实时延迟。</p>
<p>但是，RCU还是会受到更隐晦的优先级反转问题影响，比如，在等待RCU优雅周期结束而阻塞的高优先级进程，会被-rt内核的低优先级RCU读者阻塞。这可以用RCU优先级提升来解决。</p>
<p>再一方面，因为RCU读者既不自旋也不阻塞，RCU更新者也没有任何类似回滚或者中止的语义，所以RCU读者和更新者可以并发执行。这意味着RCU读者有可能访问旧数据，还有可能发现数据不一致，无论这两个问题中的哪一个，都让读写锁有卷土重来的机会。</p>
<p>不过，令人吃惊的是，在大量情景中，数据不一致和旧数据都不是问题。网络路由表是一个经典例子。因为路由的更新可能要花相当长一段时间才能到达指定系统（几秒甚至几分钟），所以系统可能会在新数据到来后的一段时间内，仍然将报文发到错误的地址去。通常，在几毫秒内将报文发送到错误地址并不算什么问题。</p>
<p>简单地说，读写锁和RCU提供了不同的保证。在读写锁中，任何在写者之后开始的读者都“保证”能看到新值。与之相反，在RCU中，在更新者完成后才开始的读者都“保证”能看见新值，在更新者开始后才完成的读者有可能看见新值，也有可能看见旧值，这取决于具体的时机。</p>
<p>在实时RCU、SRCU或QRCU中，被抢占的读者将阻止正在进行中的优雅周期的完成，即使有高优先级的任务在等待优雅周期完成时也是如此。实时RCU可以通过用call_rcu()替换synchronize_rcu()来避免此问题，或者采用RCU优先级提升来避免。</p>
<p>除了那些“玩具”RCU实现，RCU优雅周期可能会延续好几个毫秒。这使得RCU更适于使用在读数据占多数的情景。</p>
<p>将读写锁转换成RCU非常简单，如下：</p>
<p><img src="http://pic.l2h.site/rcu-zz-pic-0.png" alt></p>
<h4 id="RCU是一种受限制的引用计数机制"><a href="#RCU是一种受限制的引用计数机制" class="headerlink" title="RCU是一种受限制的引用计数机制"></a>RCU是一种受限制的引用计数机制</h4><p>因为优雅周期不能在RCU读端临界区进行时结束，所以RCU读端原语可以像受限的引用计数机制一样使用。比如考虑下面的代码片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  rcu_read_lock();             <span class="comment">/*  acquire  reference.  */</span></span><br><span class="line"><span class="number">2</span>  p  =  rcu_dereference(head);</span><br><span class="line"><span class="number">3</span>  <span class="comment">/*  do  something  with  p.  */</span></span><br><span class="line"><span class="number">4</span>  rcu_read_unlock();            <span class="comment">/*  release  reference.  */</span></span><br></pre></td></tr></table></figure>

<p>rcu_read_lock()原语可以看作是获取对p的引用，因为相应的优雅周期无法在配对的rcu_read_unlock()之前结束。这种引用计数机制是受限制的，因为我们不允许在RCU读端临界区中阻塞，也不允许将一个任务的RCU读端临界区传递给另一个任务。不管上述的限制，下列代码可以安全地删除p：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  spin_lock(&amp;mylock);</span><br><span class="line"><span class="number">2</span>  p  =  head;</span><br><span class="line"><span class="number">3</span>  rcu_assign_pointer(head,  <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">4</span>  spin_unlock(&amp;mylock);</span><br><span class="line"><span class="number">5</span>  <span class="comment">/*  Wait  for  all  references  to  be  released.  */</span></span><br><span class="line"><span class="number">6</span>  synchronize_rcu();</span><br><span class="line"><span class="number">7</span>  kfree(p);</span><br></pre></td></tr></table></figure>

<p>当然，RCU也可以与传统的引用计数结合。但是为什么不直接使用引用计数？部分原因是性能，如下图所示，图中显示了在16个3GHz CPU的Intel x86系统中采集的数据。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bysdkXxFAH9NI7yIfJoXclyturuKibwhGCPqgdNR2DbrW23QA8lbmKBh1dAg5FMq0OIS7rHI18BgCxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>和读写锁一样，RCU的性能优势主要来源于较短的临界区，如下图所示。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bysdkXxFAH9NI7yIfJoXclytdyoqTYlryHerSTloAcDWL1cTS383kH0ic8JiblPqibFVrQ2tXaBibCmsuA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h4 id="RCU是一种可大规模使用的引用计数机制"><a href="#RCU是一种可大规模使用的引用计数机制" class="headerlink" title="RCU是一种可大规模使用的引用计数机制"></a>RCU是一种可大规模使用的引用计数机制</h4><p>如前所述，传统的引用计数通常与某种或者一组数据结构有联系。然而，维护一组数据结构的全局引用计数，通常会导致包含引用计数的缓存行来回“乒乓”。这种缓存行“乒乓”会严重影响系统性能。</p>
<p>相反，RCU的轻量级读端原语允许读端极其频繁地调用，却只带来微不足道的性能影响，这使得RCU可以作为一种几乎没有性能损失的“批量引用计数机制”。当某个任务需要在一大段代码中持有引用时，可以使用可睡眠RCU（SRCU）。但是，一个任务不能将引用锁引用传递给另一个任务。例如：在开始一次I/O时获取引用，然后当对应的I/O完成时在中断处理函数里释放该引用。</p>
<h4 id="RCU是穷人版的垃圾回收器"><a href="#RCU是穷人版的垃圾回收器" class="headerlink" title="RCU是穷人版的垃圾回收器"></a>RCU是穷人版的垃圾回收器</h4><p>当人们刚开始学习RCU时，有种比较少见的感叹是“RCU有点像垃圾回收器！”。这种感叹有一部分是对的，不过还是会给学习造成误导。</p>
<p>也许思考RCU与垃圾自动回收器（GC）之间关系的最好办法是，RCU类似自动决定回收时机的GC，但是RCU与GC有几点不同：（1）程序员必须手动指示何时可以回收指定数据结构，（2）程序员必须手动标出可以合法持有引用的RCU读端临界区。</p>
<p>尽管存在这些差异，两者的相似程度仍然相当高，至少有一篇理论分析RCU的文献曾经分析过两者的相似度。</p>
<h4 id="RCU是一种提供存在担保的方法"><a href="#RCU是一种提供存在担保的方法" class="headerlink" title="RCU是一种提供存在担保的方法"></a>RCU是一种提供存在担保的方法</h4><p>通过锁来提供存在担保有其不利之处。与锁类似，如果任何受RCU保护的数据元素在RCU读端临界区中被访问，那么数据元素在RCU读端临界区持续期间保证存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1  int  delete(int  key)</span><br><span class="line">2  &#123;</span><br><span class="line">3     struct  element  *p;</span><br><span class="line">4     int  b;</span><br><span class="line">5     </span><br><span class="line">6     b  =  hashfunction(key);</span><br><span class="line">7     rcu_read_lock();</span><br><span class="line">8     p  =  rcu_dereference(hashtable[b]);</span><br><span class="line">9     if  (p  ==  NULL  ||  p-&gt;key  !=  key)  &#123;</span><br><span class="line">10         rcu_read_unlock();</span><br><span class="line">11         return  0;</span><br><span class="line">12     &#125;</span><br><span class="line">13     spin_lock(&amp;p-&gt;lock);</span><br><span class="line">14     if  (hashtable[b]  ==  p  &amp;&amp;  p-&gt;key  ==  key)  &#123;</span><br><span class="line">15         rcu_read_unlock();</span><br><span class="line">16         hashtable[b]  =  NULL;</span><br><span class="line">17         spin_unlock(&amp;p-&gt;lock);</span><br><span class="line">18         synchronize_rcu();</span><br><span class="line">19         kfree(p);</span><br><span class="line">20         return  1;</span><br><span class="line">21     &#125;</span><br><span class="line">22     spin_unlock(&amp;p-&gt;lock);</span><br><span class="line">23     rcu_read_unlock();</span><br><span class="line">24     return  0;</span><br><span class="line">25  &#125;</span><br></pre></td></tr></table></figure>

<p>上图展示了基于RCU的存在担保如何通过从哈希表删除元素的函数来实现每数据元素锁。第6行计算哈希函数，第7行进入RCU读端临界区。如果第9行发现哈希表对应的哈希项（bucket）为空，或者数据元素不是我们想要删除的那个，那么第10行退出RCU读端临界区，第11行返回错误。</p>
<p>如果第9行判断为false，第13行获取更新端的自旋锁，然后第14行检查元素是否还是我们想要的。如果是，第15行退出RCU读端临界区，第16行从哈希表中删除找到的元素，第17行释放锁，第18行等待所有之前已经存在的RCU读端临界区退出，第19行释放刚被删除的元素，最后第20行返回成功。如果14行的判断发现元素不再是我们想要的，那么第22行释放锁，第23行退出RCU读端临界区，第24行返回错误以删除该关键字。</p>
<h4 id="RCU是一种提供类型安全内存的方法"><a href="#RCU是一种提供类型安全内存的方法" class="headerlink" title="RCU是一种提供类型安全内存的方法"></a>RCU是一种提供类型安全内存的方法</h4><p>很多无锁算法并不需要数据元素在被RCU读端临界区引用时保持完全一致，只要数据元素的类型不变就可以了。换句话说，只要数据结构类型不变，无锁算法可以允许某个数据元素在被其他对象引用时被释放并重新分配，但是决不允许类型上的改变。这种“保证”，在学术文献中被称为“类型安全的内存”，它比前一节提到的存在担保要弱一些，因此处理起来也要困难一些。类型安全的内存算法在Linux内核中的应用是slab缓存，被SLAB_DESTROY_BY_RCU标记专门标出来的缓存通过RCU将已释放的slab返回给系统内存。在任何已有的RCU读端临界区持续期间，使用RCU可以保证所有带有SLAB_DESTROY_BY_RCU标记且正在使用的slab元素仍然在该slab中，类型保持一致。</p>
<p>虽然基于类型安全的无锁算法在特定情景下非常有效，但是最好还是尽量使用存在担保。毕竟简单总是更好的。</p>
<h4 id="RCU是一种等待事物结束的方式"><a href="#RCU是一种等待事物结束的方式" class="headerlink" title="RCU是一种等待事物结束的方式"></a>RCU是一种等待事物结束的方式</h4><p>RCU的一个强大之处，就是允许你在等待上千个不同事物结束的同时，又不用显式地去跟踪其中每一个事物，因此也就无需担心性能下降、扩展限制、复杂的死锁场景、内存泄露等显式跟踪机制本身的问题。</p>
<p>下面展示如何实现与不可屏蔽中断（NMI）处理函数的交互，如果用锁来实现，这将极其困难。步骤如下：</p>
<ul>
<li>1．做出改变，比如，OS对一个NMI做出反应。在NMI中使用RCU读端原语。</li>
<li>2．等待所有已有的读端临界区完全退出（比如使用synchronize_sched()原语）。</li>
<li>3．扫尾工作，比如，返回表明改变成功完成的状态。</li>
</ul>
<p>下面是一个Linux内核中的例子。在这个例子中，timer_stop()函数使用synchronize_sched()确保在释放相关资源之前，所有正在处理的NMI处理函数已经完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">profile_buffer</span>  &#123;</span></span><br><span class="line"><span class="number">2</span>     <span class="keyword">long</span>  <span class="built_in">size</span>;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">atomic_t</span>  entry[<span class="number">0</span>];</span><br><span class="line"><span class="number">4</span>  &#125;;</span><br><span class="line"><span class="number">5</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">profile_buffer</span>  *<span class="title">buf</span>  =  <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>  <span class="function"><span class="keyword">void</span>  <span class="title">nmi_profile</span><span class="params">(<span class="keyword">unsigned</span>  <span class="keyword">long</span>  pcvalue)</span></span></span><br><span class="line"><span class="function">8  </span>&#123;</span><br><span class="line"><span class="number">9</span>     <span class="class"><span class="keyword">struct</span>  <span class="title">profile_buffer</span>  *<span class="title">p</span>  =   <span class="title">rcu_dereference</span>(<span class="title">buf</span>);</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>     <span class="keyword">if</span>  (p  ==  <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">12</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span>  (pcvalue  &gt;=  p-&gt;<span class="built_in">size</span>)</span><br><span class="line"><span class="number">14</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">15</span>     atomic_inc(&amp;p-&gt;entry[pcvalue]);</span><br><span class="line"><span class="number">16</span>  &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span>  <span class="function"><span class="keyword">void</span>  <span class="title">nmi_stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">19  </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="class"><span class="keyword">struct</span>  <span class="title">profile_buffer</span>  *<span class="title">p</span>  =  <span class="title">buf</span>;</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span>     <span class="keyword">if</span>  (p  ==  <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">23</span>         <span class="keyword">return</span>;</span><br><span class="line"><span class="number">24</span>     rcu_assign_pointer(buf,  <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">25</span>     synchronize_sched();</span><br><span class="line"><span class="number">26</span>     kfree(p);</span><br><span class="line"><span class="number">27</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>第1到4行定义了profile_buffer结构，包含一个大小和一个变长数组的入口。第5行定义了指向profile_buffer的指针，这里假设别处对该指针进行了初始化，指向内存的动态分配区。</p>
<p>第7至16行定义了nmi_profile()函数，供NMI中断处理函数调用。该函数不会被抢占，也不会被普通的中断处理函数打断，但是，该函数还是会受高速缓存未命中、ECC错误以及被同一个核的其他硬件线程抢占时钟周期等因素影响。第9行使用rcu_dereference()原语来获取指向profile_buffer的本地指针，这样做是为了确保在DECAlpha上的内存顺序执行，如果当前没有分配profile_buffer，第11行和12行退出，如果参数pcvalue超出范围，第13和14行退出。否则，第15行增加以参数pcvalue为下标的profile_buffer项的值。请注意，profile_buffer结构中的size保证了pcvalue不会超出缓冲区的范围，即使突然将较大的缓冲区替换成了较小的缓冲区也是如此。</p>
<p>第18至27行定义了nmi_stop()函数，由调用者负责互斥访问（比如持有正确的锁）。第20行获取profile_buffer的指针，如果缓冲区为空，第22和23行退出。否则，第24行将profile_buffer的指针置NULL（使用rcu_assign_pointer()原语在弱顺序的机器中保证内存顺序访问），第25行等待RCU Sched的优雅周期结束，尤其是等待所有不可抢占的代码——包括NMI中断处理函数——结束。一旦执行到第26行，我们就可以保证所有获取到指向旧缓冲区指针的nmi_profile()实例都已经返回了。现在可以安全释放缓冲区，这时使用kfree()原语。</p>
<p>简而言之，RCU让profile_buffer动态切换变得更简单，你可以试试原子操作，也可以用锁来折磨下自己。注意考虑到如下一点：在大多数CPU架构中，原子操作和锁都可能存在循环语句，在循环的过程中可能会被NMI中断。</p>
<h3 id="RCU-API"><a href="#RCU-API" class="headerlink" title="RCU API"></a>RCU API</h3><p><img src="http://pic.l2h.site/RCU-API.png" alt></p>
<p>RCU API  </p>
<p>“RCU Classic”一列对应的是RCU的原始实现，rcu_read_lock()和rcu_read_unlock()原语标示出RCU读端临界区，可以嵌套使用。对应的同步的更新端原语synchronize_rcu()和synchronize_net()都是等待当前正在执行的RCU读端临界区退出。等待时间被称为“优雅周期”。异步的更新端原语call_rcu()在后续的优雅周期结束后调用由参数指定的函数。比如，call_rcu(p, f);在优雅周期结束后执行RCU回调f(p)。</p>
<p>想要利用基于RCU的类型安全的内存，要将SLAB_DESTROY_BY_RCU传递给kmem_cache_create()。有一点很重要，SLAB_DESTROY_BY_RCU不会阻止kmem_cache_alloc()立即重新分配刚被kmem_cache_free()释放的内存！事实上，由rcu_dereference返回的受SLAB_DESTROY_ BY_RCU标记保护的数据结构可能会释放——重新分配任意次，甚至在rcu_read_lock()保护下也是如此。但是，SLAB_DESTROY_BY_RCU可以阻止kmem_cache_free()在RCU优雅周期结束之前，它所返回数据结构的完全释放给SLAB。一句话，虽然数据元素可能被释放——重新分配N次，但是它的类型是保持不变的。</p>
<h4 id="订阅和版本维护API"><a href="#订阅和版本维护API" class="headerlink" title="订阅和版本维护API"></a>订阅和版本维护API</h4><p><img src="http://pic.l2h.site/rcu-api-2.png" alt></p>
<p>表中的第一类API作用于Linux的struct list_head循环双链表。list_for_each_ entry_rcu()原语以类型安全的方式遍历受RCU保护的链表。在非Alpha的平台上，该原语相较于list_for_each_entry()原语不产生或者只带来极低的性能惩罚。list_add_rcu()、list_add_tail_rcu()和list_replace_rcu()原语都是对非RCU版本的模拟，但是在弱顺序的机器上回带来额外的内存屏障开销。list_del_rcu()原语同样是非RCU版本的模拟，但是奇怪的是它要比非RCU版本快一点，这是由于list_del_rcu()只毒化prev指针，而list_del()会同时毒化prev和next指针。最后，list_splice_init_rcu()原语和它的非RCU版本类似，但是会带来一个完整的优雅周期的延迟。</p>
<p>表中的第二类API直接作用于Linux的struct hlist_head线性哈希表。struct hlist_head比structlist_head高级一点的地方是前者只需要一个单指针的链表头部，这在大型哈希表中将节省大量内存。表中的struct hlist_head原语与非RCU版本的关系同struct list_head原语的类似关系一样。</p>
<p>表中的最后一类API直接作用于指针，这对创建受RCU保护的非链表数据元素非常有用，比如受RCU保护的数组和树。rcu_assign_pointer()原语确保在弱序机器上，任何在给指针赋值之前进行的初始化都将按照顺序执行。同样，rcu_dereferece()原语确保后续指针解引用的代码可以在Alpha CPU上看见对应的rcu_assign_pointer()之前进行的初始化的结果。 </p>
<h2 id="系列五：玩具式实现"><a href="#系列五：玩具式实现" class="headerlink" title="系列五：玩具式实现"></a>系列五：玩具式实现</h2><h3 id="基于锁的RCU"><a href="#基于锁的RCU" class="headerlink" title="基于锁的RCU"></a>基于锁的RCU</h3><p>也许最简单的RCU实现就是用锁了，如下图所示。在该实现中，rcu_read_lock()获取一把全局自旋锁，rcu_read_unlock()释放锁，而synchronize_rcu()获取自旋锁，随后将其释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">4</span>  &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">7  </span>&#123;</span><br><span class="line"><span class="number">8</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">9</span>  &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">12  </span>&#123;</span><br><span class="line"><span class="number">13</span>     spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">14</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">15</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>因为synchronize_rcu()只有在获取锁（然后释放）以后才会返回，所以在所有之前发生的RCU读端临界区完成前，synchronize_rcu()是不会返回的，因此这符合RCU的语义，特别是存在担保方面的语义。</p>
<p>但是，在这样的实现中，一个读端临界区同时只能有一个RCU读者进入，这基本上可以说是和RCU的目的相反。而且，rcu_read_lock()和rcu_read_unlock()中的锁操作开销是极大的，读端的开销从Power5单核CPU上的100纳秒到64核系统上的17微秒不等。更糟的是，使用同一把锁使得rcu_read_lock()，可能会使得系统形成自旋锁死锁。这是因为：RCU的语义允许RCU读端嵌套。所以，在这样的实现中，RCU读端临界区不能嵌套。最后一点，原则上并发的RCU更新操作可以共享一个公共的优雅周期，但是该实现将优雅周期串行化了，因此无法共享优雅周期。</p>
<p>问题：这样的死锁情景会不会出现其他RCU实现中？</p>
<p>问题：为什么不直接用读写锁来实现这个RCU？</p>
<p>很难想象这种实现能用在任何一个产品中，但是这种实现有一点好处：可以用在几乎所有的用户态程序上。不仅如此，类似的使用每CPU锁或者读写锁的实现还曾经用于Linux 2.4内核中。</p>
<h3 id="基于每线程锁的RCU"><a href="#基于每线程锁的RCU" class="headerlink" title="基于每线程锁的RCU"></a>基于每线程锁的RCU</h3><p>下图显示了一种基于每线程锁的实现。rcu_read_lock()和rcu_read_unlock()分别获取和释放当前线程的锁。synchronize_rcu()函数按照次序逐一获取和释放每个线程的锁。这样，所有在synchronize_rcu()开始时就已经执行的RCU读端临界区，必须在synchronize_rcu()结束前返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>    spin_lock(&amp;__get_thread_var(rcu_gp_lock));</span><br><span class="line"><span class="number">4</span>  &#125;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">7  </span>&#123;</span><br><span class="line"><span class="number">8</span>     spin_unlock(&amp;__get_thread_var(rcu_gp_lock));</span><br><span class="line"><span class="number">9</span>  &#125;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">12  </span>&#123;</span><br><span class="line"><span class="number">13</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>     for_each_running_thread(t)  &#123;</span><br><span class="line"><span class="number">16</span>        spin_lock(&amp;per_thread(rcu_gp_lock, t));</span><br><span class="line"><span class="number">17</span>        spin_unlock(&amp;per_thread(rcu_gp_lock, t));</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>该实现的优点在于：允许并发的RCU读者，同时避免了使用单个全局锁可能造成的死锁。不仅如此，读端开销虽然高达大概140纳秒，但是不管CPU数目为多少，始终保持在140纳秒。不过，更新端的开销则在从Power5单核上的600纳秒到64核系统上的超过100微秒不等。</p>
<p><strong>问题</strong>：如果在第15至18行看，先获取所有锁，然后再释放所有锁，这样是不是更清晰一点呢？</p>
<p><strong>问题</strong>：该实现能够避免死锁吗？如果能，为什么能？如果不能，为什么不能？</p>
<p>本方法在某些情况下是很有效的，尤其是类似的方法曾在Linux 2.4内核中使用。</p>
<p>下面提到的基于计数的RCU实现，克服了基于锁实现的某些缺点。</p>
<h3 id="基于计数的简单RCU实现"><a href="#基于计数的简单RCU实现" class="headerlink" title="基于计数的简单RCU实现"></a>基于计数的简单RCU实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="keyword">atomic_t</span> rcu_refcnt;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">4  </span>&#123;</span><br><span class="line"><span class="number">5</span>     atomic_inc(&amp;rcu_refcnt);</span><br><span class="line"><span class="number">6</span>     smp_mb();</span><br><span class="line"><span class="number">7</span>  &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">10  </span>&#123;</span><br><span class="line"><span class="number">11</span>     smp_mb();</span><br><span class="line"><span class="number">12</span>     atomic_dec(&amp;rcu_refcnt);</span><br><span class="line"><span class="number">13</span>  &#125;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">16  </span>&#123;</span><br><span class="line"><span class="number">17</span>     smp_mb();</span><br><span class="line"><span class="number">18</span>     <span class="keyword">while</span> (atomic_read(&amp;rcu_refcnt) !=  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">19</span>         poll(<span class="literal">NULL</span>,  <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="number">20</span>     &#125;</span><br><span class="line"><span class="number">21</span>     smp_mb();</span><br><span class="line"><span class="number">22</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>这是一种稍微复杂一点的RCU实现。本方法在第1行定义了一个全局引用计数rcu_refcnt。rcu_read_lock()原语自动增加计数，然后执行一个内存屏障，确保在原子自增之后才进入RCU读端临界区。同样，rcu_read_unlock()先执行一个内存屏障，划定RCU读端临界区的结束点，然后再原子自减计数。synchronize_rcu()原语不停自旋，等待引用计数的值变为0，语句前后用内存屏障保护正确的顺序。第19行的poll()只是纯粹的延时，从纯RCU语义的角度上看是可以省略的。等synchronize_rcu()返回后，所有之前发生的RCU读端临界区都已经完成了。</p>
<p>与基于锁的实现相比，我们欣喜地发现：这种实现可以让读者并发进入RCU读端临界区。与基于每线程锁的实现相比，我们又欣喜地发现：本节的实现可以让RCU读端临界区嵌套。另外，rcu_read_lock()原语不会进入死锁循环，因为它既不自旋也不阻塞。</p>
<p>问题：但是如果你在调用synchronize_rcu()时持有一把锁，然后又在RCU读端临界区中获取同一把锁，会发生什么呢？</p>
<p>当然，这个实现还是存在一些严重的缺点。首先，rcu_read_lock()和rcu_read_unlock()中的原子操作开销是非常大的，读端开销从Power5单核CPU上的100纳秒到64核系统上的40微秒不等。这意味着RCU读端临界区必须非常长，才能够满足现实世界中的读端并发请求。但是从另一方面来说，当没有读者时，优雅周期只有差不多40纳秒，这比Linux内核中的产品级实现要快上很多个数量级。</p>
<p>其次，如果存在多个并发的rcu_read_lock()和rcu_read_unlock()操作，因为出现大量高速缓冲未命中，对rcu_refcnt的内存访问竞争将会十分激烈。</p>
<p>以上这两个缺点极大地影响RCU的目标，即提供一种读端低开销的同步原语。</p>
<p>最后，在很长的读端临界区中的大量RCU读者甚至会让synchronize_rcu()无法完成，因为全局计数可能永远不为0。这会导致RCU更新端的饥饿，这一点在产品级应用里肯定是不可接受的。</p>
<p>问题：当synchronize_rcu()等待时间过长了以后，为什么不能简单地让rcu_read_lock()暂停一会儿呢？这种做法不能防止synchronize_rcu()饥饿吗？</p>
<p>通过上述内容，很难想象本节的实现可以在产品级应用中使用，虽然它比基于锁的实现更有这方面的潜力，比如，作为一种高负荷调试环境中的RCU实现。下面我们将介绍一种对写者更有利的引用计数RCU变体。</p>
<h3 id="不会让更新者饥饿的引用计数RCU"><a href="#不会让更新者饥饿的引用计数RCU" class="headerlink" title="不会让更新者饥饿的引用计数RCU"></a>不会让更新者饥饿的引用计数RCU</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line"><span class="number">2</span>  <span class="keyword">atomic_t</span> rcu_refcnt[<span class="number">2</span>];</span><br><span class="line"><span class="number">3</span>  <span class="keyword">atomic_t</span> rcu_idx;</span><br><span class="line"><span class="number">4</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_nesting);</span><br><span class="line"><span class="number">5</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_read_idx);</span><br></pre></td></tr></table></figure>

<p>下图展示了一种RCU实现的读端原语，使用一对引用计数（rcu_refcnt[]），通过一个全局索引（rcu_idx）从这对计数中选出一个计数，一个每线程的嵌套计数rcu_nesting，一个每线程的全局索引快照（rcu_read_idx），以及一个全局锁（rcu_gp_lock），上图给出了上述定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">if</span> (n  ==  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">8</span>         i =  atomic_read(&amp;rcu_idx);</span><br><span class="line"><span class="number">9</span>         __get_thread_var(rcu_read_idx)  =  i;</span><br><span class="line"><span class="number">10</span>         atomic_inc(&amp;rcu_refcnt[i]);</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     __get_thread_var(rcu_nesting)  = n  +  <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span>     smp_mb();</span><br><span class="line"><span class="number">14</span>  &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">17  </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>     smp_mb();</span><br><span class="line"><span class="number">22</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (n  ==  <span class="number">1</span>)  &#123;</span><br><span class="line"><span class="number">24</span>         i =  __get_thread_var(rcu_read_idx);</span><br><span class="line"><span class="number">25</span>        atomic_dec(&amp;rcu_refcnt[i]);</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     __get_thread_var(rcu_nesting)  = n  -  <span class="number">1</span>;</span><br><span class="line"><span class="number">28</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>拥有两个元素的rcu_refcnt[]数组让更新者免于饥饿。这里的关键点是synchronize_rcu()只需要等待已存在的读者。如果在给定实例的synchronize_rcu()正在执行时，出现一个新的读者，那么synchronize_rcu()不需要等待那个新的读者。在任意时刻，当给定的读者通过通过rcu_read_lock()进入其RCU读端临界区时，它增加rcu_refcnt[]数组中由rcu_idx变量所代表下标的元素。当同一个读者通过rcu_read_unlock()退出其RCU读端临界区，它减去其增加的元素，忽略对rcu_idx值任何可能的后续更改。</p>
<p>这种安排意味着synchronize_rcu()可以通过修改rcu_idx的值来避免饥饿。假设rcu_idx的旧值为零，因此修改后的新值为1。在修改操作之后到达的新读者将增加rcu_idx[1]，而旧的读者先前递增的rcu_idx [0]将在它们退出RCU读端临界区时递减。这意味着rcu_idx[0]的值将不再增加，而是单调递减。这意味着所有synchronize_rcu()需要做的是等待rcu_refcnt[0]的值达到零。</p>
<p>有了背景，我们来好好看看实际的实现原语。</p>
<p>实现rcu_read_lock()原语自动增加由rcu_idx标出的rcu_refcnt[]成员的值，然后将索引保存在每线程变量rcu_read_idx中。rcu_read_unlock()原语自动减少对应的rcu_read_lock()增加的那个计数的值。不过，因为rcu_idx每个线程只能设置为rcu_idx设置一个值，所以还需要一些手段才能允许嵌套。方法是用每线程的rcu_nesting变量跟踪嵌套。</p>
<p>为了让这种方法能够工作，rcu_read_lock()函数的第6行获取了当前线程的rcu_nesting，如果第7行的检查发现当前处于最外层的rcu_read_lock()，那么第8至10行获取变量rcu_idx的当前值，将其存到当前线程的rcu_read_idx中，然后增加被rcu_idx选中的rcu_refcnt元素的值。第12行不管现在的rcu_nesting值是多少，直接对其加1。第13行执行一个内存屏障，确保RCU读端临界区不会在rcu_read_lock()之前开始。</p>
<p>同样，rcu_read_unlock()函数在第21行也执行一个内存屏障，确保RCU读端临界区不会在rcu_read_unlock()代码之后还未完成。第22行获取当前线程的rcu_nesting，如果第23行的检查发现当前处于最外层的rcu_read_unlock()，那么第24至25行获取当前线程的rcu_read_idx（由最外层的rcu_read_lock()保存）并且原子减少被rcu_read_idx选择的rcu_refcnt元素。无论当前嵌套了多少层，第27行都直接减少本线程的rcu_nesting值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用全局引用计数对的RCU更新端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>     smp_mb();</span><br><span class="line"><span class="number">6</span>     spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">7</span>     i =  atomic_read(&amp;rcu_idx);</span><br><span class="line"><span class="number">8</span>     atomic_set(&amp;rcu_idx,  !i);</span><br><span class="line"><span class="number">9</span>     smp_mb();</span><br><span class="line"><span class="number">10</span>     <span class="keyword">while</span> (atomic_read(&amp;rcu_refcnt[i) !=  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">11</span>         poll(<span class="literal">NULL</span>,  <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="number">12</span>     &#125;</span><br><span class="line"><span class="number">13</span>     smp_mb();</span><br><span class="line"><span class="number">14</span>     atomic_set(&amp;rcu_idx,  i);</span><br><span class="line"><span class="number">15</span>     smp_mb();</span><br><span class="line"><span class="number">16</span>     <span class="keyword">while</span> (atomic_read(&amp;rcu_refcnt[!i]) !=  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">17</span>         poll(<span class="literal">NULL</span>,  <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">20</span>     smp_mb();</span><br><span class="line"><span class="number">21</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>上图实现了对应的synchronize_rcu()。第6行和第19行获取并释放rcu_gp_lock，因为这样可以防止多于一个的并发synchronize_rcu()实例。第7至8行分别获取rcu_idx的值，并对其取反，这样后续的rcu_read_lock()实例将使用与之前的实例不同的rcu_idx值。然后第10至12行等待之前的由rcu_idx选出的元素变成0，第9行的内存屏障是为了保证对rcu_idx的检查不会被优化到对rcu_idx取反操作之前。第13至18行重复这一过程，第20行的内存屏障是为了保证所有后续的回收操作不会被优化到对rcu_refcnt的检查之前执行。</p>
<p><strong>问题</strong>：为什么上图中，在获得自旋锁之前，synchronize_rcu()第5行还有一个内存屏障？</p>
<p><strong>问题</strong>：为什么上图的计数要检查两次？难道检查一次还不够吗？</p>
<p>本节的实现避免了简单计数实现可能发生的更新端饥饿问题。</p>
<p>讨论不过这种实现仍然存在一些严重问题。首先，rcu_read_lock()和rcu_read_unlock()中的原子操作开销很大。事实上，它们比上一个实现中的单个计数要复杂很多，读端原语的开销从Power5单核处理器上的150纳秒到64核处理器上的40微秒不等。更新端synchronize_rcu()原语的开销也变大了，从Power5单核CPU中的200纳秒到64核处理器中的40微秒不等。这意味着RCU读端临界区必须非常长，才能够满足现实世界的读端并发请求。</p>
<p>其次，如果存在很多并发的rcu_read_lock()和rcu_read_unlock()操作，那么对rcu_refcnt的内存访问竞争将会十分激烈，这将导致耗费巨大的高速缓存未命中。这一点进一步延长了提供并发读端访问所需要的RCU读端临界区持续时间。这两个缺点在很多情况下都影响了RCU的目标。</p>
<p>第三，需要检查rcu_idx两次这一点为更新操作增加了开销，尤其是线程数目很多时。</p>
<p>最后，尽管原则上并发的RCU更新可以共用一个公共优雅周期，但是本节的实现串行化了优雅周期，使得这种共享无法进行。</p>
<p>问题：既然原子自增和原子自减的开销巨大，为什么不第10行使用非原子自增，在第25行使用非原子自减呢？</p>
<p>尽管有这样那样的缺点，这种RCU的变体还是可以运用在小型的多核系统上，也许可以作为一种节省内存实现，用于维护与更复杂实现之间的API兼容性。但是，这种方法在CPU增多时可扩展性不佳。</p>
<p>另一种基于引用计数机制的RCU变体极大地改善了读端性能和可扩展性。</p>
<h3 id="可扩展的基于计数RCU实现"><a href="#可扩展的基于计数RCU实现" class="headerlink" title="可扩展的基于计数RCU实现"></a>可扩展的基于计数RCU实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RCU每线程引用计数对的数据定义</span></span><br><span class="line"><span class="number">1</span>  DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line"><span class="number">2</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>  [<span class="number">2</span>], rcu_refcnt);</span><br><span class="line"><span class="number">3</span>  <span class="keyword">atomic_t</span> rcu_idx;</span><br><span class="line"><span class="number">4</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_nesting);</span><br><span class="line"><span class="number">5</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_read_idx);</span><br></pre></td></tr></table></figure>

<p>下图是一种RCU实现的读端原语，其中使用了每线程引用计数。本实现与前一个实现十分类似，唯一的区别在于rcu_refcnt成了一个每线程变量。使用这个两元素数组是为了防止读者导致写者饥饿。使用每线程rcu_refcnt[]数组的另一个好处是，rcu_read_lock()和rcu_read_unlock()原语不用再执行原子操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用每线程引用计数对的RCU读端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">if</span> (n  ==  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">8</span>         i =  atomic_read(&amp;rcu_idx);</span><br><span class="line"><span class="number">9</span>         __get_thread_var(rcu_read_idx)  =  i;</span><br><span class="line"><span class="number">10</span>         __get_thread_var(rcu_refcnt)[i]++;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     __get_thread_var(rcu_nesting)  = n  +  <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span>     smp_mb();</span><br><span class="line"><span class="number">14</span>  &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">17  </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>     smp_mb();</span><br><span class="line"><span class="number">22</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (n  ==  <span class="number">1</span>)  &#123;</span><br><span class="line"><span class="number">24</span>         i  = __get_thread_var(rcu_read_idx);</span><br><span class="line"><span class="number">25</span>         __get_thread_var(rcu_refcnt)[i]–;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     __get_thread_var(rcu_nesting)  = n  –  <span class="number">1</span>;</span><br><span class="line"><span class="number">28</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>问题：别忽悠了！我在rcu_read_lock()里看见atomic_read()原语了！为什么你想假装rcu_read_lock()里没有原子操作？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用每线程引用计数对的RCU更新端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flip_counter_and_wait</span><span class="params">(<span class="keyword">int</span>  i)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>     atomic_set(&amp;rcu_idx,  !i);</span><br><span class="line"><span class="number">6</span>     smp_mb();</span><br><span class="line"><span class="number">7</span>     for_each_thread(t)  &#123;</span><br><span class="line"><span class="number">8</span>         <span class="keyword">while</span> (per_thread(rcu_refcnt, t)[i]  !=  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">9</span>               poll(<span class="literal">NULL</span>,  <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="number">10</span>         &#125;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     smp_mb();</span><br><span class="line"><span class="number">13</span>  &#125;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">16  </span>&#123;</span><br><span class="line"><span class="number">17</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>     smp_mb();</span><br><span class="line"><span class="number">20</span>     spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">21</span>     i =  atomic_read(&amp;rcu_idx);</span><br><span class="line"><span class="number">22</span>     flip_counter_and_wait(i);</span><br><span class="line"><span class="number">23</span>     flip_counter_and_wait(!i);</span><br><span class="line"><span class="number">24</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">25</span>     smp_mb();</span><br><span class="line"><span class="number">26</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>下图是synchronize_rcu()的实现，还有一个辅助函数flip_counter_ and_wait()。synchronize_rcu()函数和前一个实现基本一样，除了原来的重复检查计数过程被替换成了第22至23行的辅助函数。</p>
<p>新的flip_counter_and_wait()函数在第5行更新rcu_idx变量，第6行执行内存屏障，然后第7至11行循环检查每个线程对应的rcu_refcnt元素，等待该值变为0。一旦所有元素都变为0，第12行执行另一个内存屏障，然后返回。</p>
<p>本RCU实现对软件环境有所要求，（1）能够声明每线程变量，（2）每个线程都可以访问其他线程的每线程变量，（3）能够遍历所有线程。绝大多数软件环境都满足上述要求，但是通常对线程数的上限有所限制。更复杂的实现可以避开这种限制，比如，使用可扩展的哈希表。这种实现能够动态地跟踪线程，比如，在线程第一次调用rcu_read_lock()时将线程加入哈希表。</p>
<p>问题：好极了，如果我有N个线程，那么我要等待2N*10毫秒（每个flip_counter_and_wait()调用消耗的时间，假设我们每个线程只等待一次）。我们难道不能让优雅周期再快一点完成吗？</p>
<p>不过本实现还有一些缺点。首先，需要检查rcu_idx两次，这为更新端带来一些开销，特别是线程数很多时。</p>
<p>其次，synchronize_rcu()必须检查的变量数随着线程增多而线性增长，这给线程数很多的应用程序带来一定的开销。</p>
<p>第三，和之前一样，虽然原则上并发的RCU更新可以共用一个公共优雅周期，但是本节的实现串行化了优雅周期，使得这种共享无法进行。</p>
<p>最后，本节曾经提到的软件环境需求，在某些环境下每线程变量和遍历线程可能存在问题。</p>
<p>读端原语的扩展性非常好，不管是在单核系统还是64核系统都只需要115纳秒左右。Synchronize_rcu()原语的扩展性不佳，开销在单核Power5系统上的1微秒到64核系统上的200微秒不等。总体来说，本节的方法可以算是一种初级的产品级用户态RCU实现了。</p>
<p>下面介绍一种能够让并发的RCU更新更有效的算法。</p>
<h3 id="可扩展的基于计数RCU实现，可以共享优雅周期"><a href="#可扩展的基于计数RCU实现，可以共享优雅周期" class="headerlink" title="可扩展的基于计数RCU实现，可以共享优雅周期"></a>可扩展的基于计数RCU实现，可以共享优雅周期</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用每线程引用计数对和共享更新数据的数据定义</span></span><br><span class="line"><span class="number">1</span>  DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line"><span class="number">2</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>  [<span class="number">2</span>], rcu_refcnt);</span><br><span class="line"><span class="number">3</span>  <span class="keyword">long</span> rcu_idx;</span><br><span class="line"><span class="number">4</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_nesting);</span><br><span class="line"><span class="number">5</span>  DEFINE_PER_THREAD(<span class="keyword">int</span>,  rcu_read_idx);</span><br></pre></td></tr></table></figure>

<p>下图是一种使用每线程引用计数RCU实现的读端原语，但是该实现允许更新端共享优雅周期。本节的实现和前面的实现唯一的区别是，rcu_idx现在是一个long型整数，可以自由增长，所以第8行用了一个掩码屏蔽了最低位。我们还将atomic_read()和atomic_set()改成了ACCESS_ONCE()。上图中的数据定义和前例也很相似，只是rcu_idx现在是long类型而非之前的atomic_t类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用每线程引用计数对和共享更新数据的RCU读端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">7</span>     <span class="keyword">if</span> (n  ==  <span class="number">0</span>)  &#123;</span><br><span class="line"><span class="number">8</span>         i =  ACCESS_ONCE(rcu_idx)  &amp; <span class="number">0x1</span>;</span><br><span class="line"><span class="number">9</span>         __get_thread_var(rcu_read_idx)  =  i;</span><br><span class="line"><span class="number">10</span>         __get_thread_var(rcu_refcnt)[i]++;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span>     __get_thread_var(rcu_nesting)  = n  +  <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span>     smp_mb();</span><br><span class="line"><span class="number">14</span>  &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">17  </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>     smp_mb();</span><br><span class="line"><span class="number">22</span>     n =  __get_thread_var(rcu_nesting);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (n  ==  <span class="number">1</span>)  &#123;</span><br><span class="line"><span class="number">24</span>      i  = __get_thread_var(rcu_read_idx);</span><br><span class="line"><span class="number">25</span>         __get_thread_var(rcu_refcnt)[i]–;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     __get_thread_var(rcu_nesting)  = n  –  <span class="number">1</span>;</span><br><span class="line"><span class="number">28</span>  &#125;</span><br><span class="line">```C</span><br></pre></td></tr></table></figure>

<p>//使用每线程引用计数对的RCU共享更新端原语<br>1  static void flip_counter_and_wait(int  ctr)<br>2  {<br>3     int i;<br>4     int t;<br>5<br>6     ACCESS_ONCE(rcu_idx)  = ctr  +  1;<br>7     i =  ctr  &amp; 0x1;<br>8     smp_mb();<br>9     for_each_thread(t)  {<br>10         while (per_thread(rcu_refcnt, t)[i]  !=  0)<br>{<br>11              poll(NULL,  0, 10);<br>12         }<br>13     }<br>14     smp_mb();<br>15  }<br>16<br>17  void synchronize_rcu(void)<br>18  {<br>19     int ctr;<br>20     int oldctr;<br>21<br>22     smp_mb();<br>23     oldctr =  ACCESS_ONCE(rcu_idx);<br>24     smp_mb();<br>25     spin_lock(&amp;rcu_gp_lock);<br>26     ctr =  ACCESS_ONCE(rcu_idx);<br>27     if (ctr  –  oldctr &gt;=  3)  {<br>28         spin_unlock(&amp;rcu_gp_lock);<br>29         smp_mb();<br>30         return;<br>31     }<br>32     flip_counter_and_wait(ctr);<br>33     if (ctr  –  oldctr &lt;  2)<br>34         flip_counter_and_wait(ctr  +  1);<br>35     spin_unlock(&amp;rcu_gp_lock);<br>36     smp_mb();<br>37  }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上图是synchronize_rcu()及其辅助函数flip_counter_and_wait()的实现。flip_counter_and_wait()的变化在于：</span><br><span class="line"></span><br><span class="line">*   1．第6行使用ACCESS_ONCE()代替了atomic_set()，用自增替代取反。</span><br><span class="line">*   2．新增了第7行，将计数的最低位掩去。</span><br><span class="line"></span><br><span class="line">synchronize_rcu()的区别要多一些：</span><br><span class="line"></span><br><span class="line">*   1．新增了一个局部变量oldctr，存储第23行的获取每线程锁之前的rcu_idx值。</span><br><span class="line">*   2．第26行用ACCESS_ONCE()代替atomic_read()。</span><br><span class="line">*   3．第27至30行检查在锁已获取时，其他线程此时是否在循环检查3个以上的计数，如果是，释放锁，执行一个内存屏障然后返回。在本例中，有两个线程在等待计数变为0，所以其他的线程已经做了所有必做的工作。</span><br><span class="line">*   4．在第33至34行，在锁已被获取时，如果当前检查计数是否为0的线程不足2个，那么flip_counter_and_wait()会被调用两次。另一方面，如果有两个线程，另一个线程已经完成了对计数的检查，那么只需再有一个就可以。</span><br><span class="line"></span><br><span class="line">在本方法中，如果有任意多个线程并发调用synchronize_rcu()，一个线程对应一个CPU，那么最多只有3个线程在等待计数变为0。</span><br><span class="line"></span><br><span class="line">尽管有这些改进，本节的RCU实现仍然存在一些缺点。首先，和上一节一样，需要检查rcu_idx两次为更新端带来开销，尤其是线程很多时。</span><br><span class="line"></span><br><span class="line">其次，本实现需要每CPU变量和遍历所有线程的能力，这在某些软件环境可能是有问题的。</span><br><span class="line"></span><br><span class="line">最后，在32位机器上，由于rcu_idx溢出而导致需要做一些额外的检查。</span><br><span class="line"></span><br><span class="line">本实现的读端原语扩展性极佳，不管CPU数为多少，开销大概为115纳秒。synchronize_rcu()原语的开销仍然昂贵，从1微秒到15微秒不等。然而这比前面的200微秒的开销已经好多了。所以，尽管存在这些缺点，本节的RCU实现已经可以在真实世界中的产品中使用了。</span><br><span class="line"></span><br><span class="line">问题：所有这些玩具式的RCU实现都要么在rcu_read_lock()和rcu_read_ unlock()中使用了原子操作，要么让synchronize_rcu()的开销与线程数线性增长。那么究竟在哪种环境下，RCU的实现既可以让上述三个原语的实现简单，又能拥有O(1)的开销和延迟呢？</span><br><span class="line"></span><br><span class="line">重新审视代码，我们看到了对一个全局变量的访问和对不超过4个每线程变量的访问。考虑到在POSIX线程中访问每线程变量的开销相对较高，我们可以将三个每线程变量放进单个结构体中，让rcu_read_lock()和rcu_read_unlock()用单个每线程变量存储类来访问各自的每线程变量。</span><br><span class="line"></span><br><span class="line">但是，下面将会介绍一种更好的办法，可以减少访问每线程变量的次数到一次。</span><br><span class="line"></span><br><span class="line">### 基于自由增长计数的RCU</span><br><span class="line">```C</span><br><span class="line">//使用自由增长计数的数据定义</span><br><span class="line">1  DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line">2  long rcu_gp_ctr  =  0;</span><br><span class="line">3  DEFINE_PER_THREAD(long,  rcu_reader_gp);</span><br><span class="line">4  DEFINE_PER_THREAD(long,  rcu_reader_gp_snap);</span><br></pre></td></tr></table></figure>

<p>下图是一种基于单个全局free-running计数的RCU实现，该计数只对偶数值进行计数，相关的数据定义见上图。rcu_read_lock()的实现极其简单。第3行向全局free-running变量rcu_gp_ctr加1，将相加后的奇数值存储在每线程变量rcu_reader_gp中。第4行执行一个内存屏障，防止后续的RCU读端临界区内容“泄漏”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用自由增长计数的RCU实现</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     __get_thread_var(rcu_reader_gp)  = rcu_gp_ctr  +  <span class="number">1</span>;</span><br><span class="line"><span class="number">4</span>     smp_mb();</span><br><span class="line"><span class="number">5</span>  &#125;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">8  </span>&#123;</span><br><span class="line"><span class="number">9</span>     smp_mb();</span><br><span class="line"><span class="number">10</span>     __get_thread_var(rcu_reader_gp)  = rcu_gp_ctr;</span><br><span class="line"><span class="number">11</span>  &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">14  </span>&#123;</span><br><span class="line"><span class="number">15</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span>     smp_mb();</span><br><span class="line"><span class="number">18</span>     spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">19</span>     rcu_gp_ctr +=  <span class="number">2</span>;</span><br><span class="line"><span class="number">20</span>     smp_mb();</span><br><span class="line"><span class="number">21</span>     for_each_thread(t)  &#123;</span><br><span class="line"><span class="number">22</span>         <span class="keyword">while</span> ((per_thread(rcu_reader_gp, t)  &amp;  <span class="number">0x1</span>) &amp;&amp;</span><br><span class="line"><span class="number">23</span> ((per_thread(rcu_reader_gp,  t)  –</span><br><span class="line"><span class="number">24</span>      rcu_gp_ctr)  &lt; <span class="number">0</span>))  &#123;</span><br><span class="line"><span class="number">25</span>              poll(<span class="literal">NULL</span>,  <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="number">26</span>         &#125;</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">29</span>     smp_mb();</span><br><span class="line"><span class="number">30</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>rcu_read_unlock()实现也很类似。第9行执行一个内存屏障，防止前一个RCU读端临界区“泄漏”。第10行将全局变量rcu_gp_ctr的值复制给每线程变量rcu_reader_gp，将此每线程变量的值变为偶数值，这样当前并发的synchronize_rcu()实例就知道忽略该每线程变量了。</p>
<p>问题：如果任何偶数值都可以让synchronize_rcu()忽略对应的任务，那么第10行为什么不直接给rcu_reader_gp赋值为0？</p>
<p>synchronize_rcu()会等待所有线程的rcu_reader_gp变量变为偶数值。但是，因为synchronize_rcu()只需要等待“在调用synchronize_rcu()之前就已存在的”RCU读端临界区，所以完全可以有更好的方法。第17行执行一个内存屏障，防止之前操纵的受RCU保护的数据结构被乱序（由编译器或者是CPU）放到第17行之后执行。为了防止多个synchronize_rcu()实例并发执行，第18行获取rcu_gp_lock锁（第28释放锁）。然后第19行给全局变量rcu_gp_ctr加2。回忆一下，rcu_reader_gp的值为偶数的线程不在RCU读端临界区里，所以第21至27行扫描rcu_reader_gp的值，直到所有值要么是偶数（第22行），要么比全局变量rcu_gp_ctr的值大（第23至24行）。第25行阻塞一小段时间，等待一个之前已经存在的RCU读端临界区退出，如果对优雅周期的延迟很敏感的话，也可以用自旋锁来代替。最后，第29行的内存屏障保证所有后续的销毁工作不会被乱序到循环之前进行。</p>
<p>问题：为什么需要第17和第29行的内存屏障？难道第18行和第28行的锁原语自带的内存屏障还不够吗？</p>
<p>本节方法的读端性能非常好，不管CPU数目多少，带来的开销大概是63纳秒。更新端的开销稍大，从Power5单核的500纳秒到64核的超过100微秒不等。</p>
<p>这个实现除了刚才提到的更新端的开销较大以外，还有一些严重缺点。首先，该实现不允许RCU读端临界区嵌套。其次如果读者在第3行获取rcu_gp_ctr之后，存储到rcu_reader_gp之前被抢占，并且如果rcu_gp_ctr计数的值增长到最大值的一半以上，但没有达到最大值时，那么synchronize_rcu()将会忽略后续的RCU读端临界区。第三也是最后一点，本实现需要软件环境支持每线程变量和对所有线程遍历。</p>
<p>问题：第3行的读者被抢占问题是一个真实问题吗？换句话说，这种导致问题的事件序列可能发生吗？如果不能，为什么不能？如果能，事件序列是什么样的，我们该怎样处理这个问题？</p>
<h3 id="基于自由增长计数的可嵌套RCU"><a href="#基于自由增长计数的可嵌套RCU" class="headerlink" title="基于自由增长计数的可嵌套RCU"></a>基于自由增长计数的可嵌套RCU</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于自由增长计数的可嵌套RCU的数据定义</span></span><br><span class="line"><span class="number">1</span> DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line"><span class="number">2</span>  <span class="meta">#<span class="meta-keyword">define</span>  RCU_GP_CTR_SHIFT  7</span></span><br><span class="line"><span class="number">3</span>  <span class="meta">#<span class="meta-keyword">define</span>  RCU_GP_CTR_BOTTOM_BIT  (1 &lt;&lt;RCU_GP_CTR_SHIFT)</span></span><br><span class="line"><span class="number">4</span>  <span class="meta">#<span class="meta-keyword">define</span>  RCU_GP_CTR_NEST_MASK (RCU_GP_CTR_BOTTOM_BIT  –  1)</span></span><br><span class="line"><span class="number">5</span>  <span class="keyword">long</span>  rcu_gp_ctr =  <span class="number">0</span>;</span><br><span class="line"><span class="number">6</span> DEFINE_PER_THREAD(<span class="keyword">long</span>, rcu_reader_gp);</span><br></pre></td></tr></table></figure>

<p>下图是一种基于单个全局free-running计数的RCU实现，但是允许RCU读端临界区的嵌套。这种嵌套能力是通过让全局变量rcu_gp_ctr的低位记录嵌套次数实现的，定义在上图中。该方法保留低位来记录嵌套深度。为了做到这一点，定义了两个宏，RCU_GP_CTR_NEST_MASK和RCU_GP_CTR_BOTTOM_BIT。两个宏之间的关系是：RCU_GP_CTR_NEST_MASK=RCU_GP_ CTR_BOTTOM_BIT - 1。RCU_GP_CTR_BOTTOM_BIT宏是用于记录嵌套那一位之前的一位，RCU_GP_CTR_NEST_MASK宏则包含rcu_gp_ctr中所有用于记录嵌套的位。显然，这两个宏必须保留足够多的位来记录允许的最大RCU读端临界区嵌套深度，在本实现中保留了7位，这样，允许最大RCU读端临界区嵌套深度为127，这足够绝大多数应用使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用自由增长计数的可嵌套RCU实现</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">long</span>  tmp;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">long</span>  *rrgp;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>     rrgp  = &amp;__get_thread_var(rcu_reader_gp);</span><br><span class="line"><span class="number">7</span>     tmp  = *rrgp;</span><br><span class="line"><span class="number">8</span>     <span class="keyword">if</span>  ((tmp &amp;  RCU_GP_CTR_NEST_MASK)  ==  <span class="number">0</span>)</span><br><span class="line"><span class="number">9</span>        tmp  =  rcu_gp_ctr;</span><br><span class="line"><span class="number">10</span>     tmp++;</span><br><span class="line"><span class="number">11</span>    *rrgp  =  tmp;</span><br><span class="line"><span class="number">12</span>    smp_mb();</span><br><span class="line"><span class="number">13</span>  &#125;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>  <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">16  </span>&#123;</span><br><span class="line"><span class="number">17</span>    <span class="keyword">long</span>  tmp;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    smp_mb();</span><br><span class="line"><span class="number">20</span>    __get_thread_var(rcu_reader_gp)–;</span><br><span class="line"><span class="number">21</span>  &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>  <span class="function"><span class="keyword">void</span>  <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">24  </span>&#123;</span><br><span class="line"><span class="number">25</span>     <span class="keyword">int</span>  t;</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span>    smp_mb();</span><br><span class="line"><span class="number">28</span>    spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">29</span>     rcu_gp_ctr  += RCU_GP_CTR_BOTTOM_BIT;</span><br><span class="line"><span class="number">30</span>    smp_mb();</span><br><span class="line"><span class="number">31</span>    for_each_thread(t)  &#123;</span><br><span class="line"><span class="number">32</span>        <span class="keyword">while</span>  (rcu_gp_ongoing(t)  &amp;&amp;</span><br><span class="line"><span class="number">33</span>               ((per_thread(rcu_reader_gp,  t)  –</span><br><span class="line"><span class="number">34</span>       rcu_gp_ctr) &lt;  <span class="number">0</span>))  &#123;</span><br><span class="line"><span class="number">35</span>               poll(<span class="literal">NULL</span>, <span class="number">0</span>,  <span class="number">10</span>);</span><br><span class="line"><span class="number">36</span>         &#125;</span><br><span class="line"><span class="number">37</span>     &#125;</span><br><span class="line"><span class="number">38</span>     spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">39</span>    smp_mb();</span><br><span class="line"><span class="number">40</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>rcu_read_lock()的实现仍然十分简单。第6行将指向本线程rcu_reader_gp实例的指针放入局部变量rrgp中，将代价昂贵的访问phtread每线程变量API的数目降到最低。第7行记录rcu_reader_gp的值放入另一个局部变量tmp中，第8行检查低位字节是否为0，表明当前的rcu_read_lock()是最外层的。如果是，第9行将全局变量rcu_gp_ctr的值存入tmp，因为第7行之前存入的值可能已经过期了。如果不是，第10行增加嵌套深度，如果你能记得，它存放在计数的最低7位。第11行将更新后的计数值重新放入当前线程的rcu_reader_gp实例中，然后，也是最后，第12行执行一个内存屏障，防止RCU读端临界区泄漏到rcu_read_lock()之前的代码里。</p>
<p>换句话说，除非当前调用的rcu_read_lock()的代码位于RCU读端临界区中，否则本节实现的rcu_read_lock()原语会获取全局变量rcu_gp_ctr的一个副本，而在嵌套环境中，rcu_read_lock()则去获取rcu_reader_gp在当前线程中的实例。在两种情况下，rcu_read_lock()都会增加获取到的值，表明嵌套深度又增加了一层，然后将结果储存到当前线程的rcu_reader_gp实例中。</p>
<p>有趣的是，rcu_read_unlock()的实现和前面的实现一模一样。第19行执行一个内存屏障，防止RCU读端临界区泄漏到rcu_read_unlock()之后的代码中去，然后第20行减少当前线程的rcu_reader_gp实例，这将减少rcu_reader_gp最低几位包含的嵌套深度。rcu_read_unlock()原语的调试版本将会在减少嵌套深度之前检查rcu_reader_gp的最低几位是否为0。</p>
<p>synchronize_rcu()的实现与前面十分类似。不过存在两点不同。第一，第29行将RCU_GP_CTR_BOTTOM_BIT增加到全局变量rcu_gp_ctr，而不是直接加常数2。第二，第32行的比较被剥离成一个函数，检查RCU_GP_CTR_BOTTOM_BIT指示的位，而非无条件地检查最低位。</p>
<p>本节方法的读端性能与前面的实现几乎一样，不管CPU数目多少，开销大概为65纳秒。更新端的开销仍然较大，从Power5单核的600纳秒到64核的超过100微秒。</p>
<p>问题：为什么不像上一节那样，直接用一个单独的每线程变量来表示嵌套深度，反而用复杂的位运算来表示？</p>
<p>除了解决了RCU读端临界区嵌套问题以外，本节的实现有着和前面实现一样的缺点。另外，在32位系统上，本方法会减少全局变量rcu_gp_ctr变量溢出所需的时间。随后将介绍一种能大大延长溢出所需时间，同时又极大地降低了读端开销的方法。</p>
<p>问题：怎样才能将全局变量rcu_gp_ctr溢出的时间延长一倍？</p>
<p>问题：溢出是致命的吗？为什么？为什么不是？如果是致命的，有什么办法可以解决它？</p>
<h3 id="基于静止状态的RCU"><a href="#基于静止状态的RCU" class="headerlink" title="基于静止状态的RCU"></a>基于静止状态的RCU</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于quiescent-state的RCU的数据定义</span></span><br><span class="line"><span class="number">1</span> DEFINE_SPINLOCK(rcu_gp_lock);</span><br><span class="line"><span class="number">2</span> <span class="keyword">long</span>  rcu_gp_ctr =  <span class="number">0</span>;</span><br><span class="line"><span class="number">3</span> DEFINE_PER_THREAD(<span class="keyword">long</span>, rcu_reader_qs_gp);</span><br></pre></td></tr></table></figure>

<p>下图是一种基于静止状态的用户态级RCU实现的读端原语。数据定义在上图。从图中第1至7行可以看出，rcu_read_lock()和rcu_read_unlock()原语不做任何事情，就和Linux内核一样，这种空函数会成为内联函数，然后被编译器优化掉。之所以是空函数，是因为基于静止状态的RCU实现用之前提到的静止状态来大致的作为RCU读端临界区的长度，这种状态包括第9至15行的rcu_quiescent_state()调用。进入扩展的静止状态（比如当发生阻塞时）的线程可以分别用thread_offline()和thread_online() API，来标记扩展的静止状态的开始和结尾。这样，thread_online()就成了对rcu_read_lock()的模仿，thread_offline()就成了对rcu_read_unlock()的模仿。此外，rcu_quiescent_state()可以被认为是一个rcu_thread_online()紧跟一个rcu_thread_offline()。从RCU读端临界区中调用rcu_quiescent_state()、rcu_thread_offline()或rcu_thread_online()是非法的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于静止状态的RCU读端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">rcu_read_lock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>  &#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>  <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">rcu_read_unlock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">6  </span>&#123;</span><br><span class="line"><span class="number">7</span>  &#125;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> rcu_quiescent_state(<span class="keyword">void</span>)</span><br><span class="line"><span class="number">10</span>  &#123;</span><br><span class="line"><span class="number">11</span>    smp_mb();</span><br><span class="line"><span class="number">12</span>    __get_thread_var(rcu_reader_qs_gp) =</span><br><span class="line"><span class="number">13</span>        ACCESS_ONCE(rcu_gp_ctr)  +  <span class="number">1</span>;</span><br><span class="line"><span class="number">14</span>    smp_mb();</span><br><span class="line"><span class="number">15</span>  &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span>  <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">rcu_thread_offline</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">18  </span>&#123;</span><br><span class="line"><span class="number">19</span>     smp_mb();</span><br><span class="line"><span class="number">20</span>    __get_thread_var(rcu_reader_qs_gp) =</span><br><span class="line"><span class="number">21</span>        ACCESS_ONCE(rcu_gp_ctr);</span><br><span class="line"><span class="number">22</span>    smp_mb();</span><br><span class="line"><span class="number">23</span>  &#125;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>  <span class="function"><span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">rcu_thread_online</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">26  </span>&#123;</span><br><span class="line"><span class="number">27</span>    rcu_quiescent_state();</span><br><span class="line"><span class="number">28</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>在rcu_quiescent_state()中，第11行执行一个内存屏障，防止在静止状态之前的代码乱序到静止状态之后执行。第12至13行获取全局变量rcu_gp_ctr的副本，使用ACCESS_ONCE()来保证编译器不会启用任何优化措施让rcu_gp_ctr被读取超过一次。然后对取来的值加1，储存到每线程变量rcu_reader_qs_gp中，这样任何并发的synchronize_rcu()实例都只会看见奇数值，因此就知道新的RCU读端临界区开始了。正在等待老的读端临界区的synchronize_rcu()实例因此也知道忽略新产生的读端临界区。最后，第14行执行一个内存屏障，这会阻止后续代码（包括可能的RCU读端临界区）对第12至13行的重新排序。</p>
<p>问题：第14行多余的内存屏障会不会显著增加rcu_quiescent_state()的开销？</p>
<p>有些应用程序可能只是偶尔需要用RCU，但是一旦它们开始用，那一定是到处都在用。这种应用程序可以在开始用RCU时调用rcu_thread_online()，在不再使用RCU时调用rcu_thread_offline()。在调用rcu_thread_offline()和下一个调用rcu_thread_ online()之间的时间成为扩展的静止状态，在这段时间RCU不会显式地注册静止状态。</p>
<p>rcu_thread_offline()函数直接将每线程变量rcu_reader_qs_gp赋值为rcu_gp_ctr的当前值，该值是一个偶数。这样所有并发的synchronize_rcu()实例就知道忽略这个线程。</p>
<p>问题：为什么需要第19行和第22行的内存屏障？</p>
<p>rcu_thread_online()函数直接调用rcu_quiescent_state()，这也表示延长静止状态的结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于静止状态的RCU更新端原语</span></span><br><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">void</span> <span class="title">synchronize_rcu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">2  </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span>  t;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>     smp_mb();</span><br><span class="line"><span class="number">6</span>    spin_lock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">7</span>    rcu_gp_ctr  +=  <span class="number">2</span>;</span><br><span class="line"><span class="number">8</span>     smp_mb();</span><br><span class="line"><span class="number">9</span>    for_each_thread(t)  &#123;</span><br><span class="line"><span class="number">10</span>        <span class="keyword">while</span>  (rcu_gp_ongoing(t)  &amp;&amp;</span><br><span class="line"><span class="number">11</span> ((per_thread(rcu_reader_qs_gp,  t)  –</span><br><span class="line"><span class="number">12</span> rcu_gp_ctr) &lt;  <span class="number">0</span>))  &#123;</span><br><span class="line"><span class="number">13</span> poll(<span class="literal">NULL</span>, <span class="number">0</span>,  <span class="number">10</span>);</span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span>    spin_unlock(&amp;rcu_gp_lock);</span><br><span class="line"><span class="number">17</span>    smp_mb();</span><br><span class="line"><span class="number">18</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>下图是synchronize_rcu()的实现，和前一个实现很相像。</p>
<p>本节实现的读端原语快得惊人，调用rcu_read_lock()和rcu_read_unlock()的开销一共大概50皮秒（10的负12次方秒）。synchronize_rcu()的开销从Power5单核上的600纳秒到64核上的超过100微秒不等。</p>
<p>问题：可以确定的是，ca-2008Power系统的时钟频率相当高，可是即使是5GHz的时钟频率，也不足以让读端原语在50皮秒执行完毕。这里究竟发生了什么？</p>
<p>不过，本节的实现要求每个线程要么周期性地调用rcu_quiescent_state()，要么为扩展的静止状态调用rcu_thread_offline()。周期性调用这些函数的要求在某些情况下会让实现变得困难，比如某种类型的库函数。</p>
<p>另外，本节的实现不允许并发的synchronize_rcu()调用来共享同一个优雅周期。不过，完全可以基于这个RCU版本写一个产品级的RCU实现。</p>
<h3 id="关于玩具式RCU实现的总结"><a href="#关于玩具式RCU实现的总结" class="headerlink" title="关于玩具式RCU实现的总结"></a>关于玩具式RCU实现的总结</h3><p>如果你看到这里，恭喜！你现在不仅对RCU本身有了更清晰的了解，而且对其所需要的软件和应用环境也更熟悉了。想要更进一步了解RCU的读者，请自行阅读在各种产品中大量采用的RCU实现。</p>
<p>之前的章节列出了各种RCU原语的理想特性。下面我们将整理一个列表，供有意实现自己的RCU实现的读者做参考。</p>
<ul>
<li>1．必须有读端原语（比如rcu_read_lock()和rcu_read_unlock()）和优雅周期原语（比如synchronize_rcu()和call_rcu()），任何在优雅周期开始前就存在的RCU读端临界区必须在优雅周期结束前执行完毕。</li>
<li>2．RCU读端原语应该有最小的开销。特别是应该避免如高速缓存未命中、原子操作、内存屏障和条件分支之类的操作。</li>
<li>3．RCU读端原语应该有O(1)的时间复杂度，可以用于实时用途。（这意味着读者可以与更新者并发运行。）</li>
<li>4．RCU读端原语应该在所有上下文中都可以使用（在Linux内核中，只有空的死循环时不能使用RCU读端原语）。一个重要的特例是RCU读端原语必须可以在RCU读端临界区中使用，换句话说，必须允许RCU读端临界区嵌套。</li>
<li>5．RCU读端原语不应该有条件判断，不会返回失败。这个特性十分重要，因为错误检查会增加复杂度，让测试和验证变得更复杂。</li>
<li>6．除了静止状态以外的任何操作都能在RCU读端原语里执行。比如像I/O这样的操作也该允许。</li>
<li>7．应该允许在RCU读端临界区中执行的同时更新一个受RCU保护的数据结构。</li>
<li>8．RCU读端和更新端的原语应该在内存分配器的设计和实现上独立。</li>
<li>9．RCU优雅周期不应该被在RCU读端临界区之外阻塞的线程而阻塞。</li>
</ul>
<p>所有这些目标，都被Linux内核RCU实现所满足。后续将分析Linux内核中RCU实现代码。</p>
<h2 id="分级RCU基础"><a href="#分级RCU基础" class="headerlink" title="分级RCU基础"></a>分级RCU基础</h2><p><a href="https://blog.csdn.net/juS3Ve/article/details/80248793" target="_blank" rel="noopener">待续</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核同步</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>RCU</tag>
        <tag>内核同步</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断(1)</title>
    <url>/p/4f47874c.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前<a href="https://www.l2h.site/2018/07/15/linux-interrupt-1/" target="_blank" rel="noopener">LINUX中断学习笔记(1)</a>和<a href="https://www.l2h.site/2018/07/15/linux-interrupt-2" target="_blank" rel="noopener">LINUX中断学习笔记(2)</a>介绍了Linux中断的一些基础知识，但是不够深入。最近公司所在团队逐渐在往内核进一步深入，仅有前边文章的浅显知识已不足以覆盖工作的需求，也无法和部门同事做深入的技术讨论。本文是在工作之余，进行代码的研究和资料的查找，希望可以将中断子系统尽量整理清楚。本文内容会不定期补充更新，也希望能对访问到本站的朋友有所帮助。</p><a id="more"></a>
<p><img src="http://pic.l2h.site/Linux-Interrupt.png" alt></p>
<h2 id="架构-Architecture"><a href="#架构-Architecture" class="headerlink" title="架构(Architecture)"></a>架构(Architecture)</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   +---------+</span><br><span class="line">                    +-------+      |         |</span><br><span class="line">                    |Device1+------+         |</span><br><span class="line">                    +-------+      |         |   +---------+</span><br><span class="line">                                   |         +---+  CPU1   |</span><br><span class="line">                    +-------+      |         |   |         |</span><br><span class="line">                    |Device2+------+         |   +---------+</span><br><span class="line">                    +-------+      |         |</span><br><span class="line">                                   |  IRQ    |   +---------+</span><br><span class="line">                    +-------+      |  Ctrl   |   |  CPU2   |</span><br><span class="line">                    |Device3+------+  A      +---+         |</span><br><span class="line">                    +-------+      |         |   +---------+</span><br><span class="line">                                   |         |</span><br><span class="line">                    +-------+      |         |   +---------+</span><br><span class="line">+------+    +----+  |Device4+------+         |   |  CPU3   |</span><br><span class="line">|Dev5  +----+    |  +-------+      |         +---+         |</span><br><span class="line">+------+    |    |                 |         |   +---------+</span><br><span class="line">            |    +-----------------+         |</span><br><span class="line">+------+    |IRQ |                 +---------+</span><br><span class="line">|Dev6  +----+Ctrl|</span><br><span class="line">+------+    |B   |</span><br><span class="line">+------+    |    |</span><br><span class="line">|Dev7  +----+    |</span><br><span class="line">+------+    |    |</span><br><span class="line">            +----+</span><br></pre></td></tr></table></figure>

<ul>
<li>中断控制器（IRQ Controller）：负责对硬件中断进行管理。例如缓冲、优先级判断等。</li>
<li>硬件设备（Devices）：中断接入中断控制器</li>
</ul>
<p>如上图，系统中可能存在多个中断控制器（IRQ Controller）。中断控制器或者直接与CPU连接，或者通过级联方式接入上一级中断控制器，最后接入CPU。中断控制器可以与系统多个核心都有连接，根据一定方法选择响应该中断的CPU（即设定中断Affinity）</p>
<h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><p>如下图。Linux中断子系统软件架构主要分为三个层次，从上到下依次是：</p>
<ul>
<li>设备驱动层：设备驱动，主要负责向系统注册真正的中断处理函数</li>
<li>硬件无关中断处理层：Linux中断子系统的核心代码</li>
<li>CPU架构相关中断控制器：与CPU架构体系相关的中断处理代码，以及与特定中断控制器相关的中断处理代码</li>
</ul>
<p>可以看出，Linux的中断处理架构非常清晰。硬件无关中断处理层，统一了中断处理的接口：避免了设备驱动实现者必须要关心不同CPU体系以及不同中断处理器的不同特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">| +---------------------------------------------+ |</span><br><span class="line">| |Device    ||Device   || Device   ||  Device  | |  设 备 驱 动 层</span><br><span class="line">| |DriVer    ||DriVer   || DriVer   ||  DriVer  | |</span><br><span class="line">| +---------------------------------------------+ |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line"></span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">| +---------------------------------------------+ |</span><br><span class="line">| |  Linux Interrupt Handle FWK                 | |  Linux硬 件 无 关 中 断 处 理 层</span><br><span class="line">| +---------------------------------------------+ |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line"></span><br><span class="line">+-------------------------+-----------------------+</span><br><span class="line">|------------+ +--------+ | +--------+ +----------|</span><br><span class="line">|| CPU ARCH 1| |CPU ARCH| | |IRQCHIP1| |IRQCHIP2 ||  CPU体 系 相 关 中 断 处 理 层</span><br><span class="line">|------------+ +--------+ | +--------+ +----------|</span><br><span class="line">+-------------------------+-----------------------+</span><br></pre></td></tr></table></figure>

<h3 id="内核目录结构"><a href="#内核目录结构" class="headerlink" title="内核目录结构"></a>内核目录结构</h3><p>IRQ相关的Linux内核目录结构如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Linux/</span><br><span class="line">| </span><br><span class="line">+--&gt;include/</span><br><span class="line">|   |</span><br><span class="line">|   |--&gt;irqchip/             中断控制器相关API定义</span><br><span class="line">|   |--&gt;linux/               Linux硬件无关中断处理层API定义</span><br><span class="line">|       |</span><br><span class="line">|       +--&gt;irqdesc.h</span><br><span class="line">|       |--&gt;irqhandler.h</span><br><span class="line">|       |--&gt;irqdomain.h</span><br><span class="line">|       |--&gt;irqflags.h</span><br><span class="line">|       +--&gt;irq.h</span><br><span class="line">+--&gt;kernel/</span><br><span class="line">|   |</span><br><span class="line">|   +--&gt;irq/                 Linux硬件无关中断处理层实现</span><br><span class="line">|       |</span><br><span class="line">|       +--&gt;irqdesc.c/irqdomain.c/.../etc.</span><br><span class="line">+--&gt;driver/               </span><br><span class="line">    |</span><br><span class="line">    +--&gt;irqchip/             中断控制器的相关实现</span><br></pre></td></tr></table></figure>

<h2 id="内核数据结构以及API"><a href="#内核数据结构以及API" class="headerlink" title="内核数据结构以及API"></a>内核数据结构以及API</h2><p>为了实现上述的软件架构，将中断使用者和硬件相关的代码隔离开。内核定义了一系列了数据结构以及相应的操作函数。本节对其中重点的数据结构进行分析：</p>
<h3 id="中断域（struct-irq-domain）"><a href="#中断域（struct-irq-domain）" class="headerlink" title="中断域（struct irq_domain）"></a>中断域（struct irq_domain）</h3><p>在介绍irq_domain之前，先介绍什么是IRQ Domain。早期的系统，只有一个中断控制器，接入中断控制器的物理中断号都是不同的。但是随着计算机系统的发展，系统中可以挂接更多的中断控制器。特别是嵌入式系统的出现，类似GPIO这种也可以视作一种中断控制器。每个中断控制器都有自己中断线的物理编号，且这些物理编号会有重复。此时，Linux Kernel发展出了IRQ Domain的概念，来区分这些相同的物理中断编号。</p>
<p>IRQ Domain，顾名思义，即中断控制域。每个中断控制器都有自己的struct irq_domain结构体，以及自己下属的物理中断号，也不用担心物理中断号重复无法区分的问题。以“硬件连接”一节的图片为例，IRQ Controller 1及其下属的几根中断输入线作为一个中断控制域，而IRQ Controller 2作为另外一个中断控制域。</p>
<p><img src="http://pic.l2h.site/l2hsiteLinux-interrupt-3-irq-domain.png" alt="Linux中断控制域"></p>
<p><strong>Figure 1. Linux中断控制域图例</strong></p>
<p>可能会有朋友问了，“记得向Linux Kernel注册中断处理函数是唯一的中断号，也没有传入Domain ID之类的参数，这如何解释？”。原因很简单，因为这个唯一的中断号是Linux Kernel分配的全局唯一<strong>虚拟</strong>中断号，Linux通过一定方式将其和中断控制域的物理中断号关联。对每个中断控制域来讲，这种映射/关联主要有以下三类：</p>
<ul>
<li>线性映射(Linear)：固定大小的数组映射（物理中断号为数组索引）。当该中断控制域的物理中断号较连续且数量不大时使用。</li>
<li>基树映射(Radix Tree): 与线性映射相反，物理中断号比较大，或者不太连续时使用。</li>
<li>直接映射(No Map/Diret): 有些中断控制器支持物理中断号编程，其被分配到的虚拟中断号可以被直接设定到中断控制器。</li>
<li>Legacy映射(传统映射？): 特殊的一种映射模式。当需要固定分配一部分中断编号范围时使用。设备驱动可以直接使用约定的虚拟中断号来进行IRQ操作。</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>中断域数据结构的定义在内核目录include/linux/irq.h，其所有成员以及相应解释如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">link</span>;</span>            <span class="comment">//Linux全局irq_domain链表的成员        </span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;                 <span class="comment">//中断控制域的名称</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> *<span class="title">ops</span>;</span> <span class="comment">//中断控制域的操作集合</span></span><br><span class="line">	<span class="keyword">void</span> *host_data;                  <span class="comment">//该中断控制域的私有数据指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;               <span class="comment">//该中断控制域的标识</span></span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span>     <span class="comment">//待补充</span></span><br><span class="line">	<span class="keyword">enum</span> irq_domain_bus_token bus_token;<span class="comment">//中断域的总线类型，见irq_domain_bus_token的定义</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_chip_generic</span> *<span class="title">gc</span>;</span> <span class="comment">//IRQ Domain使用的中断芯片数据结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">parent</span>;</span>       <span class="comment">//如果支持中断控制域层次结构，指向该控制域的父级</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">irq_hw_number_t</span> hwirq_max;          <span class="comment">//该域中的最大物理中断号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_direct_max_irq; <span class="comment">//直接映射的最大中断号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> revmap_size;           <span class="comment">//虚拟/物理线性映射表的大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">revmap_tree</span>;</span> <span class="comment">//虚拟/物理映射基树（当该IRQ Domain使用基树方式映射时）</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> linear_revmap[];       <span class="comment">//虚拟/物理线性映射表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> irq_domain_bus_token &#123;</span><br><span class="line">	DOMAIN_BUS_ANY		= <span class="number">0</span>,</span><br><span class="line">	DOMAIN_BUS_PCI_MSI,</span><br><span class="line">	DOMAIN_BUS_PLATFORM_MSI,</span><br><span class="line">	DOMAIN_BUS_NEXUS,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中断域处理函数"><a href="#中断域处理函数" class="headerlink" title="中断域处理函数"></a>中断域处理函数</h4><p>中断域处理函数主要有以下几类：</p>
<ol>
<li><p>中断域添加/删除函数irq_domain_add_*()/remove()系列，例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性映射添加</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct irq_domain *<span class="title">irq_domain_add_linear</span><span class="params">(struct device_node *of_node,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">const</span> struct irq_domain_ops *ops,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">void</span> *host_data)</span></span></span><br><span class="line"><span class="function"><span class="comment">//直接映射添加</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct irq_domain *<span class="title">irq_domain_add_nomap</span><span class="params">(struct device_node *of_node,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">unsigned</span> <span class="keyword">int</span> max_irq,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">const</span> struct irq_domain_ops *ops,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">void</span> *host_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __irq_domain_add(of_node_to_fwnode(of_node), <span class="number">0</span>, max_irq, max_irq, ops, host_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Legacy映射添加</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct irq_domain *<span class="title">irq_domain_add_legacy_isa</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				struct device_node *of_node,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> struct irq_domain_ops *ops,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">void</span> *host_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> irq_domain_add_legacy(of_node, NUM_ISA_INTERRUPTS, <span class="number">0</span>, <span class="number">0</span>, ops,</span><br><span class="line">				     host_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基树映射添加</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct irq_domain *<span class="title">irq_domain_add_tree</span><span class="params">(struct device_node *of_node,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">const</span> struct irq_domain_ops *ops,</span></span></span><br><span class="line"><span class="function"><span class="params">					 <span class="keyword">void</span> *host_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __irq_domain_add(of_node_to_fwnode(of_node), <span class="number">0</span>, ~<span class="number">0</span>, <span class="number">0</span>, ops, host_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除Domain</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">irq_domain_remove</span><span class="params">(struct irq_domain *host)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建中断号映射的irq_create_XXX()系列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建HWIRQ映射，返回对应的虚拟中断号</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_create_mapping</span><span class="params">(struct irq_domain *host,</span></span></span><br><span class="line"><span class="function"><span class="params">				       <span class="keyword">irq_hw_number_t</span> hwirq)</span></span>;</span><br><span class="line"><span class="comment">//根据Firmware Spec创建映射，一般与设备树DTS解析的信息有关</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_create_fwspec_mapping</span><span class="params">(struct irq_fwspec *fwspec)</span></span>;</span><br><span class="line"><span class="comment">//创建Direct Mapping</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_create_direct_mapping</span><span class="params">(struct irq_domain *host)</span></span>;</span><br><span class="line"><span class="comment">//创建固定映射</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">irq_create_strict_mappings</span><span class="params">(struct irq_domain *domain,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> irq_base,</span></span></span><br><span class="line"><span class="function"><span class="params">				      <span class="keyword">irq_hw_number_t</span> hwirq_base,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IRQ Domain Callback函数，供IRQ Chip Driver定义。而该中断域中的设备驱动在</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*match)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">enum</span> irq_domain_bus_token bus_token); <span class="comment">//</span></span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">map</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq, <span class="keyword">irq_hw_number_t</span> hw);                                       <span class="comment">// 创建或者更新虚拟中断号及中断域物理中断号的映射</span></span><br><span class="line">	<span class="keyword">void</span> (*unmap)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq);<span class="comment">//删除映射</span></span><br><span class="line">	<span class="keyword">int</span> (*xlate)(struct irq_domain *d, struct device_node *node,</span><br><span class="line">		     <span class="keyword">const</span> u32 *intspec, <span class="keyword">unsigned</span> <span class="keyword">int</span> intsize,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);<span class="comment">//根据DTS节点以及对应的interrupt描述符，解析出物理中断号和中断出发方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>	CONFIG_IRQ_DOMAIN_HIERARCHY</span></span><br><span class="line"><span class="comment">//以下为IRQ Domain 层次相关回调函数</span></span><br><span class="line">	<span class="keyword">int</span> (*alloc)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs, <span class="keyword">void</span> *arg);</span><br><span class="line">	<span class="keyword">void</span> (*<span class="built_in">free</span>)(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> virq,</span><br><span class="line">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_irqs);</span><br><span class="line">	<span class="keyword">void</span> (*activate)(struct irq_domain *d, struct irq_data *irq_data);</span><br><span class="line">	<span class="keyword">void</span> (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);</span><br><span class="line">	<span class="keyword">int</span> (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,</span><br><span class="line">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> *out_hwirq, <span class="keyword">unsigned</span> <span class="keyword">int</span> *out_type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们在后边的介绍中再回过头看这些回调函数的定义。</p>
<h3 id="中断描述符-struct-irq-desc"><a href="#中断描述符-struct-irq-desc" class="headerlink" title="中断描述符 (struct irq_desc)"></a>中断描述符 (struct irq_desc)</h3><p>接着我们介绍中断描述符。中断描述符与Kernel中全局唯一的虚拟中断号关联。中断描述符或者采取固定分配，例如：</p>
<blockquote>
<p>struct irq_desc irq_desc[NR_IRQS];</p>
</blockquote>
<p>或者采用分散管理方式（管理上使用基树-Radix Tree做管理）：</p>
<blockquote>
<p>#ifdef CONFIG_SPARSE_IRQ<br>static RADIX_TREE(irq_desc_tree, GFP_KERNEL);</p>
<p>#endif</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配cnt数量的连续中断号</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_alloc_hwirqs</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, irq = __irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, cnt, node, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = irq; cnt &gt; <span class="number">0</span>; i++, cnt--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arch_setup_hwirq(i, node))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		irq_clear_status_flags(i, _IRQ_NOREQUEST);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> irq;</span><br><span class="line">err: <span class="comment">//如果执行失败，则释放之前已经分配的中断</span></span><br><span class="line">	<span class="keyword">for</span> (i--; i &gt;= irq; i--) &#123;</span><br><span class="line">		irq_set_status_flags(i, _IRQ_NOREQUEST | _IRQ_NOPROBE);</span><br><span class="line">		arch_teardown_hwirq(i);</span><br><span class="line">	&#125;</span><br><span class="line">	irq_free_descs(irq, cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放已经分配的中断描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_free_descs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> from, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (from &gt;= nr_irqs || (from + cnt) &gt; nr_irqs)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">		free_desc(from + i);</span><br><span class="line">	mutex_lock(&amp;sparse_irq_lock);</span><br><span class="line">	bitmap_clear(allocated_irqs, from, cnt);</span><br><span class="line">	mutex_unlock(&amp;sparse_irq_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而中断描述符的数据结构以及其与中断子系统其他数据结构的关系如下（本图以线性管理方式为例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-------+-------+------+-------+-------+</span><br><span class="line">|irq_   | irq_  | irq_  | irq_ | ....  | irq_  |</span><br><span class="line">|desc 0 | desc 1| desc 2| desc3|       | desc n|</span><br><span class="line">+---+---+------------------------------+-------+</span><br><span class="line">    |</span><br><span class="line">    |</span><br><span class="line">+---v------+</span><br><span class="line">|handle_irq|</span><br><span class="line">+----------+</span><br><span class="line">|lock      |</span><br><span class="line">+----------+    +---------------+</span><br><span class="line">|irq_data  +---&gt;+struct irq_data|</span><br><span class="line">+----------+    +------+--------+</span><br><span class="line">| ....     |           |</span><br><span class="line">+----------+           v</span><br><span class="line">|*action   |    +--------------+</span><br><span class="line">+----------+    |    irq        |</span><br><span class="line">                +---------------+</span><br><span class="line">                |    hw_irq     |</span><br><span class="line">                +---------------+</span><br><span class="line">                |struct irq_chip|</span><br><span class="line">                +---------------|</span><br><span class="line">                |struct irq_domain</span><br><span class="line">                +---------------+</span><br><span class="line">                |struct irq_data|</span><br><span class="line">                +---------------+</span><br><span class="line">                | *chip_data    |</span><br><span class="line">                +---------------+</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>handle_irq</strong>: High-level IRQ处理函数，一般在中断控制器初始化时定义</li>
<li><strong>irq_data</strong>: 中断相关数据<ul>
<li>中断号</li>
<li>物理中断号</li>
<li>IRQ中断域</li>
<li>IRQ控制器芯片相关信息</li>
<li>IRQ控制器芯片独有的数据</li>
</ul>
</li>
<li><strong>action</strong>: 设备驱动注册的中断处理函数（即request_irq传入的Handler）</li>
</ul>
<h3 id="中断芯片-struct-irq-chip"><a href="#中断芯片-struct-irq-chip" class="headerlink" title="中断芯片 (struct irq_chip)"></a>中断芯片 (struct irq_chip)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>	*name; <span class="comment">//中断芯片名称，会呈现在/proc/interrupts内</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>	<span class="params">(*irq_startup)</span><span class="params">(struct irq_data *data)</span></span>; <span class="comment">//中断开启（默认指向enable回调函数）</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_shutdown)(struct irq_data *data); <span class="comment">//中断关闭（默认指向disable回调）</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_enable)(struct irq_data *data);  <span class="comment">//开中断 （如果未定义，默认执行irq_mask）</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_disable)(struct irq_data *data);  <span class="comment">//关中断</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_ack)(struct irq_data *data); <span class="comment">//？？</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask)(struct irq_data *data); <span class="comment">//屏蔽中断</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_mask_ack)(struct irq_data *data); <span class="comment">//??</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_unmask)(struct irq_data *data); <span class="comment">//中断去除屏蔽</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_eoi)(struct irq_data *data); <span class="comment">//中断结束</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_affinity)(struct irq_data *data, <span class="keyword">const</span> struct cpumask *dest, <span class="keyword">bool</span> force); <span class="comment">//设置中断的CPU affinity</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_retrigger)(struct irq_data *data); <span class="comment">//重新发送IRQ到CPU</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_type)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> flow_type); <span class="comment">//设定IRQ类型（边沿触发，电平触发）</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_wake)(struct irq_data *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> on); <span class="comment">//电源管理休眠或唤醒时使用，若该中断需要在CPU休眠时能触发，则函数需要实现对应功能</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_lock)(struct irq_data *data);</span><br><span class="line"><span class="comment">//IRQ BUS锁</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_bus_sync_unlock)(struct irq_data *data);  <span class="comment">//??</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_online)(struct irq_data *data);<span class="comment">//配置第二CPU的中断源</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_cpu_offline)(struct irq_data *data);<span class="comment">//配置第二CPU的中断源</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_suspend)(struct irq_data *data); <span class="comment">// 进入休眠状态前电源管理系统调用</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_resume)(struct irq_data *data); <span class="comment">//唤醒后电源管理系统调用</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_pm_shutdown)(struct irq_data *data);<span class="comment">//电源管理相关，当关机前（Suspend to disk前应该也会调用），内核调用</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_calc_mask)(struct irq_data *data);<span class="comment">//??</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);<span class="comment">//当用户调用显示中断时，印出中断芯片的一些特别字段</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_request_resources)(struct irq_data *data);</span><br><span class="line">	<span class="keyword">void</span>		(*irq_release_resources)(struct irq_data *data); <span class="comment">//调用其他callback前请求或者释放资源（可选）</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);<span class="comment">//对MSI中断类型有效</span></span><br><span class="line">	<span class="keyword">void</span>		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);<span class="comment">//对MSI中断类型有效</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_get_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> *state); <span class="comment">//返回IRQ中断芯片状态</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_irqchip_state)(struct irq_data *data, <span class="keyword">enum</span> irqchip_irq_state which, <span class="keyword">bool</span> state);<span class="comment">//设定IRQ中断芯片状态</span></span><br><span class="line">	<span class="keyword">int</span>		(*irq_set_vcpu_affinity)(struct irq_data *data, <span class="keyword">void</span> *vcpu_info); <span class="comment">//虚拟机中的CPU Affinity</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	flags; <span class="comment">//中断芯片相关字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p><a href="https://www.l2h.site/2019/01/01/linux-interrupt-4" target="_blank" rel="noopener">Linux中断(2) – 流程</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中断</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>L&amp;H的半北疆8日游</title>
    <url>/p/8b68b8ac.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想游 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 已久，一直因为某些众所周知的因素不敢出行。终于，趁着这段空档期，恰在X程订到了1500一人的端午开始的8天7晚 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10757.html" target="_blank" rel="noopener">北疆</a> 游，便开始这场说走就走的旅行。后来根据一路的住宿游玩等内容算起来，这段行程对旅行社一定是亏本赚吆喝买卖。</p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>动身：<br>我们是从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10035.html" target="_blank" rel="noopener">成都</a> 出发，由于想（机）多玩（票）地方（贵），真正动身先坐火车卧铺到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> ，从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a>转机到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 。  </p><a id="more"></a>

<p>紧接着随团行程如下图：</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/565857780.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s14/M00/87/51/wKgE2l0HT3iAaYxoAAwnlE5wL2E379.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>以下为行车线路：</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/565917107.html" target="_blank" rel="noopener"><img src="http://n3-q.mafengwo.net/s14/M00/8B/DE/wKgE2l0HUMKAPqHkAAcQr2y5lm8180.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>返程：最后一日回程从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 直飞 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13663.html" target="_blank" rel="noopener">绵阳</a> 转动车回蓉（省钱）  </p>
<h2 id="兰州二打卡"><a href="#兰州二打卡" class="headerlink" title="兰州二打卡"></a>兰州二打卡</h2><p><img src="http://images.mafengwo.net/images/i/face/brands_v3/10.png" alt></p>
<p>上次到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 是4年前，当时是将其作为到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> 的中转站。时间仓促，只逛了兰大老校区，在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13295.html" target="_blank" rel="noopener">甘肃</a> 省博物馆参观了著名的马踏飞燕。<br>此行 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 仍为中转站目的，因为到达 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 时间较早，参观了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18668.html" target="_blank" rel="noopener">黄河</a> 母亲雕像，以及著名的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10514.html" target="_blank" rel="noopener">中山</a> 桥。中午 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10805.html" target="_blank" rel="noopener">日照</a> 强烈，并未登上白塔山公园。我想如果有下次中转打卡时候，将 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 市看完  。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566047603.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s14/M00/94/52/wKgE2l0HVAeAZfGuAAf6dzgRjY4679.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566047604.html" target="_blank" rel="noopener"><img src="http://p3-q.mafengwo.net/s14/M00/94/54/wKgE2l0HVAiAK5N5AAmHeocZm1o624.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>游览完 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10783.html" target="_blank" rel="noopener">兰州</a> 当天飞到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 为9点，天仍大亮，因之前到过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> ，并不觉得新奇。第一感觉反而是，机场真大，真TM辽阔！然而此时并来不及赞叹观赏，饥肠辘辘的我们亟待回到市区解决肚子的需求。当晚住在一家新开的如家（非旅行社安排内）。</p>
<h2 id="“亚洲，美洲，巴州”"><a href="#“亚洲，美洲，巴州”" class="headerlink" title="“亚洲，美洲，巴州”"></a>“亚洲，美洲，巴州”</h2><p>翌日是端午节，自由活动，当天好友带着游 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 。<br>中午12点好友到酒店来接吃饭（顺便讲一下， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 的作息时间与内地相差2个小时左右），吃饭的地方是一家有歌舞表演的餐馆“纳瓦”。</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566662062.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s14/M00/BE/D0/wKgE2l0HbzGAKRqYAAl0ZHSaNPk126.png?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>参观了大巴扎，当时正好广场上在跳舞，大家尽情施展舞技，也可以随意参与。不得不说维族人民各个能歌善舞。</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566666079.html" target="_blank" rel="noopener"><img src="http://n1-q.mafengwo.net/s14/M00/BF/38/wKgE2l0Hb5aAEEL6AAHGZSfEiUs454.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>晚上好友约上其高中同学一起撸串，听到我第二天出行，其高中同学谈起 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 之大，说起了标题的梗：“世界几大洲来数一数： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/52314.html" target="_blank" rel="noopener">亚洲</a> 、美洲、巴州（ <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18231.html" target="_blank" rel="noopener">巴音郭楞</a> 自治州）”。<br>微醺之后打车回到住处（旅行社所订酒店）， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 昆仑宾馆。这个宾馆有名之处在于其为“八楼”地名的来历，想来听过刀郎“2002年的第一场雪”的朋友们不会陌生（暴露年龄了）。</p>
<h2 id="“这是一段魔鬼行程”"><a href="#“这是一段魔鬼行程”" class="headerlink" title="“这是一段魔鬼行程”"></a>“这是一段魔鬼行程”</h2><p>第二天真正开始旅途，同行还有母女两人，坐一个7人商务车。师傅上车就跟我们讲道，旅行社这个安排有诸多往返行程。单日有时要开上700多公里甚至更多。他们其他师傅，甚至负责调度的旅行社同事一致觉得这是魔鬼行程。主要是因为：<br>– <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 之大<br>–旅行的安排景点够多<br>–路况虽好，一路低至60、70码的限速、<br>–师傅除了开车，还要负责安排食宿买景点票等<br>当然师傅虽累，却也非常负责。师傅本人是随兵团来的疆三代，一路上和师傅也聊了蛮多有关 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 的东西。</p>
<h2 id="额尔齐斯河"><a href="#额尔齐斯河" class="headerlink" title="额尔齐斯河"></a>额尔齐斯河</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18027.html" target="_blank" rel="noopener">额尔齐斯河</a> （简称“额河”）是学初中地理时就学过甚至特别有印象的河流。除了其是我国唯一一个自东向西并灌入北冰洋的河流，更因为其好听的名字。<br>行程第一天的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/64136.html" target="_blank" rel="noopener">可可托海</a> 和第二天的五彩滩则全为额河景点。6月河水正为丰水期，在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/18027.html" target="_blank" rel="noopener">额尔齐斯河</a> 大峡谷看到奔流但又凶恶的河水，流过针叶树林，以及旁边带草的浅滩，一阵阵开阔奔腾之感油然而生，让人好不生爱。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566826828.html" target="_blank" rel="noopener"><img src="http://p1-q.mafengwo.net/s14/M00/CB/D7/wKgE2l0He5KAYToIAAmQ77LiJMI169.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>看过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11340.html" target="_blank" rel="noopener">张掖</a> 丹霞，却不胜五彩滩的丹霞地貌，在额河风光的映衬下好似一副画作，更为出众。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/566841987.html" target="_blank" rel="noopener"><img src="http://b1-q.mafengwo.net/s14/M00/CC/D4/wKgE2l0HfHuAEPh1AA8_e1JuJGs403.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<h2 id="星空呢？"><a href="#星空呢？" class="headerlink" title="星空呢？"></a>星空呢？</h2><p>不同于额河， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 和 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 风景与 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/12703.html" target="_blank" rel="noopener">四川</a> 的高原草场比较像：高山草甸、野花、马牛羊在草场悠然地吃着草。一时间让人觉得，就在这个地方作只牛羊也甚好。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567699124.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s14/M00/16/8D/wKgE2l0HqRiALuIgAAaEF52WyoU208.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567699125.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s14/M00/16/8F/wKgE2l0HqRmANK16AAca-RcnW04835.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 最期待的就是看到星空银河，况且一直对自己“召唤阳光”的技能充满自信，但是此行 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> ，无奈连日落雨，小木屋里看银河以及观 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/144202.html" target="_blank" rel="noopener">鱼台</a> 上找 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 水怪行程都落空。虽是如此，小木屋里听雨已经<a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 湖边漫步则是另外一种感觉。<br>因为行程安排较紧， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10832.html" target="_blank" rel="noopener">禾木</a> 这种需要慢下来享受的地方，没有玩得很充分。希望下次再来，悠然地住上几天。</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742350.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s14/M00/18/71/wKgE2l0HqjyAVIisAAWVm8T-CCY758.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742351.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s14/M00/18/72/wKgE2l0Hqj2AQWyGAAYte1VLSfU048.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568203610.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s14/M00/2F/A6/wKgE2l0HvMaAHUIgAAlDRoV89lk611.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/567742353.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s14/M00/18/74/wKgE2l0Hqj-AYlbcAAzHPZPgZo0174.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>游览完 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10732.html" target="_blank" rel="noopener">喀纳斯</a> 驱车几百公里回到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17988.html" target="_blank" rel="noopener">布尔津</a> ，下图为 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10300.html" target="_blank" rel="noopener">俄罗斯</a> 风情小镇。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048108.html" target="_blank" rel="noopener"><img src="http://b4-q.mafengwo.net/s14/M00/25/79/wKgE2l0HsyeAMDyZAATgqMT8IEI892.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048109.html" target="_blank" rel="noopener"><img src="http://n2-q.mafengwo.net/s14/M00/25/7C/wKgE2l0HsyiANZPHAAhYR3f9PDQ984.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568048111.html" target="_blank" rel="noopener"><img src="http://p3-q.mafengwo.net/s14/M00/25/7E/wKgE2l0HsymAY8XpAAa8RRCzkUY546.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<h2 id="重温魔鬼城"><a href="#重温魔鬼城" class="headerlink" title="重温魔鬼城"></a>重温魔鬼城</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> ，一座以石油命名的城市。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/21297.html" target="_blank" rel="noopener">乌尔禾</a> 魔鬼城就在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> ，之前到过 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10240.html" target="_blank" rel="noopener">敦煌</a> “附近”（其实也有100多KM）雅丹魔鬼城，这种风化岩地形还蛮类似，因此比较震撼的是 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/15017.html" target="_blank" rel="noopener">克拉玛依</a> 的油井。  </p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198721.html" target="_blank" rel="noopener"><img src="http://b4-q.mafengwo.net/s14/M00/2F/58/wKgE2l0HvHWAecfiAA8zkKV4bZw967.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198722.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s14/M00/2F/59/wKgE2l0HvHWAQvYjAAXNplg6u5M013.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198723.html" target="_blank" rel="noopener"><img src="http://b3-q.mafengwo.net/s14/M00/2F/5C/wKgE2l0HvHeAe-kHAAjbwH5lbX8554.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>到处都是油井</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/568198725.html" target="_blank" rel="noopener"><img src="http://n3-q.mafengwo.net/s14/M00/2F/5D/wKgE2l0HvHiATokMAAUn4ccSa2Q361.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<h2 id="天山天池-新疆野马生态园"><a href="#天山天池-新疆野马生态园" class="headerlink" title="天山天池+新疆野马生态园"></a>天山天池+新疆野马生态园</h2><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 南边200多公里， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> 和野马生态园是到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 路上经过乌市时经过的。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> 非常漂亮，海拔虽不高，但是因为纬度高的关系，山顶总是白雪覆盖。可惜到达天池一样下着小雨（第二天甚至已经被白雪覆盖）。</p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/569938993.html" target="_blank" rel="noopener"><img src="http://p2-q.mafengwo.net/s14/M00/73/C0/wKgE2l0IPJ6AKyNeAAF1uuYN864310.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/photo/13061/scenery_13759048/569938994.html" target="_blank" rel="noopener"><img src="http://n4-q.mafengwo.net/s14/M00/73/C0/wKgE2l0IPJ-AEJR-AAiDKw1KNHg936.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://p4-q.mafengwo.net/s14/M00/73/C2/wKgE2l0IPJ-ABv71AAQM4AwM9A8481.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://p4-q.mafengwo.net/s14/M00/73/C2/wKgE2l0IPJ-ABv71AAQM4AwM9A8481.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<h2 id="下雨的库木塔格沙漠"><a href="#下雨的库木塔格沙漠" class="headerlink" title="下雨的库木塔格沙漠"></a>下雨的库木塔格沙漠</h2><p>也许老天赏脸，到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 居然不热，第二天到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/16245.html" target="_blank" rel="noopener">鄯善</a> 的库木塔格沙漠还微微落雨。（复习一下高中地理， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 全年降雨量不过16.4毫米）。地面气温最高时有80多度的火焰山居然只有37度。<br>吃到了20块钱3个的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11348.html" target="_blank" rel="noopener">哈密</a> 瓜（果然是产地），与内地所吃味道略有不同（甜度更高，也有可能是心理因素）。据开车师傅讲，再过一个月上市高峰当地可以买到3毛钱一公斤。<br>晚上住在当地新开的一个酒庄宾馆</p>
<p><a href="https://n4-q.mafengwo.net/s14/M00/7E/02/wKgE2l0IQ9aAG8ExAAELGciI0_U018.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s14/M00/7E/02/wKgE2l0IQ9aAG8ExAAELGciI0_U018.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://p4-q.mafengwo.net/s14/M00/7E/04/wKgE2l0IQ9aAdqmsAAEmq3JDxRU225.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://p4-q.mafengwo.net/s14/M00/7E/04/wKgE2l0IQ9aAdqmsAAEmq3JDxRU225.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://b2-q.mafengwo.net/s14/M00/7E/05/wKgE2l0IQ9eAKXj2AAEr9RKCmCc803.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://b2-q.mafengwo.net/s14/M00/7E/05/wKgE2l0IQ9eAKXj2AAEr9RKCmCc803.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>骑了骆驼和沙滩越野车</p>
<p><a href="https://n4-q.mafengwo.net/s14/M00/7C/B9/wKgE2l0IQwmAMIpoAAJnYcrzOJI294.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://n4-q.mafengwo.net/s14/M00/7C/B9/wKgE2l0IQwmAMIpoAAJnYcrzOJI294.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://n1-q.mafengwo.net/s14/M00/7C/BA/wKgE2l0IQwqAVy0cAAagAF-44U4301.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://n1-q.mafengwo.net/s14/M00/7C/BA/wKgE2l0IQwqAVy0cAAagAF-44U4301.JPG?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p>坎儿井（从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10469.html" target="_blank" rel="noopener">吐鲁番</a> 挖过火焰山一直到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/17879.html" target="_blank" rel="noopener">天山</a> ，实际感受水温20度左右）  </p>
<p><a href="https://n3-q.mafengwo.net/s14/M00/7D/C7/wKgE2l0IQ7CAQJWuAAGVtnCFniE786.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s14/M00/7D/C7/wKgE2l0IQ7CAQJWuAAGVtnCFniE786.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://b4-q.mafengwo.net/s14/M00/7D/C8/wKgE2l0IQ7GAV68GAAFMXS89bqE804.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://b4-q.mafengwo.net/s14/M00/7D/C8/wKgE2l0IQ7GAV68GAAFMXS89bqE804.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<h2 id="后记：“一定要多推荐我们新疆”"><a href="#后记：“一定要多推荐我们新疆”" class="headerlink" title="后记：“一定要多推荐我们新疆”"></a>后记：“一定要多推荐我们新疆”</h2><p>离别前夜， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10218.html" target="_blank" rel="noopener">乌鲁木齐</a> 观看当地丝路秀表演。</p>
<p><a href="https://n3-q.mafengwo.net/s14/M00/7E/E2/wKgE2l0IRGyAVOqDAADKwKvgOXo690.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://n3-q.mafengwo.net/s14/M00/7E/E2/wKgE2l0IRGyAVOqDAADKwKvgOXo690.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="https://b1-q.mafengwo.net/s14/M00/7E/E4/wKgE2l0IRG2ABVV8AAEIKKh19rk251.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" target="_blank" rel="noopener"><img src="https://b1-q.mafengwo.net/s14/M00/7E/E4/wKgE2l0IRG2ABVV8AAEIKKh19rk251.jpg?imageView2%2F2%2Fw%2F680%2Fq%2F90%7CimageMogr2%2Fstrip%2Fquality%2F90" alt></a></p>
<p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 幅员辽阔，此行8天也只是走马观花看了4分之一都不到的地方，下次应该是到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/11471.html" target="_blank" rel="noopener">伊犁</a> 吧。不禁想起第一天和好友吃饭出门，好友的高中好友再三给我嘱咐“回去一定要多推荐我们 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> ，我们 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/13061.html" target="_blank" rel="noopener">新疆</a> 真的很好”。一定会的！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>新疆</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中断(2)</title>
    <url>/p/646ad48f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.l2h.site/2019/01/01/linux-interrupt-3/" target="_blank" rel="noopener">前文</a>介绍了Linux中断的软件架构，以及其中的重要数据结构。本文介绍中断子系统的一些基本流程。本文组织如下：</p><ol>
<li>初始化流程</li>
<li>中断处理流程</li>
</ol><p>![](<a href="http://pic.l2h.site/l2hsiteLinux" target="_blank" rel="noopener">http://pic.l2h.site/l2hsiteLinux</a> Interrupt-2.png)</p><h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p>Linux中断的初始化分为以下几个部分：</p><ul>
<li>系统初始化</li>
<li>设备驱动初始化</li>
</ul><a id="more"></a>




<h3 id="中断子系统初始化"><a href="#中断子系统初始化" class="headerlink" title="中断子系统初始化"></a>中断子系统初始化</h3><p><img src="http://pic.l2h.site/l2hsiteirq_start_kernel3.jpg" alt></p>
<p>中断初始化流程如上图，初始化从start_kernel()开始：</p>
<ol>
<li>设定early_boot_irq_disabled标志为真，表示系统正在初始化过程中，需要关闭CPU中断。</li>
<li>关闭CPU中断，local_irq_disable()函数根据CPU Arch来执行不同CPU体系结构的关终端代码。这里特别说明一下，另外一个函数local_irq_save也是做同样的事情，只是关闭中断前会保存一下中断的标志状态，供打开中断时恢复。</li>
<li>初始化中断向量表。对ARM来讲直接返回。</li>
<li>初始化中断描述符, <strong><em>early_irq_init()</em></strong></li>
<li>初始化中断控制器, <strong><em>init_IRQ()</em></strong></li>
<li>初始化软中断，会在之后的文章中介绍</li>
<li>开CPU中断</li>
</ol>
<h4 id="early-irq-init"><a href="#early-irq-init" class="headerlink" title="early_irq_init()"></a>early_irq_init()</h4><p>early_irq_init有两种定义，本质上差异不大，根据Linux编译选项<strong><em>CONFIG_SPARSE_IRQ</em></strong>定义与否来决定走哪条路。前文中有简单带过，该编译选项的主要作用是区分中断描述符具体是使用基树还是使用线性管理。本文以基树管理方式来对early_irq_init进行介绍，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">early_irq_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, initcnt, node = first_online_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line"></span><br><span class="line">	init_irq_default_affinity();               --- <span class="number">1</span></span><br><span class="line">	initcnt = arch_probe_nr_irqs();            --- <span class="number">2</span></span><br><span class="line">	printk(KERN_INFO <span class="string">"NR_IRQS:%d nr_irqs:%d %d\\n"</span>, NR_IRQS, nr_irqs, initcnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		nr_irqs = IRQ_BITMAP_BITS;</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))</span><br><span class="line">		initcnt = IRQ_BITMAP_BITS;         --<span class="number">-3</span></span><br><span class="line">	<span class="keyword">if</span> (initcnt &gt; nr_irqs)</span><br><span class="line">		nr_irqs = initcnt;                 --<span class="number">-4</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; initcnt; i++) &#123;            </span><br><span class="line">		desc = alloc_desc(i, node, <span class="literal">NULL</span>);  --<span class="number">-5</span></span><br><span class="line">		set_bit(i, allocated_irqs);        </span><br><span class="line">		irq_insert_desc(i, desc);          --<span class="number">-6</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arch_early_irq_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>初始化IRQ描述符默认分配的IRQ Affinity（对多核生效），之后初始化IRQ描述符时，对应affinity的默认值从该值拷贝</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_irq_default_affinity</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	alloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);</span><br><span class="line">	cpumask_setall(irq_default_affinity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">alloc_cpumask_var</span><span class="params">(<span class="keyword">cpumask_var_t</span> *mask, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc_cpumask_var_node(mask, flags, NUMA_NO_NODE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">alloc_cpumask_var_node</span><span class="params">(<span class="keyword">cpumask_var_t</span> *mask, <span class="keyword">gfp_t</span> flags, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*mask = kmalloc_node(cpumask_size(), flags, node);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PER_CPU_MAPS</span></span><br><span class="line">	<span class="keyword">if</span> (!*mask) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"=&gt; alloc_cpumask_var: failed!\\n"</span>);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> *mask != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取CPU arch的 irq数量。此处是从默认的struct machine_desc（对应嵌入式板级操作集合）的nr_irq字段得到 – 嵌入式设备的机器设定大多各不相同，因此使用者需要定义自己的<br>machine_desc来描述一些设备的基本信息或者回调函数，这个结构体在更早的初始化过程中建立起来。关于machine_desc的描述可以到<a href="https://www.baidu.com/s?wd=struct%20machine_desc" target="_blank" rel="noopener">百度搜索</a>。</p>
</li>
<li><p>确认IRQ数量，如果超过IRQ Bitmap的位数，则发出Warning。</p>
</li>
<li><p>nr_irqs 设置为initcnt</p>
</li>
<li><p>根据irq数据初始化中断描述符，并将它们初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct irq_desc *<span class="title">alloc_desc</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">int</span> node, struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span> gfp = GFP_KERNEL;</span><br><span class="line">	desc = kzalloc_node(<span class="keyword">sizeof</span>(*desc), gfp, node); <span class="comment">//分配中断描述符</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* allocate based on nr_cpu_ids */</span></span><br><span class="line">	desc-&gt;kstat_irqs = alloc_percpu(<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">if</span> (!desc-&gt;kstat_irqs)</span><br><span class="line">		<span class="keyword">goto</span> err_desc;</span><br><span class="line">	<span class="keyword">if</span> (alloc_masks(desc, gfp, node))   <span class="comment">//分配该中断的affinity，并初始化设定为第一步所设置的affinity</span></span><br><span class="line">		<span class="keyword">goto</span> err_kstat;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_init(&amp;desc-&gt;lock); <span class="comment">//初始化中断描述符Spinlock用于并发保护</span></span><br><span class="line">	lockdep_set_class(&amp;desc-&gt;lock, &amp;irq_desc_lock_class);</span><br><span class="line">	desc_set_defaults(irq, desc, node, owner); <span class="comment">//初始化中断描述符其他字段</span></span><br><span class="line">	<span class="keyword">return</span> desc;</span><br><span class="line">err_kstat:</span><br><span class="line">	free_percpu(desc-&gt;kstat_irqs);</span><br><span class="line">err_desc:</span><br><span class="line">	kfree(desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">desc_set_defaults</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc, <span class="keyword">int</span> node, struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line">	desc-&gt;irq_common_data.handler_data = <span class="literal">NULL</span>;</span><br><span class="line">	desc-&gt;irq_common_data.msi_desc = <span class="literal">NULL</span>;</span><br><span class="line">	desc-&gt;irq_data.common = &amp;desc-&gt;irq_common_data;</span><br><span class="line">	desc-&gt;irq_data.irq = irq;</span><br><span class="line">........</span><br><span class="line">	desc-&gt;owner = owner;</span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		*per_cpu_ptr(desc-&gt;kstat_irqs, cpu) = <span class="number">0</span>;</span><br><span class="line">	desc_smp_init(desc, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将中断描述符插入到中断描述符基树 。 注意early_irq_init()函数执行前start_kernel做了基树使用的必要初始化radix_tree_init() 。基树可以在中断值离散时能极大地节约空间，且查找效率也比较高。更多基树的介绍见<a href="https://en.wikipedia.org/wiki/Radix_tree" target="_blank" rel="noopener">Wikipedia</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">RADIX_TREE</span><span class="params">(irq_desc_tree, GFP_KERNEL)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">irq_insert_desc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	radix_tree_insert(&amp;irq_desc_tree, irq, desc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="init-IRQ"><a href="#init-IRQ" class="headerlink" title="init_IRQ()"></a>init_IRQ()</h4><p>init_IRQ为执行与所使用CPU架构对应的中断初始化流程。我们可以查看Linux源码树，arch/***/kernel/irq.c中均对此函数有做了定义。本文以arch/arm64/kernel/irq.c中的定义为例进行介绍。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in arch/arm64/kernel/irq.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">init_IRQ</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	irqchip_init();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in drivers/irqchip/irqchip.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">irqchip_of_table</span>[];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">irqchip_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	of_irq_init(__irqchip_of_table);                          --- <span class="number">1</span></span><br><span class="line">	acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码要作用为根据DTS定义，去Linux IRQ Chip数组里匹配IRQ Chip，并初始化IRQ CHIP。这里内核使用了链接上的一些小技巧，将__irqchip_of_table定义为kernel elf的段(见arch/arm64/kernel/vmlinux.lds)。而Linux编译过程中各个IRQ chip将自己声明在该段中。以gic为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//in drivers/irqchip/irq-gic-v3.c</span></span><br><span class="line">IRQCHIP_DECLARE(gic_v3, <span class="string">"arm,gic-v3"</span>, gic_of_init);</span><br><span class="line"><span class="comment">//逐步展开</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line">		_OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_</span>##<span class="title">name</span>		\</span></span><br><span class="line"><span class="class">		__<span class="title">used</span> __<span class="title">section</span>(__##<span class="title">table</span>##_<span class="title">of_table</span>)			\</span></span><br><span class="line"><span class="class">		 = &#123;</span> .compatible = compat,				\</span><br><span class="line">		     .data = (fn == (fn_type)<span class="literal">NULL</span>) ? fn : fn  &#125;</span><br></pre></td></tr></table></figure>

<p>上述宏定义逐步展开得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_gic_v3</span> __<span class="title">used</span> __<span class="title">section</span>(__<span class="title">irqchip_of_table</span>) =</span></span><br><span class="line"><span class="class">&#123;</span> .compatible= <span class="string">"arm,gic-v3"</span></span><br><span class="line">  .data =  gic_of_init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开后可以清晰地看到，其实IRQCHIP_DECLARE就是将gic_v3这颗IRQ中断控制器的一些基本信息定义到 __irqchip_of_table中。这样在of_irq_init过程中就能进行匹配查找。我们回过头来继续分析of_irq_init()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">of_irq_init</span><span class="params">(<span class="keyword">const</span> struct of_device_id *matches)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>, *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_intc_desc</span> *<span class="title">desc</span>, *<span class="title">temp_desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">intc_desc_list</span>, <span class="title">intc_parent_list</span>;</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_desc_list);</span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_parent_list);</span><br><span class="line"></span><br><span class="line">	for_each_matching_node(np, matches) &#123; ----------<span class="number">-1</span></span><br><span class="line">		<span class="keyword">if</span> (!of_find_property(np, <span class="string">"interrupt-controller"</span>, <span class="literal">NULL</span>) ||</span><br><span class="line">				!of_device_is_available(np))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!desc)) &#123;</span><br><span class="line">			of_node_put(np);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		desc-&gt;dev = of_node_get(np);</span><br><span class="line">		desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</span><br><span class="line">			desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</span><br><span class="line">		list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123; ----------<span class="number">-2</span></span><br><span class="line">		list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line">			<span class="keyword">of_irq_init_cb_t</span> irq_init_cb;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">			match = of_match_node(matches, desc-&gt;dev);</span><br><span class="line">			<span class="keyword">if</span> (WARN(!match-&gt;data,</span><br><span class="line">			    <span class="string">"of_irq_init: no init function for %s\\n"</span>,</span><br><span class="line">			    match-&gt;compatible)) &#123;</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pr_debug(<span class="string">"of_irq_init: init %s @ %p, parent %p\\n"</span>,</span><br><span class="line">				 match-&gt;compatible,</span><br><span class="line">				 desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">			irq_init_cb = (<span class="keyword">of_irq_init_cb_t</span>)match-&gt;data;</span><br><span class="line">			ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent);                                  ------ <span class="number">3</span></span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		desc = list_first_entry_or_null(&amp;intc_parent_list,</span><br><span class="line">						typeof(*desc), <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">			pr_err(<span class="string">"of_irq_init: children remain, but no parents\\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		parent = desc-&gt;dev;</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">           .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.上述函数标号为1的循环，主要是将DTS中定义的所有中断控制器加到intc_desc_list。 可以这样做的前提是，start_kernel初期内核已经做了DTS的初步解析。</p>
<ol start="2">
<li><p>循环2，则是将所有DTS定义的中断控制器，去和编译时 <strong><em>__irqchip_of_table</em></strong>里的定义中断控制器设备做匹配。</p>
</li>
<li><p>如果匹配到，则执行对应irqchip项的<strong>data</strong>字段指向的回调函数。对前面的例子，gic_v3来讲，就是执行<em><strong>gic_of_init</strong>_。关于</em><strong>gic_of_init</strong>_, 本文不做深入解析。大家可以到drivers/irqchip/irq-gic-v3.c去找到对应函数。不过值得一提的是，如<a href="https://www.l2h.site/2019/01/01/linux-interrupt-3/" target="_blank" rel="noopener">Linux中断(1)</a>所讲，每个中断控制器属于一个中断控制域。GIC也不例外，初始化过程中，会去向系统注册中断控制域(irq_domain)。另外也会向如下代码中对handle_arch_irq赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">gic_of_init</span><span class="params">(struct device_node *node, struct device_node *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">	set_handle_irq(gic_handle_irq);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">set_handle_irq</span><span class="params">(<span class="keyword">void</span> (*handle_irq)(struct pt_regs *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (handle_arch_irq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	handle_arch_irq = handle_irq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="设备驱动初始化"><a href="#设备驱动初始化" class="headerlink" title="设备驱动初始化"></a>设备驱动初始化</h3><p>前边所有提到的初始化部分，是为了设备驱动可以简单有效使用中断做准备。事实上，设备驱动使用中断也的确蛮简单。只需要request_irq注册中断处理函数即可。Request IRQ定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __must_check</span><br><span class="line">request_irq(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span><br><span class="line">	    <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_threaded_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">irq_handler_t</span> thread_fn, <span class="keyword">unsigned</span> <span class="keyword">long</span> irqflags,</span></span></span><br><span class="line"><span class="function"><span class="params">			 <span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">       ..........................</span><br><span class="line"></span><br><span class="line">	desc = irq_to_desc(irq);                                ----<span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(struct irqaction), GFP_KERNEL); ----<span class="number">-2</span> start</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;                                ----<span class="number">-2</span> <span class="built_in">end</span></span><br><span class="line"></span><br><span class="line">	chip_bus_lock(desc); <span class="comment">//对该中断描述符设置做访问保护</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);                ----<span class="number">-3</span></span><br><span class="line">	chip_bus_sync_unlock(desc); <span class="comment">//解除访问保护</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line">        .......</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过IRQ编号找到对应的中断描述符</p>
</li>
<li><p>分配IRQ Action, 并将对应的结构体字段赋值（由函数传入）。</p>
</li>
<li><p>将 驱动的中断处理函数挂给该IRQ描述符</p>
</li>
</ol>
<p>根据内核对request_threaded_irq的注释：当设备驱动希望内核启用一个内核线程来响应中断时，需要同时提供handler和thread_fn。尽管会使用thread_fn来响应中断，handler仍然会被调用，保证可以在中断上下文来屏蔽该设备中断。handler调用过后需要返回 IRQ_WAKE_THREAD ，这样内核才能接着呼叫thread_fn。  </p>
<h2 id="中断触发流程"><a href="#中断触发流程" class="headerlink" title="中断触发流程"></a>中断触发流程</h2><p>当中断子系统初始化成功，且设备驱动都注册好中断处理函数后，内核就能正常对中断进行处理了。</p>
<p>以ARM架构为例：当发生中断后，汇编码会调用到handle_arch_irq，即gic的gic_handle_irq函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exception_irq_entry <span class="title">gic_handle_irq</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 irqstat, irqnr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gic_chip_data</span> *<span class="title">gic</span> = &amp;<span class="title">gic_data</span>[0];</span></span><br><span class="line">	<span class="keyword">void</span> __iomem *cpu_base = gic_data_cpu_base(gic);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK); </span><br><span class="line">		irqnr = irqstat &amp; GICC_IAR_INT_ID_MASK;             ----<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1021</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">				writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);</span><br><span class="line">			handle_domain_irq(gic-&gt;domain, irqnr, regs);----<span class="number">-2</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;                                   ----<span class="number">-3</span></span><br><span class="line">			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);</span><br><span class="line">			<span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">				writel_relaxed(irqstat, cpu_base + GIC_CPU_DEACTIVATE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">			smp_rmb();</span><br><span class="line">			handle_IPI(irqnr, regs);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>从中断控制器芯片中读取物理中断号</p>
</li>
<li><p>如果大于15，执行handle_domain_irq</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __handle_domain_irq(struct irq_domain *domain, <span class="keyword">unsigned</span> <span class="keyword">int</span> hwirq,</span><br><span class="line">			<span class="keyword">bool</span> lookup, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> = <span class="title">set_irq_regs</span>(<span class="title">regs</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> irq = hwirq;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	irq_enter();                                      <span class="comment">//进入中断处理前准备</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_DOMAIN</span></span><br><span class="line">	<span class="keyword">if</span> (lookup)</span><br><span class="line">		irq = irq_find_mapping(domain, hwirq);    <span class="comment">//返回虚拟中断号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!irq || irq &gt;= nr_irqs)) &#123;</span><br><span class="line">		ack_bad_irq(irq);</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		generic_handle_irq(irq);                  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq_exit();                                       <span class="comment">//退出IRQ处理</span></span><br><span class="line">	set_irq_regs(old_regs);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generic_handle_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> = <span class="title">irq_to_desc</span>(<span class="title">irq</span>);</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	generic_handle_irq_desc(desc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">generic_handle_irq_desc</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	desc-&gt;handle_irq(desc);                          <span class="comment">//执行中断描述符的handle_irq回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>中断描述符对应的handle_irq函数在GIC Chip初始化时有设定，位于gic_irq_domain_map函数内：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gic_irq_domain_map</span><span class="params">(struct irq_domain *d, <span class="keyword">unsigned</span> <span class="keyword">int</span> irq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      <span class="keyword">irq_hw_number_t</span> hw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">................</span><br><span class="line">	<span class="keyword">if</span> (hw &lt; <span class="number">32</span>) &#123;</span><br><span class="line">................</span><br><span class="line">		irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">				    handle_percpu_devid_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">................</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hw &gt;= <span class="number">32</span> &amp;&amp; hw &lt; gic_data.irq_nr) &#123;</span><br><span class="line">		irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">................</span><br><span class="line">	<span class="keyword">if</span> (hw &gt;= <span class="number">8192</span> &amp;&amp; hw &lt; GIC_ID_NR) &#123;</span><br><span class="line">................</span><br><span class="line">		irq_domain_set_info(d, irq, hw, chip, d-&gt;host_data,</span><br><span class="line">				    handle_fasteoi_irq, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">................</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以handle_fasteoi_irq来进行分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_fasteoi_irq</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	.........</span><br><span class="line">	<span class="keyword">if</span> (desc-&gt;istate &amp; IRQS_ONESHOT)</span><br><span class="line">		mask_irq(desc);                   <span class="comment">//屏蔽中断,即调用对应中断芯片的irq_mask函数</span></span><br><span class="line"></span><br><span class="line">	preflow_handler(desc);</span><br><span class="line">	handle_irq_event(desc);                  <span class="comment">//处理中断</span></span><br><span class="line">        .........</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">handle_irq_event_percpu</span><span class="params">(struct irq_desc *desc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        .........</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> = <span class="title">desc</span>-&gt;<span class="title">action</span>;</span></span><br><span class="line">	<span class="keyword">while</span> (action) &#123;</span><br><span class="line">		<span class="keyword">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">		trace_irq_handler_entry(irq, action);</span><br><span class="line">		res = action-&gt;handler(irq, action-&gt;dev_id);</span><br><span class="line">		trace_irq_handler_exit(irq, action, res);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res) &#123;</span><br><span class="line">		<span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">				warn_no_thread(irq, action);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__irq_wake_thread(desc, action);</span><br><span class="line">		<span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">			flags |= action-&gt;flags;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		retval |= res;</span><br><span class="line">		action = action-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">        .........</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对同一个中断来讲，是可以注册多个中断处理函数的。即request_irq对同一个中断号执行多次。这些handler会被挂到对应中断描述的action链表中。上述函数即依次执行对应该中断号的irqaction中handler（即设备request_irq时注册的handler）。</p>
<ol start="3">
<li>0-15中断号是ARM多核之间用来相互沟通的SGI消息。本文不做分析。</li>
</ol>
<h3 id="irq-enter-与irq-exit"><a href="#irq-enter-与irq-exit" class="headerlink" title="irq_enter()与irq_exit()"></a>irq_enter()与irq_exit()</h3><p>irq_enter和irq_exit是中断处理的重要函数，前一节的handle_domain_irq函数中可以看到他们分别在执行对应中断描述符的handler前后被调用。本节对这两个函数做重点分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_enter</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	rcu_irq_enter();                               </span><br><span class="line">	<span class="keyword">if</span> (is_idle_task(current) &amp;&amp; !in_interrupt()) &#123;----<span class="number">-1</span></span><br><span class="line">h_disable();</span><br><span class="line">		local_bh_disable();</span><br><span class="line">                tick_irq_enter();    </span><br><span class="line">		_local_bh_enable();                    </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__irq_enter();              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __irq_enter()					\  </span></span><br><span class="line">	<span class="keyword">do</span> &#123;						\</span><br><span class="line">		account_irq_enter_time(current);	\</span><br><span class="line">		preempt_count_add(HARDIRQ_OFFSET);	\ ---<span class="number">-2</span></span><br><span class="line">		trace_hardirq_enter();			\  </span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ARCH_IRQ_EXIT_IRQS_DISABLED</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	account_irq_exit_time(current);</span><br><span class="line">	preempt_count_sub(HARDIRQ_OFFSET);</span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt() &amp;&amp; local_softirq_pending())</span><br><span class="line">		invoke_softirq();                   -----<span class="number">-3</span></span><br><span class="line"></span><br><span class="line">	tick_irq_exit();</span><br><span class="line">	rcu_irq_exit();</span><br><span class="line">	trace_hardirq_exit(); <span class="comment">/* must be last! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果当前是在idle状态，且不在中断上下文中，则通知中断状态下发生了idle</p>
</li>
<li><p>irq_enter() 最重要的步骤就是__irq_enter(),本函数的主要作用就是关闭抢占，避免执行中断处理函数时，CPU被调度到执行其他事情。</p>
</li>
<li><p>在执行完设备驱动的中断handler，开始执行irq_exit()，该函数主要的作用就是查看系统中是否有未执行的软中断，若有则呼叫invoke_softirq执行系统中的软中断。此时中断的上半部执行结束，开始执行中断下半部。</p>
</li>
</ol>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>下一篇文章，将介绍中断下半部的主要的实现方式：</p>
<ul>
<li>软中断（Soft IRQ）</li>
<li>Workqueue</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux中断</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核学习电子书</title>
    <url>/p/9a083f8b.html</url>
    <content><![CDATA[<p>本文收集一些Linux内核学习电子书，供参考（不定期更新）</p><p><img src="http://pic.l2h.site/Linux-e-book.jpg" alt></p><h2 id="Linux那些事儿"><a href="#Linux那些事儿" class="headerlink" title="Linux那些事儿"></a>Linux那些事儿</h2><p><img src="http://pic.l2h.site/Linux-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-1024x448.png" alt></p><p><a href="https://pan.baidu.com/s/1rXeCmePKfGdYnhZ9NzXUBQ" target="_blank" rel="noopener">下载（<strong>提取码</strong>：2r1h ）</a></p><h2 id="深入理解Linux内核-第三版-英文版"><a href="#深入理解Linux内核-第三版-英文版" class="headerlink" title="深入理解Linux内核-第三版(英文版)"></a>深入理解Linux内核-第三版(英文版)</h2><p><img src="http://pic.l2h.site/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%E7%AC%AC%E4%B8%89%E7%89%88.png" alt></p><p><a href="https://pan.baidu.com/s/1P9tt5swnUgvzNHfzvjWnVw" target="_blank" rel="noopener">下载（<strong>提取码</strong>：ik4z）  
</a></p><h2 id="Linux设备驱动程序-第三版"><a href="#Linux设备驱动程序-第三版" class="headerlink" title="Linux设备驱动程序(第三版)"></a>Linux设备驱动程序(第三版)</h2><p><img src="http://pic.l2h.site/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.png" alt></p><p><a href="https://pan.baidu.com/s/1IPSOfOwH3NE5HRw9v4AyUg" target="_blank" rel="noopener">下载 (<strong>提取码</strong>：vef7)</a></p><h2 id="深入理解Linux网络-Understanding-Linux-Networking-Internal-英文版"><a href="#深入理解Linux网络-Understanding-Linux-Networking-Internal-英文版" class="headerlink" title="深入理解Linux网络(Understanding Linux Networking Internal)英文版"></a>深入理解Linux网络(Understanding Linux Networking Internal)英文版</h2><a id="more"></a>







<p><img src="http://pic.l2h.site/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C.png" alt></p>
<p><a href="https://pan.baidu.com/s/17-ZuCC0p6h243qLdhAQ0aw" target="_blank" rel="noopener">下载 (<strong>提取码</strong>：i4wl )</a></p>
<h2 id="Linux设备驱动程序内核机制"><a href="#Linux设备驱动程序内核机制" class="headerlink" title="Linux设备驱动程序内核机制"></a>Linux设备驱动程序内核机制</h2><p><img src="http://pic.l2h.site/Screenshot_2019-01-08-23-03-15-795_com.duokan.reader-744x1024.jpg" alt></p>
<p><a href="https://pan.baidu.com/s/1tlNa3BnbrhEIfgIq2OV6dw" target="_blank" rel="noopener">下载(提取码:69m8)</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU 链接脚本LDS介绍</title>
    <url>/p/696008f6.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>程序的从C语言代码变成可以在目标机器上执行额文件，可以分为如下步骤</p><ul>
<li>编译<ul>
<li>预编译：将宏定义等转义编译：将C语言变成目标文件(.o档案)</li>
<li>编译/汇编：将预编译过后的目标变为目标文件</li>
</ul>
</li>
<li>链接：合并多个目标文件(.o/.a)等为最终的可执行文件。</li>
</ul><p>LD命令是GNU链接程序，它可以接受 <em>ld -T</em> 输入链接脚本，根据链接脚本的定义来决定链接方式。在 <strong><a href="https://www.l2h.site/2019/01/05/linux-interrupt-4/" target="_blank" rel="noopener">Linux中断(2)</a></strong> 一文中，有简单提到过Linux里用到了很多链接技巧。因此，学习Linux内核，多少需要对链接脚本基本语法格式有初步了解。 本文即对GNU链接脚本的基本格式进行一些介绍。</p><a id="more"></a>


<p>先看一个基本的链接脚本。在执行_ld_链接时，如果不传入链接脚本，会使用默认的链接脚本。_ld –verbose_可以显示默认的链接脚本，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lambert ~]$ ld --verbose</span><br><span class="line">GNU ld version 2.25.1-32.base.el7_4.1</span><br><span class="line">  Supported emulations:</span><br><span class="line">   elf_x86_64</span><br><span class="line">   elf32_x86_64</span><br><span class="line">   elf_i386</span><br><span class="line">   i386linux</span><br><span class="line">   elf_l1om</span><br><span class="line">   elf_k1om</span><br><span class="line">using internal linker script:</span><br><span class="line">==================================================</span><br><span class="line">/* Script for -z combreloc: combine and sort reloc sections */</span><br><span class="line">/* Copyright (C) 2014 Free Software Foundation, Inc.</span><br><span class="line">   Copying and distribution of this script, with or without modification,</span><br><span class="line">   are permitted in any medium without royalty provided the copyright</span><br><span class="line">   notice and this notice are preserved.  */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;,</span><br><span class="line">              &quot;elf64-x86-64&quot;)</span><br><span class="line">OUTPUT_ARCH(i386:x86-64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SEARCH_DIR(&quot;/usr/x86_64-redhat-linux/lib64&quot;); SEARCH_DIR(&quot;/usr/lib64&quot;); SEARCH_D                                                                                                                                                             IR(&quot;/usr/local/lib64&quot;); SEARCH_DIR(&quot;/lib64&quot;); SEARCH_DIR(&quot;/usr/x86_64-redhat-lin                                                                                                                                                             ux/lib&quot;); SEARCH_DIR(&quot;/usr/local/lib&quot;); SEARCH_DIR(&quot;/lib&quot;); SEARCH_DIR(&quot;/usr/lib                                                                                                                                                             &quot;);</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* Read-only sections, merged into text segment: */</span><br><span class="line">  PROVIDE (__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000)); . = SE                                                                                                                                                             GMENT_START(&quot;text-segment&quot;, 0x400000) + SIZEOF_HEADERS;</span><br><span class="line">  .interp         : &#123; *(.interp) &#125;</span><br><span class="line">  .note.gnu.build-id : &#123; *(.note.gnu.build-id) &#125;</span><br><span class="line">  .hash           : &#123; *(.hash) &#125;</span><br><span class="line">  .gnu.hash       : &#123; *(.gnu.hash) &#125;</span><br><span class="line">  .dynsym         : &#123; *(.dynsym) &#125;</span><br><span class="line">  .dynstr         : &#123; *(.dynstr) &#125;</span><br><span class="line">  .gnu.version    : &#123; *(.gnu.version) &#125;</span><br><span class="line">  .gnu.version_d  : &#123; *(.gnu.version_d) &#125;</span><br><span class="line">  .gnu.version_r  : &#123; *(.gnu.version_r) &#125;</span><br><span class="line">/* 以下部分省略 */</span><br></pre></td></tr></table></figure>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SECTION"><a href="#SECTION" class="headerlink" title="SECTION"></a><strong>SECTION</strong></h3><p>我们知道一个可执行文件有多个段，如.text段、BSS段、data段等。这里SECTION即对应可执行程序的段。一个段由以下几个部分组成：</p>
<ul>
<li>段名称</li>
<li>段内容</li>
<li>段长度信息</li>
</ul>
<p>段可以定义为Loadable和allocatable两种加载方式</p>
<ul>
<li>loadable: 执行时该section是否需要被加载到内存</li>
<li>allocatable: 先保留内存的一块空间让程序执行时使用，如.bss段</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>一个object 档案存放多个symbol，又称为symbol table（符号表）。Symbol通常就是全局变量、静态变量或是函数的名称。我们可以使用<em><strong>objdump -t 可执行文件</strong></em> 或者 <em><strong>readelf -a 可执行文件</strong>_或者</em><strong>nm 可执行文件</strong>_来查看对应可执行文件的符号表。</p>
<h3 id="LMA-V-S-VMA"><a href="#LMA-V-S-VMA" class="headerlink" title="LMA V.S. VMA"></a>LMA V.S. VMA</h3><p>LMA: Load Memory Address, 表示程序被装载到内存哪个位置</p>
<p>VMA: Virutal Memroy Address，表示程序执行的位置，即CPU执行对应程序指令的位置。</p>
<p>通常，LMA = VMA。但是在一些嵌入式体系中， LMA和VMA不一样。而其中最常见的一种情况就是，程序被放到ROM中。而程序要运行时候的地址是内存虚拟地址，也就是VMA。之后小节会有例子做介绍。</p>
<h2 id="Link-Script语法"><a href="#Link-Script语法" class="headerlink" title="Link Script语法"></a>Link Script语法</h2><p>Link Script可以基本总结如下：</p>
<ul>
<li>以文本形式存放</li>
<li>由多个command組成</li>
<li>每个command可能是<ul>
<li>keyword + 参数</li>
<li>设定symbol</li>
<li>…</li>
</ul>
</li>
<li>command 可以用<code>;</code>分開，空白會被忽略</li>
<li>使用/_* * _/注释</li>
<li>字串直接打，如果有用到script保留的字元如<code>.</code>可以用<code>&quot;</code>包住</li>
</ul>
<h3 id="简单链接脚本范例"><a href="#简单链接脚本范例" class="headerlink" title="简单链接脚本范例"></a>简单链接脚本范例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = 0x10000;</span><br><span class="line">  .text : &#123; *(.text) &#125;</span><br><span class="line">  . = 0x8000000;</span><br><span class="line">  .data : &#123; *(.data) &#125;</span><br><span class="line">  .bss : &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>.</em></strong>表示内存位置，起始值为0。结束值则由链接器计算把所有input section的数据整合到output section的长度。而.如果没有指定明确的内存地址的话，就会被设定为上一个地址的结束地址。</p>
<p>第三行：设定内存位置为0x10000</p>
<p>第四行：把所有<strong>输入</strong>object档中({ <em>(.text) })存放到*</em>输出**object档案的.text区块中。</p>
<p>第五行：设定内存位置为0x8000000</p>
<p>第六行、第七行：先放已初始化全局变量（.data），所有输入目标文件中的.data字段都会被打包到此位置；紧接着再放未初始值的全局变量（.bss）。</p>
<h3 id="简单链接脚本命令"><a href="#简单链接脚本命令" class="headerlink" title="简单链接脚本命令"></a>简单链接脚本命令</h3><p><em><strong>ENTRY(symbol)</strong></em> ：设置程序入口点</p>
<h4 id="文件相关命令"><a href="#文件相关命令" class="headerlink" title="文件相关命令"></a>文件相关命令</h4><p><strong>_INCLUDE filename<br>_</strong>在看到这个命令的时候才去载入filename这个linker script。可以被放在不同的命令如SETCTION, MEMORY等。<br>_<strong>INPUT(file1 file2 …)<br>**_指定加载的输入object档案，如abc.o这样的档案。<br>_</strong>GROUP(file1 file2 …)<br><strong>_指定加载的输入archieve档案，如libabc.a这样的档案。<br>_</strong>AS_NEEDED(file1 file2 …)<br><strong>_在INPUT和GROUP使用的命令，用来告诉linker说如果object里面的数据有被reference到才link进来，猜测应该可以减少储存空间。范例（未测试请自行斟酌）：INPUT(file1.o file2.o AS_NEEDED(file3.o file4.o))<br>_</strong>OUTPUT(filename)<br><strong>_和gcc -o filename 一样<br>**_SEARCH_DIR(path)<br>_</strong>和-L path一样<br>_*<em>STARTUP(filename)<br>*</em>_和INPUT相同，唯一差别是ld保证这个档案一定是第一个被link  </p>
<h4 id="输出文件格式相关命令"><a href="#输出文件格式相关命令" class="headerlink" title="输出文件格式相关命令"></a>输出文件格式相关命令</h4><p>_<strong>OUTPUT_FORMAT(bfdname)<br>**_指定输出object档案的binary 文件格式，可以使用objdump -i列出支持的binary 文件格式<br>_</strong>OUTPUT_FORMAT(default, big, little)<br><strong>_指定输出object档案预设的binary 文件格式，big endian的binary 文件格式以及little endian的binary 文件格式。可以使用objdump -i列出支持的binary 文件格式<br>_</strong>TARGET(bfdname)<br>**_告诉ld用那种binary 文件格式读取输入object档案要，可以使用objdump -i列出支持的binary 文件格式</p>
<h4 id="设定内存块别名的命令"><a href="#设定内存块别名的命令" class="headerlink" title="设定内存块别名的命令"></a>设定内存块别名的命令</h4><p><strong><em>REGION_ALIAS(alias, region)</em></strong> 对内存区域设定别名，这样输出段可以灵活地映射。具体可以参考&lt;<a href="https://sourceware.org/binutils/docs/ld/REGION_005fALIAS.html#REGION_005fALIAS" target="_blank" rel="noopener">LD:REGION_ALIAS</a>&gt;</p>
<h4 id="其他链接器相关命令"><a href="#其他链接器相关命令" class="headerlink" title="其他链接器相关命令"></a>其他链接器相关命令</h4><p><strong><em>ASSERT(exp, message)</em></strong> 条件不成立打印message并结束链接过程<br><em><strong>EXTERN(symbol1 symbol2 …)</strong></em> 强迫让指定的symbol设成undefined，手册说一般用在刻意要使用非标准的API。<br><em><strong>FORCE_COMMON_ALLOCATION</strong></em> 手册和男人说和兼容性有关，手册上是说强迫分配空间给common symbols，即使是link relocate档案。(common symbols不知道是什么)<br><em><strong>OUTPUT_ARCH(bfdarch)</strong></em> 指定输出的平台，可以透过objdump -i查询支持平台<br><em><strong>INSERT [ AFTER | BEFORE ] output_section</strong></em> 指定在预设linker script命令被执行之前或是之后加上或加入特定的输入section到输出section</p>
<h2 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h2><h3 id="简单赋值命令范例"><a href="#简单赋值命令范例" class="headerlink" title="简单赋值命令范例"></a>简单赋值命令范例</h3><p>可以在脚本中使用类C语言语法对符号进行赋值，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> symbol = expression ;</span><br><span class="line"> symbol += expression ;</span><br><span class="line"> symbol -= expression ;</span><br><span class="line"> symbol *= expression ;</span><br><span class="line"> symbol /= expression ;</span><br><span class="line"> symbol &lt;&lt;= expression ; symbol &gt;&gt;= expression ;</span><br><span class="line"> symbol &amp;= expression ;</span><br><span class="line"> symbol |= expression ;</span><br><span class="line"></span><br><span class="line">一段简单的范例：</span><br><span class="line"></span><br><span class="line">floating_point = 0;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.text)</span><br><span class="line">      _etext = .;</span><br><span class="line">    &#125;</span><br><span class="line">  _bdata = (. + 3) &amp; ~ 3;</span><br><span class="line">  .data : &#123; *(.data) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行：设定floating_point变量的链接地址为0</p>
<p>第七行：设置_etext的地址为.text之后</p>
<p>第九行：设置_bdata地址为_etext之后4字节alignment的位置。实则是对.data段的起始位置进行字节对齐</p>
<h3 id="HIDDEN"><a href="#HIDDEN" class="headerlink" title="HIDDEN"></a>HIDDEN</h3><p>对输出ELF，把其中某个符号定义为目标文件内可见。对上文范例的symbol改写后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HIDDEN(floating_point = 0);</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.text)</span><br><span class="line">      HIDDEN(_etext = .);</span><br><span class="line">    &#125;</span><br><span class="line">  HIDDEN(_bdata = (. + 3) &amp; ~ 3);</span><br><span class="line">  .data : &#123; *(.data) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>floating_point/_etext/_bdata 为ELF内可见，但是无法导出。即假设目标文件是库文件，其他文件也无法引用使用。</p>
<h4 id="PROVIDE"><a href="#PROVIDE" class="headerlink" title="PROVIDE"></a>PROVIDE</h4><p>链接器直接定义一个symbol，如果它没有在任何输入目标文件中定义，则链接时使用PROVIDE定义的符号。如果目标文件中有定义，则使用目标文件中的定义。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  .text :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.text)</span><br><span class="line">      _etext = .;</span><br><span class="line">      PROVIDE(etext = .);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>_<strong>_etext</strong>_不能在程序中定义，否则链接时有重复定义</li>
<li>_<strong>etext</strong>_则可定义在程序中定义，这样链接器会使用程序中的定义。</li>
</ul>
<h4 id="PROVIDE-HIDDEN"><a href="#PROVIDE-HIDDEN" class="headerlink" title="PROVIDE_HIDDEN"></a>PROVIDE_HIDDEN</h4><p>类似PROVIDE，差异只在于符号是HIDDEN</p>
<h4 id="源代码引用"><a href="#源代码引用" class="headerlink" title="源代码引用"></a>源代码引用</h4><p>C语言内可以引用链接器脚本中定义的变量。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start_of_ROM   = .ROM;</span><br><span class="line">end_of_ROM     = .ROM + <span class="keyword">sizeof</span> (.ROM);</span><br><span class="line">start_of_FLASH = .FLASH;</span><br></pre></td></tr></table></figure>

<p>则C语言中可以如下引用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> start_of_ROM, end_of_ROM, start_of_FLASH;</span><br><span class="line"><span class="built_in">memcpy</span> (&amp; start_of_FLASH, &amp; start_of_ROM, &amp; end_of_ROM - &amp; start_of_ROM);</span><br></pre></td></tr></table></figure>

<h2 id="SECTION-1"><a href="#SECTION-1" class="headerlink" title="SECTION"></a>SECTION</h2><p>SECTION命令告诉链接器如何映射输入的段到输出段，且摆到内存的哪个位置。基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  sections-command</span><br><span class="line">  sections-command</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SECTION命令可能是以下命令的一种</p>
<ul>
<li>ENTRY命令</li>
<li>符号赋值</li>
<li>输出段描述</li>
<li>覆盖描述</li>
</ul>
<p><em><strong>待补充。。。</strong></em></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>&lt;<a href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts" target="_blank" rel="noopener">GNU Link Scripts</a>&gt;</li>
<li>&lt;<a href="https://wen00072.github.io/blog/2014/03/14/study-on-the-linker-script/" target="_blank" rel="noopener">Linker Script初探 - GNU Linker Ld手冊略讀</a>&gt;</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux编译</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LD Script</tag>
        <tag>链接器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux电源管理介绍-1</title>
    <url>/p/ab834475.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了节省功耗，需要让系统在不需要工作的时候尽可能的休眠（甚至断电）。同时，为了不影响到系统功能的正常运作，又必须保证休眠不能打断正在进行的重要事务，且能在适时还原回来。因此，一个高效运行的Low Power框架必不可少。 <img src="http://pic.l2h.site/l2hsiteLinux-low-power-1.png" alt="Linux电源管理介绍-1" title="Linux电源管理介绍-1"> 本文以Linux 4.4内核为基础，介绍Linux的Low Power框架。</p><a id="more"></a>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>Linux的电源管理架构如下图。首先内核态导出了一些sysfs节点，用来给用户空间态作电源管理控制：</p>
<ol>
<li>/sys/power/autosleep : 主要用于控制是否开启内核自动休眠，之后会有章节介绍</li>
<li>/sys/power/state：直接控制进入休眠（有多种state，后边会看到）</li>
<li>/sys/power/wake_lock&amp;wake_unlock：拿Wake lock和释放Wake lock，用于避免正在处理重要事务时系统进入休眠<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                                      +-----------+</span><br><span class="line">                                                      |应 用 程 序|</span><br><span class="line">             +------------------+                     +-----+-----+</span><br><span class="line">             |电 源 管 理 程 序  +---------+                 |</span><br><span class="line">             +-----+------------+         |                 |</span><br><span class="line">                   |                      |                 |</span><br><span class="line">                   |                      |                 |</span><br><span class="line">用 户 空 间 态      v                      v                 v</span><br><span class="line">            /sys/power/autosleep   /sys/power/state  /sys/power/wake_lock&amp;wake_unlock</span><br><span class="line">+------------------+----------------------+-----------------+---------------------------</span><br><span class="line">                   |                      |                 |</span><br><span class="line">内 核 态           |                      |                 |</span><br><span class="line">                   v                      v                 v </span><br><span class="line">             +-----+----------------------+-----------------+---+</span><br><span class="line">             |                   sysfs                          |</span><br><span class="line">             +--------------------------------------------------+</span><br><span class="line">           kernel/power/main.c                              |</span><br><span class="line">               +                                            |</span><br><span class="line">   +--------------------------------------------------------|-------------------------+</span><br><span class="line">   |           |                                            v        电 源 管 理 框 架 |</span><br><span class="line">   |           |                   +--------------------------------+                 |</span><br><span class="line">   |           v                   |                                |                 |</span><br><span class="line">   |  +----------+                 | Wakeup Source                  |                 |</span><br><span class="line">   |  |autosleep | &lt;---------------+                                |                 |</span><br><span class="line">   |  +----------+                 +----------------------------^---+                 |</span><br><span class="line">   |kernel/power/autosleep.c                                    |                     |</span><br><span class="line">   |        |                                             +-----+-----------+         |</span><br><span class="line">   |        |                                             |                 |         |</span><br><span class="line">   |        |--------------------------------------------&gt;|  驱 动 程 序     |         |</span><br><span class="line">   |        v                                             |                 |         |</span><br><span class="line">   |  +-----+--------+                                    +-----------------+         |</span><br><span class="line">   |  | 平 台 相 关   |                                                                |</span><br><span class="line">   |  | 睡 眠 代 码   |                                                                |</span><br><span class="line">   |  +--------------+                                                                |</span><br><span class="line">   |                                                                                  |</span><br><span class="line">   +----------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>内核态是实现电源管理的核心代码，主要分为如下几大功能模块：</p>
<ol>
<li>提供用户空间态操作的SYSFS节点操作</li>
<li>记录系统中拿睡眠锁的Wake Source</li>
<li>内核自动休眠例程Autosleep</li>
<li>平台相关睡眠（及唤醒）代码</li>
<li>各个硬件驱动程序：<ol>
<li>注册硬件相关的睡眠及唤醒代码，保证经过一次断电恢复后的硬件仍能正常工作。</li>
<li>根据应用需要，拿Wake Lock和释放Wake Lock，保证硬件驱动可以正常工作。</li>
</ol>
</li>
</ol>
<h1 id="数据和变量"><a href="#数据和变量" class="headerlink" title="数据和变量"></a>数据和变量</h1><p>在对电源管理的系统流程进行介绍之前，先对电源管理的一些必要的数据结构和关键变量进行分析。</p>
<h2 id="wakeup-source-wakeup-sources"><a href="#wakeup-source-wakeup-sources" class="headerlink" title="wakeup_source/wakeup_sources"></a>wakeup_source/wakeup_sources</h2><p>wakeup_source名字具有一定迷惑性，乍一看像是触发系统从睡眠中唤醒的唤醒源，实则不然。这个结构体是用来描述所有“阻挡”系统进入休眠的对象，即向电源管理模块拿wakelock用的。而wakeup_sources则是记录系统中所有wakeup_source的链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wakeup_source</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> 		*name;            <span class="comment">//名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span>             <span class="comment">//挂入wakeup_sources链表的表头</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;              <span class="comment">//自旋锁保护该wakeup_source内容的修改</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_irq</span>		*<span class="title">wakeirq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">timer</span>;</span>             <span class="comment">//wakeup source相关的定时器</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		timer_expires;  <span class="comment">//超时时间，也就是wake_lock_timeout()里面的时间参数，超时后会执行deactivate函数</span></span><br><span class="line">	<span class="keyword">ktime_t</span> total_time;                  <span class="comment">//该wakeup source被激活的总时间</span></span><br><span class="line">	<span class="keyword">ktime_t</span> max_time;                  </span><br><span class="line">	<span class="keyword">ktime_t</span> last_time;                  <span class="comment">//该wakeup source上次被访问的时间</span></span><br><span class="line">	<span class="keyword">ktime_t</span> start_prevent_time;           <span class="comment">//上次因wakeup source导致系统无法休眠的时间</span></span><br><span class="line">	<span class="keyword">ktime_t</span> prevent_sleep_time;          <span class="comment">//’阻止系统休眠的时长</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		event_count;   <span class="comment">//产生事件数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		active_count;   <span class="comment">//激活次数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		relax_count;    <span class="comment">//释放次数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expire_count;   <span class="comment">//Wakeup source的超时次数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		wakeup_count;  <span class="comment">//该source阻止系统休眠的次数</span></span><br><span class="line">	<span class="keyword">bool</span>			active:<span class="number">1</span>;               <span class="comment">//是否激活状态</span></span><br><span class="line">	<span class="keyword">bool</span>			autosleep_enabled:<span class="number">1</span>;    <span class="comment">//系统是否开启autosleep</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="suspend-state-t"><a href="#suspend-state-t" class="headerlink" title="suspend_state_t"></a>suspend_state_t</h2><p>描述系统休眠几种不同状态，按照睡眠从浅入深分别是：</p>
<ol>
<li>On：未休眠</li>
<li>Freeze：轻量级的休眠状态。</li>
<li>Standby：中等休眠状态，CPU没有挂起（Memory和CPU带电）</li>
<li>Mem：深度休眠，系统及设备状态挂起到Memory（Memory仍然带电），CPU不再工作（少数外围设备工作）。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typedefint __bitwise <span class="keyword">suspend_state_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_ON         ((__force suspend_state_t) 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_FREEZE   ((__force suspend_state_t) 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_STANDBY      ((__force suspend_state_t) 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_MEM             ((__force suspend_state_t) 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_MIN        PM_SUSPEND_FREEZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_SUSPEND_MAX              ((__force suspend_state_t) 4)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="combined-event-count"><a href="#combined-event-count" class="headerlink" title="combined_event_count"></a>combined_event_count</h2><p>用于记录系统中已注册的wakeup事件数量和正在生效的wakeup事件数量。这两个变量需要一起更新的，所以用combined_event_count一个变量来记录。高16 bit存放正在生效的wakeup事件数量，低16bit存放wakeup事件总数量。</p>
<h1 id="后续章节预告"><a href="#后续章节预告" class="headerlink" title="后续章节预告"></a>后续章节预告</h1><blockquote>
<p>Autosleep及power状态设置流程 Autosleep代码分析 Wakelock拿锁与释放锁流程分析</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux电源管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>电源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX电源管理介绍-2</title>
    <url>/p/d1ee5036.html</url>
    <content><![CDATA[<h1 id="前篇文章"><a href="#前篇文章" class="headerlink" title="前篇文章"></a>前篇文章</h1><p><a href="http://www.l2h.site/2018/10/24/linux-low-power-1/" target="_blank" rel="noopener">http://www.l2h.site/2018/10/24/linux-low-power-1/</a> <img src="http://pic.l2h.site/l2hsiteLinux-low-power-2.png" alt="LINUX电源管理介绍-2" title="LINUX电源管理介绍-2"></p><h1 id="电源管理相关状态设置流程"><a href="#电源管理相关状态设置流程" class="headerlink" title="电源管理相关状态设置流程"></a>电源管理相关状态设置流程</h1><p>通过用户空间态访问内核开出的sysfs节点autosleep/state，可以直接控制Linux内核的休眠。例：</p><blockquote>
<p>echo “mem” &gt; /sys/power/state cat /sys/power/autosleep</p>
</blockquote><a id="more"></a>


<h2 id="sys-power-state"><a href="#sys-power-state" class="headerlink" title="/sys/power/state"></a>/sys/power/state</h2><p>/sys/power/state节点的处理代码定义在kernel/power/main.c。首先，节点定义如下：</p>
<p>power_attr(state);          //定义state sysfs节点（struct kobj_attribute）</p>
<p>当从用户态写该节点时（例，前文提到的echo命令），内核中响应函数如下(忽略一些非核心代码)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">state_store</span><span class="params">(struct kobject *kobj, struct kobj_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       error = pm_autosleep_lock();</span><br><span class="line">       state = decode_state(buf, n);            <span class="comment">//将用户空间态传入的state字符串，转化为suspend_state_t，目前只接收"mem", "standby", "freeze"三种输入</span></span><br><span class="line">       <span class="keyword">if</span> (state &lt; PM_SUSPEND_MAX)</span><br><span class="line">              error = pm_suspend(state);         <span class="comment">//调用pm_suspend，根据解析出的电源state进入不同的休眠等级</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (state == PM_SUSPEND_MAX)</span><br><span class="line">              error = hibernate();                <span class="comment">//否则调用hibernate，suspend to disk</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">              error = -EINVAL;</span><br><span class="line"> out:</span><br><span class="line">       pm_autosleep_unlock();</span><br><span class="line">       <span class="keyword">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而读取这个sysfs节点的响应函数则很简单了，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">power_attr(autosleep);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">state_show</span><span class="params">(struct kobject *kobj, struct kobj_attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">char</span> *s = buf;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SUSPEND</span></span><br><span class="line">       <span class="keyword">suspend_state_t</span> i;</span><br><span class="line">       <span class="keyword">for</span> (i = PM_SUSPEND_MIN; i &lt; PM_SUSPEND_MAX; i++) <span class="comment">//循环将所有电源管理状态加入到要返回的字符串</span></span><br><span class="line">              <span class="keyword">if</span> (pm_states[i])</span><br><span class="line">                     s += <span class="built_in">sprintf</span>(s,<span class="string">"%s "</span>, pm_states[i]);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       <span class="keyword">if</span> (hibernation_available())</span><br><span class="line">              s += <span class="built_in">sprintf</span>(s, <span class="string">"disk "</span>); <span class="comment">//如果系统支持Hibernate，则将disk加入要返回的字符串</span></span><br><span class="line">       <span class="keyword">if</span> (s != buf)</span><br><span class="line">              *(s-1) = '\\n';</span><br><span class="line">       <span class="keyword">return</span> (s - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sys-power-autosleep"><a href="#sys-power-autosleep" class="headerlink" title="/sys/power/autosleep"></a>/sys/power/autosleep</h2><p>autosleep节点同样定义在kernel/power/main.c，其基本结构与state基本相似。当从用户空间态读取该节点时，返回全局变量autosleep_state的值对应的字符串（”mem”, “standby”, “freeze”或者”disk”）。 而写该节点时，处理与/sys/power/state的处理则稍有不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">autosleep_store</span><span class="params">(struct kobject *kobj,struct kobj_attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">suspend_state_t</span> state = decode_state(buf, n);</span><br><span class="line">       <span class="keyword">int</span> error;</span><br><span class="line">       <span class="keyword">if</span> (state == PM_SUSPEND_ON &amp;&amp; <span class="built_in">strcmp</span>(buf, <span class="string">"off"</span>) &amp;&amp; <span class="built_in">strcmp</span>(buf, <span class="string">"off\\n"</span>))</span><br><span class="line">              <span class="keyword">return</span> -EINVAL;</span><br><span class="line">       error = pm_autosleep_set_state(state); <span class="comment">//将suspend_state_t类型的状态传入供处理</span></span><br><span class="line">       <span class="keyword">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pm_autosleep_set_state</span><span class="params">(<span class="keyword">suspend_state_t</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       __pm_stay_awake(autosleep_ws);  <span class="comment">// 避免系统进入休眠状态（这里传入全局变量，autosleep_ws，表明是autosleep wakeup source）</span></span><br><span class="line">       mutex_lock(&amp;autosleep_lock);</span><br><span class="line">       autosleep_state = state;         <span class="comment">// 将传入的状态赋值给全局变量autosleep_state</span></span><br><span class="line">       __pm_relax(autosleep_ws);       <span class="comment">// 释放休眠锁</span></span><br><span class="line">       <span class="keyword">if</span> (state &gt; PM_SUSPEND_ON) &#123;</span><br><span class="line">              pm_wakep_autosleep_enabled(<span class="literal">true</span>); <span class="comment">//对系统中注册的所有wakeup source，均设置其中的autosleep成员为true，并更新start_prevent_time</span></span><br><span class="line">              queue_up_suspend_work(); <span class="comment">//将autosleep例程加入到kernel的workqueue进行调度</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              pm_wakep_autosleep_enabled(<span class="literal">false</span>); <span class="comment">//对系统中注册的所有wakeup source，均设置其中的autosleep成员为false</span></span><br><span class="line">       &#125;</span><br><span class="line">       mutex_unlock(&amp;autosleep_lock);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sys-power-wake-lock-amp-wake-unlock"><a href="#sys-power-wake-lock-amp-wake-unlock" class="headerlink" title="/sys/power/wake_lock &amp; wake_unlock"></a>/sys/power/wake_lock &amp; wake_unlock</h2><p>wake_lock和wake_unlock为用户空间态拿睡眠锁与释放睡眠锁的节点。不出意料，它们还是定义在kernel/power/main.c。Kernel对这两个节点的读取处理几乎一致，以wake_lock的读取为例，对它的读取打印系统中所有激活的wakeup source。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">wake_lock_show</span><span class="params">(struct kobject *kobj,struct kobj_attribute *attr,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pm_show_wakelocks(buf, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当从用户空间态写这两个节点时，内核处理则不相同。写wake_lock和wake_unlock的处理分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">wake_lock_store</span><span class="params">(struct kobject *kobj,struct kobj_attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> error = pm_wake_lock(buf); <span class="comment">//buf内为拿休眠锁的wakeup_source的名字，将该wakeup_source注册到内核中</span></span><br><span class="line">       <span class="keyword">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">wake_unlock_store</span><span class="params">(struct kobject *kobj,struct kobj_attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> error = pm_wake_unlock(buf); <span class="comment">//buf内为释放休眠锁的wakeup_source的名字，告诉内核释放该wakeup_source拿的休眠锁</span></span><br><span class="line">       <span class="keyword">return</span> error ? error : n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Autosleep代码分析"><a href="#Autosleep代码分析" class="headerlink" title="Autosleep代码分析"></a>Autosleep代码分析</h1><p>Autosleep其实为一个内核的一个workqueue，其定义在kernel/power/autosleep.c，核心处理函数为try_to_suspend。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DECLARE_WORK</span><span class="params">(suspend_work, try_to_suspend)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">try_to_suspend</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">int</span> initial_count, final_count;</span><br><span class="line">       <span class="keyword">if</span> (!pm_get_wakeup_count(&amp;initial_count, <span class="literal">true</span>))</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">       mutex_lock(&amp;autosleep_lock);</span><br><span class="line">       <span class="keyword">if</span> (!pm_save_wakeup_count(initial_count) ||</span><br><span class="line">              system_state != SYSTEM_RUNNING) &#123;</span><br><span class="line">              mutex_unlock(&amp;autosleep_lock);</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (autosleep_state == PM_SUSPEND_ON) &#123;</span><br><span class="line">              mutex_unlock(&amp;autosleep_lock);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (autosleep_state &gt;= PM_SUSPEND_MAX)</span><br><span class="line">              hibernate();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">              pm_suspend(autosleep_state);</span><br><span class="line"></span><br><span class="line">       mutex_unlock(&amp;autosleep_lock);</span><br><span class="line">       <span class="keyword">if</span> (!pm_get_wakeup_count(&amp;final_count, <span class="literal">false</span>))</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If the wakeup occured for an unknown reason, wait to prevent the</span></span><br><span class="line"><span class="comment">        * system from trying to suspend and waking up in a tight loop.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (final_count == initial_count)</span><br><span class="line">              schedule_timeout_uninterruptible(HZ / <span class="number">2</span>);</span><br><span class="line"> out:</span><br><span class="line">       queue_up_suspend_work();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第5,6行(pm_get_wakeup_count)</strong>，读取wakeup source的总数到initial_count供函数后续使用。同时判断若当前激活的wakeup source的数量大于0（表示有人持锁），则跳出函数执行。 <strong>第8-12行(pm_save_wakeup_count)</strong>，再次检查，如果执行期间wakeup source数量有变化、或者持锁的wakeup source数量大于0，或者当前系统已经不在休眠状态，则跳出执行。 <strong>第13-16行(autosleep_state == PM_SUSPEND_ON)</strong>，若自动休眠状态的等级为非休眠，则跳出执行。 <strong>第17-20行</strong>，进入到系统休眠。 <strong>第22-31行</strong>，从休眠跳出后，马上检查系统的wakeup_source数量。若wakeup_source总数量没有变化，会让出该线程执行，让内核重新调度。从注释的解释分析，这里的作用主要是因为从休眠中跳出，但是没有新的wakeup source产生，为了避免系统再次进入到休眠。所以让出系统调度，让造成休眠跳出的系统模块得以注册新的wakeup source。 <strong>第33行</strong>，将try_to_suspend加入workqueue，等待下次调度。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux电源管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>电源管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux內存初始化过程(ZZ)</title>
    <url>/p/d209b5b5.html</url>
    <content><![CDATA[<blockquote>
<p>Linux内存管理是个庞大的课题，让多少工程师本文为之困惑。本文为对Linux内存初始化解释的比较清楚的一篇文章，转载自<a href="https://hk.saowen.com/a/da28ac89eda5566fe54a26448a47988ceb73ee7ed141e8956c780bc132ed5881" target="_blank" rel="noopener">Link</a>，欢迎交流</p>
</blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直以来，我都非常着迷于两种电影拍摄手法：一种是慢镜头，将每一个细节全方位的展现给观众。另外一种就是快镜头，多半是反应一个时代的变迁，从非常长的时间段中，截取几个典型的snapshot，合成在十几秒的镜头中，可以让观众很快的了解一个事物的发展脉络。对应到技术层面，慢镜头有点类似情景分析，把每一行代码都详细的进行解析，了解技术的细节。快镜头类似数据流分析，勾勒一个过程中，数据结构的演化。本文采用了快镜头的方法，对内存初始化部分进行描述，不纠缠于具体函数的代码实现，只是希望能给大家一个概略性的印象（有兴趣的同学可以自行研究代码）。BTW，在本文中我们都是基于ARM64来描述体系结构相关的内容。</p><a id="more"></a>

<h2 id="启动之前"><a href="#启动之前" class="headerlink" title="启动之前"></a>启动之前</h2><p>在详细描述linux kernel对内存的初始化过程之前，我们必须首先了解kernel在执行第一条语句之前所面临的处境。这时候的内存状况可以参考下图：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/46d41476331680.gif" alt="http://www.wowotech.net/content/uploadfile/201610/46d41476331680.gif"></p>
<p>bootloader有自己的方法来了解系统中memory的布局，然后，它会将绿色的kernel image和蓝色dtb image copy到了指定的内存位置上。</p>
<p>kernel image最好是位于main memory起始地址偏移TEXT_OFFSET的位置，当然，TEXT_OFFSET需要和kernel协商好。</p>
<p>kernel image是否一定位于起始的main memory（memory address最低）呢？也不一定，但是对于kernel而言，低于kernel image的内存，kernel是不会纳入到自己的内存管理系统中的。对于dtb image的位置，linux并没有特别的要求。由于这时候MMU是turn off的，因此CPU只能看到物理地址空间。对于cache的要求也比较简单，只有一条：kernel image对应的cache必须clean to PoC，即系统中所有的observer在访问kernel image对应内存地址的时候是一致性的。</p>
<h2 id="汇编时代"><a href="#汇编时代" class="headerlink" title="汇编时代"></a>汇编时代</h2><p>一旦跳转到linux kernel执行，内核则完全掌控了内存系统的控制权，它需要做的事情首先就是要打开MMU，而为了打开MMU，必须要创建linux kernel正常运行需要的页表，这就是本节的主要内容。</p>
<p>在体系结构相关的汇编初始化阶段，我们会准备二段地址的页表：一段是identity mapping，其实就是把地址等于物理地址的那些虚拟地址mapping到物理地址上去，打开MMU相关的代码需要这样的mapping（别的CPU不知道，但是ARM ARCH强烈推荐这么做的）。第二段是kernel image mapping，内核代码欢快的执行当然需要将kernel running需要的地址（kernel txt、rodata、data、bss等等）进行映射了。具体的映射情况可以参考下图：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/95491476331682.gif" alt="http://www.wowotech.net/content/uploadfile/201610/95491476331682.gif"></p>
<p>turn on MMU相关的代码被放入到一个特别的section，名字是.idmap.text，实际上对应上图中物理地址空间的IDMAP_TEXT这个block。这个区域的代码被mapping了两次，做为kernel image的一部分，它被映像到了__idmap_text_start开始的虚拟地址上去，此外，假设IDMAP_TEXT block的物理地址是A地址，那么它还被映像到了A地址开始的虚拟地址上去。虽然上图中表示的A地址似乎要大于PAGE_OFFSET，不过实际上不一定需要这样的关系，这和具体处理器的实现有关。</p>
<p>编译程序感知的是kernel image的虚拟地址（左侧），在内核的链接脚本中定义了若干的符号，都是虚拟地址。但是在内核刚开始，没有打开MMU之前，这些代码实际上是运行在物理地址上的，因此，内核起始刚开始的汇编代码基本上是PIC的，首先需要定位到页表的位置，然后在页表中填入kernel image mapping和identity mapping的页表项。页表的起始位置比较好定（bss段之后），但是具体的size还是需要思考一下的。我们要选择一个合适的size，确保能够覆盖kernel image mapping和identity mapping的地址段，然后又不会太浪费。我们以kernel image mapping为例，描述确定Tranlation table size的思考过程。假设48 bit的虚拟地址配置，4k的page size，这时候需要4级映像，地址被分成9（level 0 or PGD） ＋ 9（level 1 or PUD） ＋ 9（level 2 or PMD） ＋ 9（level 3 or PTE） ＋ 12（page offset），假设我们分配4个page分别保存Level 0到level 3的translation table，那么可以创建的最大的地址映像范围是512（level 3中有512个entry） X 4k ＝ 2M。2M这个size当然不理想，无法容纳kernel image的地址区域，怎么办？使用section mapping，让PMD执行block descriptor，这样使用3个page就可以mapping 512 X 2M ＝ 1G的地址空间范围。当然，这种方法有一点副作用就是：PAGE_OFFSET必须2M对齐。对于16K或者64K的page size，使用section mapping就有点不合适了，因为这时候对齐的要求太高了，对于16K page size，需要32M对齐，对于64K page size，需要512M对齐。不过，这也没有什么，毕竟这时候page size也变大了，不使用section mapping也能覆盖很大区域。例如，对于16K page size，一个16K page size中可以保存2K个entry，因此能够覆盖2K X 16K ＝ 32M的地址范围。对于64K page size，一个64K page size中可以保存8K个entry，因此能够覆盖8K X 64K ＝ 512M的地址范围。32M和512M基本是可以满足需求的。最后的结论：swapper进程（内核空间）需要预留页表的size是和page table level相关，如果使用了section mapping，那么需要预留PGTABLE_LEVELS - 1个page。如果不使用section mapping，那么需要预留PGTABLE_LEVELS 个page。</p>
<p>上面的结论起始是适合大部分情况下的identity mapping，但是还是有特例（需要考虑的点主要和其物理地址的位置相关）。我们假设这样的一个配置：虚拟地址配置为39bit，而物理地址是48个bit，同时，IDMAP_TEXT这个block的地址位于高端地址（大于39 bit能表示的范围）。在这种情况下，上面的结论失效了，因为PGTABLE_LEVELS 是和虚拟地址的bit数、PAGE_SIZE的定义相关，而是和物理地址的配置无关。linux kernel使用了巧妙的方法解决了这个问题，大家可以自己看代码理解，这里就不多说了。</p>
<p>一旦设定完了页表，那么打开MMU之后，kernel正式就会进入虚拟地址空间的世界，美中不足的是内核的虚拟世界没有那么大。原来拥有的整个物理地址空间都消失了，能看到的仅仅剩下kernel image mapping和identity mapping这两段地址空间是可见的。不过没有关系，这只是刚开始，内存初始化之路还很长。</p>
<h2 id="看见DTB"><a href="#看见DTB" class="headerlink" title="看见DTB"></a>看见DTB</h2><p>虽然可以通过kernel image mapping和identity mapping来窥探物理地址空间，但终究是管中窥豹，不了解全局，那么内核是如何了解对端的物理世界呢？答案就是DTB，但是问题来了，这时候，内核还没有为DTB这段内存创建映射，因此，打开MMU之后的kernel还不能直接访问，需要先创建dtb mapping，而要创建address mapping，就需要分配页表内存，而这时候，还没有了解内存布局，内存管理模块还没有初始化，如何来分配内存呢？</p>
<p>下面这张图片给出了解决方案：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/d2921476331683.gif" alt="http://www.wowotech.net/content/uploadfile/201610/d2921476331683.gif"></p>
<p>整个虚拟地址空间那么大，可以被平均分成两半，上半部分的虚拟地址空间主要各种特定的功能，而下半部分主要用于物理内存的直接映像。对于DTB而言，我们借用了fixed-mapped address这个概念。fixed map是被linux kernel用来解决一类问题的机制，这类问题的共同特点是：（1）在很早期的阶段需要进行地址映像，而此时，由于内存管理模块还没有完成初始化，不能动态分配内存，也就是无法动态分配创建映像需要的页表内存空间。（2）物理地址是固定的，或者是在运行时就可以确定的。对于这类问题，内核定义了一段固定映像的虚拟地址，让使用fix map机制的各个模块可以在系统启动的早期就可以创建地址映像，当然，这种机制不是那么灵活，因为虚拟地址都是编译时固定分配的。</p>
<p>好，我们可以考虑创建第三段地址映像了，当然，要创建地址映像就要创建各个level中描述符。对于fixed-mapped address这段虚拟地址空间，由于也是位于内核空间，因此PGD当然就是复用swapper进程的PGD了（其实整个系统就一个PGD），而其他level的Translation table则是静态定义的（arch/arm64/mm/mmu.c），位于内核bss段，由于所有的Translation table都在kernel image mapping的范围内，因此内核可以毫无压力的访问，并创建fixed-mapped address这段虚拟地址空间对应的PUD、PMD和PTE的entry。所有中间level的Translation table都是在early_fixmap_init函数中完成初始化的，最后一个level则是在各个具体的模块进行的，对于DTB而言，这发生在fixmap_remap_fdt函数中。</p>
<p>系统对dtb的size有要求，不能大于2M，这个要求主要是要确保在创建地址映像（create_mapping）的时候不能分配其他的translation table page，也就是说，所有的translation table都必须静态定义。为什么呢？因为这时候内存管理模块还没有初始化，即便是memblock模块（初始化阶段分配内存的模块）都尚未初始化（没有内存布局的信息），不能动态分配内存。</p>
<h2 id="early-ioremap"><a href="#early-ioremap" class="headerlink" title="early ioremap"></a>early ioremap</h2><p>除了DTB，在启动阶段，还有其他的模块也想要创建地址映像，当然，对于这些需求，内核统一采用了fixmap的机制来应对，fixmap的具体信息如下图所示：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/5c8f1476331684.gif" alt="http://www.wowotech.net/content/uploadfile/201610/5c8f1476331684.gif"></p>
<p>从上面这个图片可以看出fix-mapped虚拟地址分成两段，一段是permanent fix map，一段是temporary fixmap。所谓permanent表示映射关系永远都是存在的，例如FDT区域，一旦完成地址映像，内核可以访问DTB之后，这个映射关系一直都是存在的。而temporary fixmap则不然，一般而言，某个模块使用了这部分的虚拟地址之后，需要尽快释放这段虚拟地址，以便给其他模块使用。</p>
<p>你可能会很奇怪，因为传统的驱动模块中，大家通常使用ioremap函数来完成地址映像，为了还有一个early IO remap呢？其实ioremap函数的使用需要一定的前提条件的，在地址映像过程中，如果某个level的Translation tabe不存在，那么该函数需要调用伙伴系统模块的接口来分配一个page size的内存来创建某个level的Translation table，但是在启动阶段，内存管理的伙伴系统还没有ready，其实这时候，内核连系统中有多少内存都不知道的。而early io remap则在early_ioremap_init之后就可以被使用了。更具体的信息请参考mm/early_ioremap.c文檔。</p>
<p>结论：如果想要在伙伴系统初始化之前进行设备寄存器的访问，那么可以考虑early IO remap机制。</p>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>完成DTB的映射之后，内核可以访问这一段的内存了，通过解析DTB中的内容，内核可以勾勒出整个内存布局的情况，为后续内存管理初始化奠定基础。收集内存布局的信息主要来自下面几条途径：</p>
<ul>
<li>（1）choosen node。该节点有一个bootargs属性，该属性定义了内核的启动参数，而在启动参数中，可能包括了mem=nn[KMG]这样的参数项。initrd-start和initrd-end参数定义了initial ramdisk image的物理地址范围。</li>
<li>（2）memory node。这个节点主要定义了系统中的物理内存布局。主要的布局信息是通过reg属性来定义的，该属性定义了若干的起始地址和size条目。</li>
<li>（3）DTB header中的memreserve域。对于dts而言，这个域是定义在root node之外的一行字符串，例如：/memreserve/ 0x05e00000 0x00100000;，memreserve之后的两个值分别定义了起始地址和size。对于dtb而言，memreserve这个字符串被DTC解析并称为DTB header中的一部分。更具体的信息可以参考<a href="https://hk.saowen.com/rd/aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvZGV2aWNlX21vZGVsL2R0X2Jhc2ljX2NvbmNlcHQuaHRtbA==" target="_blank" rel="noopener">device tree基础</a>文文件，了解DTB的结构。</li>
<li>（4）reserved-memory node。这个节点及其子节点定义了系统中保留的内存地址区域。保留内存有两种，一种是静态定义的，用reg属性定义的address和size。另外一种是动态定义的，只是通过size属性定义了保留内存区域的长度，或者通过alignment属性定义对齐属性，动态定义类型的子节点的属性不能精准的定义出保留内存区域的起始地址和长度。在创建地址映像方面，可以通过no-map属性来控制保留内存区域的地址映像关系的创建。更具体的信息可以阅读参考文献[1]。</li>
</ul>
<p>通过对DTB中上述信息的解析，其实内核已经基本对内存布局有数了，但是如何来管理这些信息呢？这也就是著名的memblock模块，主要负责在初始化阶段用来管理物理内存。一个参考性的示意图如下：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/47b01476331686.gif" alt="http://www.wowotech.net/content/uploadfile/201610/47b01476331686.gif"></p>
<p>内核在收集了若干和memory相关的信息后，会调用memblock模块的接口API（例如：memblock_add、memblock_reserve、memblock_remove等）来管理这些内存布局的信息。内核需要动态管理起来的内存资源被保存在memblock的memory type的数组中（上图中的绿色block，按照地址的大小顺序排列），而那些需要预留的，不需要内核管理的内存被保存在memblock的reserved type的数组中（上图中的青色block，也是按照地址的大小顺序排列）。要想了解进一步的信息，请参考内核代码中的setup_machine_fdt和arm64_memblock_init这两个函数的实现。</p>
<h2 id="看到内存"><a href="#看到内存" class="headerlink" title="看到内存"></a>看到内存</h2><p>了解到了当前的物理内存的布局，但是内核仍然只是能够访问部分内存（kernel image mapping和DTB那两段内存，上图中黄色block），大部分的内存仍然处于黑暗中，等待光明的到来，也就是说需要创建这些内存的地址映像。</p>
<p>在这个时间点上，创建内存的地址映像有一个悖论：创建地址映像需要分配内存，但是这时候伙伴系统没有ready，无法动态分配。也许你会说，memblock不是已经ready了吗，不可以调用memblock_alloc进行物理内存的分配吗？当然可以，memblock_alloc分配的物理内存仍然需要通过虚拟地址访问，而这些内存都还没有创建地址映像，因此内核一旦访问memblock_alloc分配的物理内存，悲剧就会发生了。</p>
<p>怎么办呢？内核采用了一个巧妙的办法：那就是控制创建地址映像，memblock_alloc分配页表内存的顺序。也就是说刚开始的时候创建的地址映像不需要页表内存的分配，当内核需要调用memblock_alloc进行页表物理地址分配的时候，很多已经创建映像的内存已经ready了，这样，在调用create_mapping的时候不需要分配页表内存。更具体的解释参考下面的图片：</p>
<p><img src="http://www.wowotech.net/content/uploadfile/201610/634b1476331687.gif" alt="http://www.wowotech.net/content/uploadfile/201610/634b1476331687.gif"></p>
<p>我们知道，在内核编译的时候，在BSS段之后分配了几个page用于swapper进程地址空间（内核空间）的映射，当然，由于kernel image不需要mapping那么多的地址，因此swapper进程translation table的最后一个level中的entry不会全部的填充完毕。换句话说：swapper进程页表可以支持远远大于kernel image mapping那一段的地址区域，实际上，它可以支持的地址段的size是SWAPPER_INIT_MAP_SIZE。为（PAGE_OFFSET，PAGE_OFFSET＋SWAPPER_INIT_MAP_SIZE）这段虚拟内存创建地址映像，mapping到（PHYS_OFFSET，PHYS_OFFSET＋SWAPPER_INIT_MAP_SIZE）这段物理内存的时候，调用create_mapping不会发生内存分配，因为所有的页表都已经存在了，不需要动态分配。</p>
<p>一旦完成了（PHYS_OFFSET，PHYS_OFFSET＋SWAPPER_INIT_MAP_SIZE）这段物理内存的地址映像，这时候，终于可以自由使用memblock_alloc进行内存分配了，当然，要进行限制，确保分配的内存位于（PHYS_OFFSET，PHYS_OFFSET＋SWAPPER_INIT_MAP_SIZE）这段物理内存中。完成所有memory type类型的memory region的地址映像之后，可以解除限制，任意分配memory了。而这时候，所有memory type的地址区域（上上图中绿色block）都已经可见，而这些宝贵的内存资源就是内存管理模块需要管理的对象。具体代码请参考paging_init—&gt;map_mem函数的实现。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>目前为止，所有为内存管理做的准备工作已经完成：收集了整个内存布局的信息，memblock模块中已经保存了所有需要管理memory region的信息，同时，系统也为所有的内存（reserved除外）创建了地址映像。虽然整个内存管理系统没有ready，但是通过memblock模块已经可以在随后的初始化过程中进行动态内存的分配。 有了这些基础，随后就是真正的内存管理系统的初始化了，我们下回分解。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>1、Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</li>
<li>2、linux4.4.6内核代码</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Memory</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux MTD子系统</title>
    <url>/p/97cebc38.html</url>
    <content><![CDATA[<h3 id="为什么需要MTD子系统"><a href="#为什么需要MTD子系统" class="headerlink" title="为什么需要MTD子系统"></a>为什么需要MTD子系统</h3><p>嵌入式系统使用Flash作为存储设备，Flash类别有Nand、Nor等。Flash的上层是文件系统。直觉上，系统中使用这些Flash时，我们需要为每种Flash编写驱动。同时在调用Flash的文件系统做接口对接。这样，每使用一种新的Flash类型甚至型号，都得修改文件系统的编码来做适配。显然，这会造成代码的爆炸，同时也不方便大家各司其职（例如：厂商A做Flash，添加一个新的Flash需要厂商A的驱动开发人员去改写所有文件系统的接口，这显然不现实）。</p><a id="more"></a>
<p>几乎所有的现代操作系统都不会允许以上事情的发生。通用的做法是，抽象出上下层对接的方式，厂商驱动开发人员只需要按照接口进行匹配节课。</p>
<p>MTD（Memory Technology Devices）便是Linux系统下处理以上问题的方式。</p>
<h3 id="架构与代码目录"><a href="#架构与代码目录" class="headerlink" title="架构与代码目录"></a>架构与代码目录</h3><p>MTD在系统中的结构如下图。</p>
<ul>
<li>构成MTD的部分有MTD核心、MTD字符设备和MTD块设备层。成为文件系统和底层硬件驱动的沟通桥梁</li>
<li>MTD核心建立在Flash驱动（位于drivers/mtd/）之上，为Flash驱动提供一系列的API抽象</li>
<li>MTD为上层提供统一的操作抽象接口如<code>dev/mtd0</code>, <code>/dev/mtd1</code>（例如擦除、读写等），同时提供 <code>/proc/mtd</code>供上层读取MTD系统相关信息</li>
<li>MTD提供一系列的API，为基于Flash的文件系统提供控制操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   +-----------------+</span><br><span class="line">  | 使用文件系统的应用 |</span><br><span class="line">   +-----------------+</span><br><span class="line">   +------------+ +------------+</span><br><span class="line">   |Char Dev节点 | |Block Dev节点| 用户空间层</span><br><span class="line">   +------------+ +------------+</span><br><span class="line">+---------------------------------+</span><br><span class="line">   +---------------+-----------+</span><br><span class="line">   |  MTD字 符 设 备| MTD块 设 备|</span><br><span class="line">   +---------------+-----------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |      MTD Core             | 内核层</span><br><span class="line">   +---------------------------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |       Flash驱 动           |</span><br><span class="line">   +---------------------------+</span><br><span class="line">+---------------------------------+</span><br><span class="line">   +---------------------------+</span><br><span class="line">   |       各 种 Flash          | 硬件层</span><br><span class="line">   +---------------------------+</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>MTD代码在Linux内核源码树的位置：</p>
<ul>
<li>_include/linux/mtd/_：定义所有MTD相关头文件</li>
<li><em>drivers/mtd</em>: 定义MTD核心，以及Flash驱动</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>MTD的核心结构定义在内核源码树的_include/linux/mtd/mtd.h_。先看核心数据结构mtd_info：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> &#123;</span></span><br><span class="line">	u_char type;</span><br><span class="line">	<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	<span class="keyword">uint64_t</span> <span class="built_in">size</span>;	 <span class="comment">// MTD总大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> erasesize; <span class="comment">//擦除大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> writesize; <span class="comment">//最小写单位</span></span><br><span class="line">	<span class="keyword">uint32_t</span> writebufsize; <span class="comment">//写缓冲大小，提升写效率</span></span><br><span class="line">	<span class="keyword">uint32_t</span> oobsize;   <span class="comment">// 每个Flash 块的OOB数量</span></span><br><span class="line">	<span class="keyword">uint32_t</span> oobavail;  <span class="comment">// 每个Flash块的OOB大小</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_shift;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_shift;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> erasesize_mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writesize_mask; <span class="comment">//shift和mask在Linux源码中常见，主要用于MTD大小相关的位运算</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> bitflip_threshold; <span class="comment">//位翻转阈值，即最大允许位翻转个数，超出后，读写返回“-EUCLEAN”</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//MTD名称</span></span><br><span class="line">	<span class="keyword">int</span> index;  <span class="comment">//MTD索引</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_ooblayout_ops</span> *<span class="title">ooblayout</span>;</span> <span class="comment">//OOB layout操作</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_pairing_scheme</span> *<span class="title">pairing</span>;</span><span class="comment">//MLC/TLC NANDs Flash 颗粒的配对策略</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_step_size; <span class="comment">//ecc步长</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ecc_strength; <span class="comment">//ecc最大可纠正错误bit数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> numeraseregions;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_erase_region_info</span> *<span class="title">eraseregions</span>;</span> <span class="comment">//擦除区域信息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//以下为Flash操作的回调函数，不同flash有不同实现</span></span><br><span class="line">	<span class="keyword">int</span> (*_erase) (struct mtd_info *mtd, struct erase_info *instr);</span><br><span class="line">	<span class="keyword">int</span> (*_point) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">void</span> **virt, <span class="keyword">resource_size_t</span> *phys);</span><br><span class="line">	<span class="keyword">int</span> (*_unpoint) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*_get_unmapped_area)</span> <span class="params">(struct mtd_info *mtd,</span></span></span><br><span class="line"><span class="function"><span class="params">					     <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">					     <span class="keyword">unsigned</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">					     <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*_read) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len,</span><br><span class="line">		      <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len,</span><br><span class="line">		       <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_panic_write) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, <span class="keyword">const</span> u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_read_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,</span><br><span class="line">			  struct mtd_oob_ops *ops);</span><br><span class="line">	<span class="keyword">int</span> (*_write_oob) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to,</span><br><span class="line">			   struct mtd_oob_ops *ops);</span><br><span class="line">	<span class="keyword">int</span> (*_get_fact_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_read_fact_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_get_user_prot_info) (struct mtd_info *mtd, <span class="keyword">size_t</span> len,  <span class="keyword">size_t</span> *retlen, struct otp_info *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_read_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_write_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *retlen, u_char *buf);</span><br><span class="line">	<span class="keyword">int</span> (*_lock_user_prot_reg) (struct mtd_info *mtd, <span class="keyword">loff_t</span> from,  <span class="keyword">size_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_writev) (struct mtd_info *mtd, <span class="keyword">const</span> struct kvec *vecs, <span class="keyword">unsigned</span> <span class="keyword">long</span> count, <span class="keyword">loff_t</span> to, <span class="keyword">size_t</span> *retlen);</span><br><span class="line">	<span class="keyword">void</span> (*_sync) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">int</span> (*_lock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_unlock) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_is_locked) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs, <span class="keyword">uint64_t</span> len);</span><br><span class="line">	<span class="keyword">int</span> (*_block_isreserved) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line">	<span class="keyword">int</span> (*_block_isbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line">	<span class="keyword">int</span> (*_block_markbad) (struct mtd_info *mtd, <span class="keyword">loff_t</span> ofs);</span><br><span class="line">	<span class="keyword">int</span> (*_suspend) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">void</span> (*_resume) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">void</span> (*_reboot) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">int</span> (*_get_device) (struct mtd_info *mtd);</span><br><span class="line">	<span class="keyword">void</span> (*_put_device) (struct mtd_info *mtd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">reboot_notifier</span>;</span>  <span class="comment">//重启通知</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_ecc_stats</span> <span class="title">ecc_stats</span>;</span> <span class="comment">//ECC统计数据</span></span><br><span class="line">	<span class="keyword">int</span> subpage_sft;</span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="keyword">int</span> usecount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外一个比较重要的数据结构为mtd_partition，顾名思义，对一块flash进行分区:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//分区名称</span></span><br><span class="line">	<span class="keyword">uint64_t</span> <span class="built_in">size</span>;	<span class="comment">//大小</span></span><br><span class="line">	<span class="keyword">uint64_t</span> offset; <span class="comment">//在MTD设备的偏移</span></span><br><span class="line">	<span class="keyword">uint32_t</span> mask_flags; <span class="comment">//MTD主设备的掩码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常每种类型的Flash芯片定义了这样一个数据结构，用于对Flash进行操作。可参考drivers/mtd/devices下相关使用（例如lpddr2_nvm.c）</p>
<p>mtdcore.h/mtdcore.c下定义了一系列使用MTD设备的API：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *__<span class="title">mtd_next_device</span>(<span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注册MTD设备</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_device</span><span class="params">(struct mtd_info *mtd)</span></span>; <span class="comment">//注销</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *, <span class="keyword">const</span> struct mtd_partition *, <span class="keyword">int</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_mtd_partitions</span><span class="params">(struct mtd_info *)</span></span>; <span class="comment">//添加、删除MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span>; <span class="comment">//从MTD设备查找MTD分区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mtd_part_parser_cleanup</span><span class="params">(struct mtd_partitions *parts)</span></span>;<span class="comment">//清除parse_mtd_partitions得到的MTD分区数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">init_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __exit <span class="title">cleanup_mtdchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//注册、清除MTD字符设备</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_mtd_user</span> <span class="params">(struct mtd_notifier *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unregister_mtd_user</span> <span class="params">(struct mtd_notifier *old)</span> <span class="comment">//注册、去注册MTD使用者（当有MTD变动时通知）</span></span></span><br></pre></td></tr></table></figure>

<h3 id="MTD字符设备"><a href="#MTD字符设备" class="headerlink" title="MTD字符设备"></a>MTD字符设备</h3><p>MTD字符设备定义在mtdchar.c，其中定义了字符设备的相关操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mtd_fops</span> = &#123;</span></span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.llseek		= mtdchar_lseek,</span><br><span class="line">	.<span class="built_in">read</span>		= mtdchar_read,</span><br><span class="line">	.<span class="built_in">write</span>		= mtdchar_write,</span><br><span class="line">	.unlocked_ioctl	= mtdchar_unlocked_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	.compat_ioctl	= mtdchar_compat_ioctl,</span><br><span class="line">#endif</span><br><span class="line">	.<span class="built_in">open</span>		= mtdchar_open,</span><br><span class="line">	.<span class="built_in">release</span>	= mtdchar_close,</span><br><span class="line">	.mmap		= mtdchar_mmap,</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">	.get_unmapped_area = mtdchar_get_unmapped_area,</span><br><span class="line">	.mmap_capabilities = mtdchar_mmap_capabilities,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="MTD块设备"><a href="#MTD块设备" class="headerlink" title="MTD块设备"></a>MTD块设备</h3><p>MTD块设备定义在mtdblock.c/mtdblock_ro.c，定义了块设备相关操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">"mtdblock"</span>,</span><br><span class="line">	.major		= MTD_BLOCK_MAJOR,</span><br><span class="line">	.part_bits	= <span class="number">0</span>,</span><br><span class="line">	.blksize 	= <span class="number">512</span>,</span><br><span class="line">	.<span class="built_in">open</span>		= mtdblock_open,</span><br><span class="line">	.<span class="built_in">flush</span>		= mtdblock_flush,</span><br><span class="line">	.<span class="built_in">release</span>	= mtdblock_release,</span><br><span class="line">	.readsect	= mtdblock_readsect,</span><br><span class="line">	.writesect	= mtdblock_writesect,</span><br><span class="line">	.add_mtd	= mtdblock_add_mtd,</span><br><span class="line">	.remove_dev	= mtdblock_remove_dev,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span> = &#123;</span></span><br><span class="line">	.name		= <span class="string">"mtdblock"</span>,</span><br><span class="line">	.major		= MTD_BLOCK_MAJOR,</span><br><span class="line">	.part_bits	= <span class="number">0</span>,</span><br><span class="line">	.blksize 	= <span class="number">512</span>,</span><br><span class="line">	.readsect	= mtdblock_readsect,</span><br><span class="line">	.writesect	= mtdblock_writesect,</span><br><span class="line">	.add_mtd	= mtdblock_add_mtd,</span><br><span class="line">	.remove_dev	= mtdblock_remove_dev,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>在嵌入式设备，一个flash往往会被划分做不同的功能分区。例如，升级分区、文件系统分区、bootloader分区、配置分区、备份分区等等。代码树中的drivers/mtd/mtdpart.c实现了分区的相关操作：</p>
<p>以下全局变量定义了MTD分区的链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(mtd_partitions)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(mtd_partitions_mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>链表元素为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtd_part</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> <span class="title">mtd</span>;</span>      <span class="comment">//MTD信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">master</span>;</span>  <span class="comment">//MTD 设备指针</span></span><br><span class="line">	<span class="keyword">uint64_t</span> offset;          <span class="comment">//主设备偏移</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关操作为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct mtd_part *<span class="title">allocate_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *part, <span class="keyword">int</span> partno, <span class="keyword">uint64_t</span> cur_offset)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分配分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mtd_add_partition_attrs</span><span class="params">(struct mtd_part *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_add_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">long</span> <span class="keyword">long</span> offset, <span class="keyword">long</span> <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mtd_del_partition</span><span class="params">(struct mtd_info *master, <span class="keyword">int</span> partno)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加删除分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> struct mtd_partition *parts, <span class="keyword">int</span> nbparts)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据分区表添加分区</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __<span class="title">register_mtd_parser</span><span class="params">(struct mtd_part_parser *p, struct <span class="keyword">module</span> *owner)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregister_mtd_parser</span><span class="params">(struct mtd_part_parser *p)</span></span></span><br><span class="line"><span class="function"><span class="comment">//向内核注册和去注册回调函数用于MTD分区时执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_mtd_partitions</span><span class="params">(struct mtd_info *master, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> *types, struct mtd_partitions *pparts, struct mtd_part_parser_data *data)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li>《<a href="http://www.linux-mtd.infradead.org/doc/general.html" target="_blank" rel="noopener">General MTD documentation</a>》</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MTD</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/p/3a046ccf.html</url>
    <content><![CDATA[<p>回顾下操作系统概念：现代计算机往往都是“同时”运行多个任务。系统若只有一个处理器，那么给定时刻只可能有一个任务在执行。而操作系统通过进程管理和调度，切换正在执行的任务，是用户在感官上认为计算机是并行执行多个任务。当然，若是多处理器系统，真正同时执行的任务可以达到处理器的数目。</p><p>内核进行进程管理的主要解决的问题：</p><a id="more"></a>

<ul>
<li>任务有轻重缓急之分，需要可以根据任务的紧急程度给予任务不同的执行优先级和时间。同时尽可能保证任务执行的公平性。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在Linux系统中，我们所讲的任务即进程。进程调度，就是根据当前系统的运行状况，对进程状态的切换。</p>
<p>Linux中进程主要有如下状态：</p>
<ul>
<li><strong>运行</strong>：该进程此刻正在执行。</li>
<li><strong>等待</strong>：进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。</li>
<li><strong>睡眠</strong>：进程正在睡眠无法运行，因为它在等待一个外部事件（或某种资源）。调度器无法在下一次任务切换时选择该进程。</li>
</ul>
<p>以上状态可以相互转换（等待–&gt;睡眠转换除外），转换的条件主要有：</p>
<ul>
<li>进程时间片用完或轮转到该进程</li>
<li>进程阻塞等待某种资源/某种资源准备好了</li>
</ul>
<h3 id="进程表示"><a href="#进程表示" class="headerlink" title="进程表示"></a>进程表示</h3><p>进程用task_struct结构体来表示，定义在include/linux/sched.h如下（省略部分成员）。重点结构体成员意义注释在代码中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*进程当前状态，由sched.h中的宏定义TASK_RUNNING~TASK_STATE_MAX表示。</span></span><br><span class="line"><span class="comment"> TASK_RUNNING意味着进程处于可运行状态。这并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件。</span></span><br><span class="line"><span class="comment"> TASK_INTERRUPTIBLE是针对等待某事件或其他资源的睡眠进程设置的。在内核发送信号给该进程表明事件已经发生时，进程状态变为TASK_RUNNING，它只要调度器选中该进程即可恢复执行。</span></span><br><span class="line"><span class="comment"> TASK_UNINTERRUPTIBLE用于因内核指示而停用的睡眠进程。它们不能由外部信号唤醒，只能由内核亲自唤醒。</span></span><br><span class="line"><span class="comment"> TASK_STOPPED表示进程特意停止运行，例如，由调试器暂停。</span></span><br><span class="line"><span class="comment"> TASK_TRACED本来不是进程状态，用于从停止的进程中，将当前被调试的那些（使用ptrace机制）与常规的进程区分开来。</span></span><br><span class="line"><span class="comment"> EXIT_ZOMBIE为僵尸状态，表示进程结束时父进程未调用wait调用的进程</span></span><br><span class="line"><span class="comment"> EXIT_DEAD状态则是指wait系统调用已经发出，而进程完全从系统移除之前的状态。只有多个线程对同一个进程发出wait调用时，该状态才有意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>; <span class="comment">//进程栈指针</span></span><br><span class="line">	<span class="keyword">atomic_t</span> usage; <span class="comment">//进程描述符使用计数，被置为2时，表示进程描述符正在被使用而且其相应的进程处于活动状态</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags; <span class="comment">//进程标志	</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;<span class="comment">//进程调试跟踪相关标记</span></span><br><span class="line">	<span class="keyword">int</span> on_rq; <span class="comment">//CPU可能有多个运行队列，可能会在运行队列中移动。标记表示进程目前在运行队列位置状态。</span></span><br><span class="line">	<span class="keyword">int</span> prio, static_prio, normal_prio;<span class="comment">//静态优先级动态优先级和一般优先级，调度器使用</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority; <span class="comment">//实时进程运行优先级</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span> <span class="comment">//指向进程的调度器(完全公平调度器？实时调度器等)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span> <span class="comment">//调度实体，每个进程就是一个调度实体。调度实体也可以是用户进程组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span> <span class="comment">//实时进程调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_SCHED</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_group</span> *<span class="title">sched_task_group</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span> <span class="title">dl</span>;</span> <span class="comment">//Deadline调度实体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">preempt_notifiers</span>;</span><span class="comment">//存放进程被抢占的通知函数链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> policy; <span class="comment">//调度策略</span></span><br><span class="line">	<span class="keyword">int</span> nr_cpus_allowed; <span class="comment">//允许调度的CPU数量</span></span><br><span class="line">	<span class="keyword">cpumask_t</span> cpus_allowed;<span class="comment">//掩码图表示允许调度的CPU</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span><span class="comment">//进程链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">active_mm</span>;</span><span class="comment">//进程内存管理结构体</span></span><br><span class="line">	u64 vmacache_seqnum;<span class="comment">//虚拟地址区间缓存序列号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vmacache</span>[<span class="title">VMACACHE_SIZE</span>];</span><span class="comment">//虚拟地址区间缓存</span></span><br><span class="line">	<span class="keyword">int</span> exit_state; <span class="comment">//以下记录进程的退出状态信息</span></span><br><span class="line">	<span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">	<span class="comment">/* 调度器相关标记 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sched_migrated:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> :<span class="number">0</span>; <span class="comment">/* force alignment to the next boundary */</span></span><br><span class="line">	<span class="keyword">unsigned</span> in_execve:<span class="number">1</span>; <span class="comment">/* bit to tell LSMs we're in execve */</span></span><br><span class="line">	<span class="keyword">unsigned</span> in_iowait:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(TIF_RESTORE_SIGMASK)</span></span><br><span class="line">	<span class="keyword">unsigned</span> restore_sigmask:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">unsigned</span> memcg_may_oom:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">	<span class="keyword">unsigned</span> memcg_kmem_skip_account:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="keyword">unsigned</span> brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span> <span class="title">restart_block</span>;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid; <span class="comment">//进程全局PID</span></span><br><span class="line">	<span class="keyword">pid_t</span> tgid; <span class="comment">//进程组内PID</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">//真正父进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">//父进程（为什么会有real_parent和parent，因为线程的存在，其父进程应为创建它的进程的父进程）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">//子进程列表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">//兄弟进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">//对多线程程序有用，指向线程组组长</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptraced</span>;</span> <span class="comment">//ptrace跟踪的进程链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_entry</span>;</span> <span class="comment">//所在父进程的ptrace链表</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span> <span class="comment">//线程组链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_node</span>;</span> <span class="comment">//线程节点链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>		<span class="comment">/* for vfork() */</span></span><br><span class="line">	<span class="keyword">int</span> __user *set_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line">	<span class="keyword">int</span> __user *clear_child_tid;<span class="comment">//与创建新进程相关，传回用户空间</span></span><br><span class="line"><span class="comment">//进程运行时间相关参数</span></span><br><span class="line">	<span class="keyword">cputime_t</span> utime, stime, utimescaled, stimescaled;</span><br><span class="line">	<span class="keyword">cputime_t</span> gtime;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span> <span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	<span class="keyword">seqcount_t</span> vtime_seqcount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> vtime_snap;</span><br><span class="line">	<span class="keyword">enum</span> &#123;</span><br><span class="line">		VTIME_INACTIVE = <span class="number">0</span>,</span><br><span class="line">		VTIME_USER,</span><br><span class="line">		VTIME_SYS,</span><br><span class="line">	&#125; vtime_snap_whence;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NO_HZ_FULL</span></span><br><span class="line">	<span class="keyword">atomic_t</span> tick_dep_mask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">/* context switch counts */</span></span><br><span class="line">	u64 start_time;		</span><br><span class="line">	u64 real_start_time;	<span class="comment">//启动时间</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_cputime</span> <span class="title">cputime_expires</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进程身份相关参数</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer's credentials at attach */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>	</span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">				     \- access with [gs]et_task_comm (which lockit with task_lock())</span></span><br><span class="line"><span class="comment">				     \- initialized normally by setup_new_exec */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span> <span class="comment">//路径相关信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">//IPC参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span><span class="comment">//信号量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span><span class="comment">//共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> last_switch_count; <span class="comment">//切换次数，用于检验进程挂起</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">// 进程文件系统信息 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 打开文件的信息 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span> <span class="comment">// 命名空间 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span> <span class="comment">//信号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span> <span class="comment">//信号处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sigset_t</span> blocked, real_blocked;</span><br><span class="line">	<span class="keyword">sigset_t</span> saved_sigmask;	<span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line">	<span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line">	<span class="keyword">unsigned</span> sas_ss_flags;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">task_works</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line">	<span class="keyword">kuid_t</span> loginuid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> sessionid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span> <span class="title">seccomp</span>;</span></span><br><span class="line"><span class="comment">//线程组信息</span></span><br><span class="line">   	u32 parent_exec_id;</span><br><span class="line">   	u32 self_exec_id;</span><br><span class="line"><span class="comment">//进程资源锁</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line">	<span class="keyword">raw_spinlock_t</span> pi_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> <span class="title">wake_q</span>;</span></span><br><span class="line"><span class="comment">//虚拟内存状态信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span> *<span class="title">reclaim_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_context</span> *<span class="title">io_context</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line">	<span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span> <span class="title">ioac</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_TASK_XACCT)</span></span><br><span class="line">	u64 acct_rss_mem1;	<span class="comment">/* accumulated rss usage */</span></span><br><span class="line">	u64 acct_vm_mem1;	<span class="comment">/* accumulated virtual memory usage */</span></span><br><span class="line">	<span class="keyword">cputime_t</span> acct_timexpd;	<span class="comment">/* stime + utime since last update */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="keyword">nodemask_t</span> mems_allowed;	<span class="comment">/* Protected by alloc_lock */</span></span><br><span class="line">	<span class="keyword">seqcount_t</span> mems_allowed_seq;	<span class="comment">/* Seqence no to catch updates */</span></span><br><span class="line">	<span class="keyword">int</span> cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="keyword">int</span> cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span> *<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span> *<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pi_state_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span> *<span class="title">pi_state_cache</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span> *<span class="title">perf_event_ctxp</span>[<span class="title">perf_nr_task_contexts</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">perf_event_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_PREEMPT</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> preempt_disable_ip;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">........</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为要支持各种各样的功能，task_struct已经变得非常大。不过总体上，结构体可以被划分为如下部分：</p>
<ul>
<li>状态和执行信息，如待决信号、使用的二进制格式（和其他系统二进制格式的任何仿真信息）、进程ID号（ pid）、到父进程及其他有关进程的指针、优先级和程序执行有关的时间信息（例如CPU时间）。</li>
<li>有关已经分配的虚拟内存的信息。</li>
<li>进程身份凭据，如用户ID、组ID以及权限①等。可使用系统调用查询（或修改）这些数据。</li>
<li>使用的文件包含程序代码的二进制文件，以及进程所处理的所有文件的文件系统信息，这些都必须保存下来。</li>
<li>进程信息记录该进程特定于CPU的运行时间数据（该结构的其余字段与所使用的硬件无关）。</li>
<li>在与其他应用程序协作时所需的进程间通信有关的信息。</li>
<li>该进程所用的信号处理程序，用于响应到来的信号。</li>
</ul>
<h3 id="进程ID号"><a href="#进程ID号" class="headerlink" title="进程ID号"></a>进程ID号</h3><p>在task_struct结构体里，我们看到了很多进程ID相关字段，初看会很容易混淆。本节介绍Linux进程ID管理相关思想，帮助理解这些字段的含义。</p>
<p>乍一看进程ID管理应该比较简单：内核只需要保证分配的id不唯一，释放掉的id可以被其他新创建的进程id使用即可。但是事实并非如此，内核需要做如下考量：</p>
<ul>
<li>内核有<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">命名空间</a>的概念，一个进程可以出现在多个命名空间，它在不同的命名空间的id是不同的。</li>
<li>同一个进程可以有多个线程，这些线程（其实也是task_struct）共享同一个线程组id (TGID)</li>
<li>进程可以合并为进程组，而进程组又可以合并为会话（Session）。组或者会话里的进程共享相同的组id或会话id。</li>
</ul>
<p>PID分配需要在特定的命名空间内保证id的唯一性。用来表示PID的命名空间定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> pid_allocated;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span> <span class="comment">//对应命名空间0号进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//该命名空间的层级</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span> <span class="comment">//命名空间上级的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">proc_mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_self</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">proc_thread_self</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_pin</span> *<span class="title">bacct</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">proc_work</span>;</span></span><br><span class="line">	<span class="keyword">kgid_t</span> pid_gid;</span><br><span class="line">	<span class="keyword">int</span> hide_pid;</span><br><span class="line">	<span class="keyword">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125; __randomize_layout</span><br></pre></td></tr></table></figure>

<p>而内核管理命名空间内的pid也主要围绕两个数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> nr; <span class="comment">//id</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span> <span class="comment">//指向所在命名空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;  <span class="comment">//pid使用数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> level; <span class="comment">//层级数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span> <span class="comment">//对应每种类别命名空间进程的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span> <span class="comment">//每级的pid</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中PIDTYPE_MAX为pid类别的枚举类型最大值，具体该枚举类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> pid_type</span><br><span class="line">&#123;</span><br><span class="line">	PIDTYPE_PID,</span><br><span class="line">	PIDTYPE_TGID,</span><br><span class="line">	PIDTYPE_PGID,</span><br><span class="line">	PIDTYPE_SID,</span><br><span class="line">	PIDTYPE_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除此之外，task_struct还保留了两个pid，分别为：</p>
<ul>
<li>pid: 初使命名空间（即init进程所在空间）中该进程的全局ID号</li>
<li>tgid：初使命名空间中该进程的线程组ID号，若该进程非多线程进程，则值与pid相同。</li>
</ul>
<p>一张图表示task_struct中进程id的相互关联：</p>
<p><img src="https://i0.wp.com/www.l2h.site/wp-content/uploads/2019/09/1.png?fit=810%2C467&ssl=1" alt></p>
<p>pid数据结构关系图（引用自《深入理解linux内核架构》）</p>
<p>注意，上图结构为2.6版内核中数据结构。新版内核（截至目前应该是5.）对结构会有部分调整，但总体管理方式和数据结构间关联未变。</p>
<h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>进程可以有子进程，其子进程链表用task_struct的children元素表示。一个子进程和父进程的其他子进程互为兄弟进程，通过task_struct的sibling元素相互关联。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了linux内核管理的基本概念，以及相应的数据结构。后续介绍会包含进程调度基本架构和思想。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核同步之RCU</title>
    <url>/p/282e4a87.html</url>
    <content><![CDATA[<blockquote>
<p>本欲根据自己的理解来写RCU，无奈时间有限，且目前工作内容着重逻辑、架构思考，少接触直接编程。为避免误人子弟，_<strong>从如下文章转载</strong>_：欢迎大家留言交流</p>
<p>《<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652662265&idx=1&sn=4e0ec525316720553666482ec4bd9756&chksm=810f2f64b678a672f9573d0374786f5cb1acbb08fdfe3881fac6275145471ad5fc39aa4bb03e&scene=21#wechat_redirect" target="_blank" rel="noopener">谢宝友:深入理解RCU</a> 》，请尊重原文作者劳动成果</p>
<p>本转载系列文章：<br>LINUX内核同步之RCU<br><a href="https://www.l2h.site/2019/01/19/linux-rcu-zz-2/" target="_blank" rel="noopener">Linux内核同步之RCU（2）</a></p>
</blockquote><h2 id="系列一：从硬件说起"><a href="#系列一：从硬件说起" class="headerlink" title="系列一：从硬件说起"></a>系列一：从硬件说起</h2><h3 id="1-来自于霍金的难题"><a href="#1-来自于霍金的难题" class="headerlink" title="1. 来自于霍金的难题"></a>1. <strong>来自于霍金的难题</strong></h3><a id="more"></a>
<p>据说斯蒂芬·霍金曾经声称半导体制造商面临两个基本问题：</p>
<ol>
<li>有限的光速</li>
<li>物质的原子本质</li>
</ol>
<p>第一个难题，决定了在一个CPU周期内，<strong>电信号无法在整个系统所有CPU中广播。换句话说，某个CPU指令对一个内存地址的写操作，不会在这条指令执行完毕后，马上被其他CPU识别到操作结果</strong>。例如：CPU0对全局变量foo执行foo = 1，当CPU 0执行完相应的汇编代码后，其他CPU核仍然看到foo赋值前的值。刚接触操作系统的读者，需要注意这一点。</p>
<p>第二个难题，导致我们至少需要一个原子来存储二进制位。没有办法在一个原子中存储一个字、一段内存、一个完整的寄存器内容……最终的结果是，硬件工程师没有办法缩小芯片流片面积。当CPU核心增加时，核间通信的负担会变得更加沉重。</p>
<p>当然，作为理论物理学家，霍金的这两个问题都是理论性的。半导体制造商很有可能已经逼近这两个限制。虽然如此，还是有一些研发报告关注于如何规避这两个基本限制。</p>
<p>其中一个绕开物质原子本质的办法是一种称为“high-K绝缘体”的材料，这种材料允许较大的器件模拟超小型器件的电气属性。这种材料存在一些重大的生产困难，但是总算能将研究的前沿再推进一步。另一个比较奇异的解决方法是在单个电子上存储多个比特位，这是建立在单个电子可以同时存在于多个能级的现象之上。不过这种方法还有待观察，才能确定能否在产品级的半导体设备中稳定工作。</p>
<p>还有一种称为“量子点”的解决方法，使得可以制造体积小得多的半导体设备，不过该方法还处于研究阶段。</p>
<p>第一个限制不容易被绕过，虽然量子技术、甚至弦论，理论上允许通信速度超过光速。但是这仅仅是理论研究，实际工程中还未应用。</p>
<h3 id="2-原子操作有多慢？"><a href="#2-原子操作有多慢？" class="headerlink" title="2. 原子操作有多慢？"></a>2. <strong>原子操作有多慢？</strong></h3><p>这里的原子操作，是特指Linux内核中，类似于atomic_long_add_return这样的API。简单的说，就是当某个原子操作完成时，确保所有CPU核已经识别到对原子变量的修改，并且在原子操作期间，其他CPU核不会同步对该变量进行修改。这必然要求相应的电信号在所有的CPU之间广播。如下图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqsmF7fTKuFia1pPYReacibAibz1UmDAq4VlrBOrVHwouwQ4tb7mf1zenSUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>对于普通变量操作（非原子操作）来说，电信号则不必在所有CPU核之间传播并来回传递：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqsoa5ounjwogQJO0STXuIdpwjvFiaS80Z8mjB6laKvwlM7YJicSAdElaFA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>不能忘记一点：Linux操作系统可以运行在超过1024个CPU的大型系统中。在这些大型系统中，在所有CPU之间广播传递电信号，需要花费“很长”的时间。但是，很长究竟是多长？</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqse5qBW0XEncBicW5dZw9XpQk1BQhSsXa1ibpcLxAZwKw7vx1c4ICUGLlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>在上表中，一次“CAS cache miss”的CPU周期是266，够长了吧？而这个测试结果，是在比较新的、4核CPU的多核系统中进行的。在老一点的系统中，或者在更多CPU核心的系统中，这个时间更长。</p>
<h3 id="3-变量可以拥有多个值"><a href="#3-变量可以拥有多个值" class="headerlink" title="3.变量可以拥有多个值"></a>3.<strong>变量可以拥有多个值</strong></h3><p>这不是天方夜谭。</p>
<p>假设CPU 0向全局变量foo写入一个值1，我们会很自然的认为：其他CPU会立即识别到foo的值为1。即使有所疑惑，我们可能也会退一步认为，在稍后某个时刻，其他“所有”CPU都会“同时”识别到foo的值为1。而不会出现一种奇怪的现象：在某个时刻，CPU 1识别到其值为1，而CPU 2识别到其值为0。不幸的是，是时候告别这种想法了。并行计算就是这么神奇和反直觉。如果不能理解这一点，就没办法真正理解RCU。</p>
<p>要明白这一点，考虑下面的代码片段。它被几个CPU并行的执行。第 1行设置共享变量的值为当前CPU的ID，第2行调用gettb()函数对几个值进行初始化，该函数读取硬件时间计数，这个计数值由SOC硬件给出，并且在所有CPU之间共享。当然，这个硬件计数值主要是在power架构上有效，笔者在powerpce500架构上经常使用它。第3-8行的循环，记录变量在当前CPU上保持的时间长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> state.variable = mycpu;</span><br><span class="line"><span class="number">2</span> lasttb = oldtb = firsttb = gettb();</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span> (state.variable == mycpu) &#123;</span><br><span class="line"><span class="number">4</span>   lasttb = oldtb;</span><br><span class="line"><span class="number">5</span>   oldtb = gettb();</span><br><span class="line"><span class="number">6</span>   <span class="keyword">if</span> (lasttb - firsttb &gt;<span class="number">1000</span>)</span><br><span class="line"><span class="number">7</span>     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">8</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在退出循环前，firsttb 将保存一个时间戳，这是赋值的时间。lasttb 也保存一个时间戳，它是对共享变量保持最后赋予的值时刻的采样值，如果在进入循环前，共享变量已经变化，那么就等于firsttb。</p>
<p>这个数据是在一个1.5GHz POWER5 8核系统上采集的。每一个核包含一对硬件线程。CPU 1、2、3和4记录值，而CPU 0 控制测试。时间戳计数器周期是5.32ns，这对于我们观察缓存状态来说是足够了。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqsiauM3g6UrUbIlSwpiaKATgK6SrjKkLcLE8b3fVTiaDwAIXQJtBbA8DmJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>上图的结果，展示出每个CPU识别到变量保持的时间。每一个水平条表示该CPU观察到变量的时间，左边的黑色区域表示相应的CPU第一次计数的时间。在最初5ns期间, 仅仅CPU 3拥有变量的值。在接下来的10ns，CPU 2和3看到不一致的变量值，但是随后都一致的认为其值是“2”。 但是，CPU 1在整个300ns内认为其值是“1”，并且 CPU 4 在整个500ns内认为其值是“4”。</p>
<p>这真是一个匪夷所思的测试结果。同一个变量，竟然在不同的CPU上面被看到不同的值！！！！</p>
<p>如果不理解硬件，就不会接受这个匪夷所思的测试结果。当然了，此时如果有一位大师站在你的面前，你也不能够跟随大师的节奏起舞。</p>
<h3 id="4-为什么需要MESI"><a href="#4-为什么需要MESI" class="headerlink" title="4* 为什么需要MESI"></a>4* <strong>为什么需要MESI</strong></h3><p>请不要说：我还不知道MESI是什么？</p>
<p>简单的说，MESI是一种内存缓存一致性协议。</p>
<p>现代CPU的速度比现代内存系统的速度快得多。2006 年的CPU可以在每纳秒内执行十条指令。但是需要很多个十纳秒才能从物理内存中取出一个数据。它们的速度差异（超过2个数量级）导致在现代CPU中出现了数兆级别的缓存。这些缓存与CPU是相关联的，如下图。典型的，缓存可以在几个时钟周期内被访问。借助于CPU流水线的帮助，我们暂且可以认为，缓存能够抵消内存对CPU性能的影响。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqsRbyibhP3RlRhbmUjqMrnMetV5B6iaU0Fiahjdzvia9Gic1hjgnmCd2g87kA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>CPU缓存和内存之间的数据流是固定长度的块，称为“缓存行”，其大小通常是2的N次方。范围从16到256字节不等。当一个特定的数据第一次被CPU访问时，它在缓存中还不存在，这称为“cache miss”(或者可被更准确的称为“startup cache miss”或者“warmupcache miss”)。“cache miss”意味着：CPU在从物理内存中读取数据时，它必须等待(或处于“stalled”状态) 数百个CPU周期。但是，数据将被装载入CPU缓存以后，后续的访问将在缓存中找到，因此可以全速运行。</p>
<p>经过一段时间后，CPU的缓存将会被填满，后续的缓存缺失需要换出缓存中现有的数据，以便为最近的访问项腾出空间。这种“cache miss”被称为“capacitymiss”，因为它是由于缓存容量限制而造成的。但是，即使此时缓存还没有被填满，大量缓存也可能由于一个新数据而被换出。这是由于大量的缓存是通过硬件哈希表来实现的，这些哈希表有固定长度的哈希桶（或者叫“sets”，CPU设计者是这样称呼的），如下图。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqseU5B5jSbMhjn1GlicWxpUFZqnU1I67j6WnjhsM0oZ12EicSOK0HZXyqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这个缓存有16个“sets”和2“路”，共32个“缓存行”，每个节点包含一个256字节的“缓存行”，它是一个256字节对齐的内存块。这个缓存行稍微显得大了一点，但是这使得十六进制的运行更简单。从硬件的角度来说，这是一个两路组相联缓存，类似于带16个桶的软件哈希表，每个桶的哈希链最多有两个元素。大小 (本例中是32个缓存行) 和相连性 (本例中是2) 都被称为缓存的“geometry”。由于缓存是硬件实现的，哈希函数非常简单：从内存地址中取出4位（哈希桶数量）作为哈希键值。</p>
<p>在程序代码位于地址0x43210E00- 0x43210EFF，并且程序依次访问地址0x12345000-0x12345EFF时，图中的情况就可能发生。假设程序正准备访问地址0x12345F00，这个地址会哈希到 0xF行，该行的两路都是空的，因此可以提供对应的256字节缓存行。如果程序访问地址0x1233000，将会哈希到第0行，相应的256字节缓存行可以放到第1路。但是，如果程序访问地址0x1233E00，将会哈希到第0xE行，必须有一个缓存行被替换出去，以腾出空间给新的行。如果随后访问被替换的行，会产生一次“cache miss”，这样的缓存缺失被称为“associativitymiss”。</p>
<p>更进一步说，我们仅仅考虑了读数据的情况。当写的时候会发生什么呢？由于在一个特定的CPU写数据前，让所有CPU都意识到数据被修改这一点是非常重要的。因此，它必须首先从其他CPU缓存中移除，或者叫“invalidated”（使无效）。一旦“使无效”操作完成，CPU可以安全的修改数据项。如果数据存在于该CPU缓存中，但是是只读的，这个过程称为“write miss”。一旦某个特定的CPU使其他CPU完成了“使无效”操作，该CPU可以反复的重新写（或者读）数据。</p>
<p>最后，如果另外某个CPU试图访问数据项，将会引起一次缓存缺失，此时，由于第一个CPU为了写而使得缓存项无效，这被称为“communication miss”。因为这通常是由于几个CPU使用缓存通信造成的（例如，一个用于互斥算法的锁使用这个数据项在CPU之间进行通信）。</p>
<p>很明显，所有CPU必须小心的维护数据的一致性视图。这些问题由“缓存一致性协议”来防止，常用的缓存一致性是MESI。</p>
<h3 id="5-MESI的四种状态"><a href="#5-MESI的四种状态" class="headerlink" title="5. MESI的四种状态"></a>5. <strong>MESI的四种状态</strong></h3><p>MESI 存在“modified”，“exclusive”，“shared”和“invalid”四种状态，协议可以在一个指定的缓存行中应用这四种状态。因此，协议在每一个缓存行中维护一个两位的状态标记，这个标记附着在缓存行的物理地址和数据后面。</p>
<p>处于“modified”状态的缓存行是由于相应的CPU最近进行了内存存储。并且相应的内存确保没有在其他CPU的缓存中出现。因此，“modified”状态的缓存行可以被认为被CPU所“拥有”。由于该缓存保存了“最新”的数据，因此缓存最终有责任将数据写回到内存，也应当为其他缓存提供数据，并且必须在缓存其他数据之前完成这些事情。</p>
<p>“exclusive”状态非常类似于“modified”状态，唯一的差别是该缓存行还没有被相应的CPU修改，这也表示缓存行中的数据及内存中的数据都是最新的。但是，由于CPU能够在任何时刻将数据存储到该行，而不考虑其他CPU，因此，处于“exclusive”状态也可以认为被相应的CPU所“拥有”。也就是说，由于物理内存中的值是最新的，该行可以直接丢弃而不用回写到内存，也不用通知其他CPU。</p>
<p>处于“shared”状态的缓存行可能已经被复制到至少一个其他CPU的缓存中，这样在没有得到其他CPU的许可时，不能向缓存行存储数据。与“exclusive”状态相同，此时内存中的值是最新的，因此可以不用向内存回写值而直接丢弃缓存中的值，也不用通知其他CPU。</p>
<p>处于“invalid”状态的行是空的，换句话说，它没有保存任何有效数据。当新数据进入缓存时，它被放置到一个处于“invalid”状态的缓存行。这个方法是比较好的，因为替换其他状态的缓存行将引起大量的缓存缺失。</p>
<p>由于所有CPU必须维护缓存行中的数据一致性视图，因此缓存一致性协议提供消息以标识系统中缓存行的动作。</p>
<h3 id="6-MESI消息"><a href="#6-MESI消息" class="headerlink" title="6. MESI消息"></a>6. <strong>MESI消息</strong></h3><p>MESI协议需要在CPU之间通信。如果CPU在单一共享总线上，只需要如下消息就足够了：</p>
<ul>
<li>读消息：“读”消息包含要读取的缓存行的物理地址。</li>
<li>读响应消息：“读响应”消息包含较早前的“读”消息的数据。这个“读响应”消息可能由物理内存或者其他CPU的缓存提供。例如，如果一个缓存处于“modified”状态，那么，它的缓存必须提供“读响应”消息。</li>
<li>使无效消息：“使无效”消息包含要使无效的缓存行的物理地址。其他的缓存必须从它们的缓存中移除相应的数据并且响应此消息。</li>
<li>使无效应答：一个接收到“使无效”消息的CPU必须在移除指定数据后响应一个“使无效应答”消息。</li>
<li>读使无效：“读使无效”消息包含缓存行要读取的物理地址。同时指示其他缓存移除数据。因此，它同时包含一个“读”消息和一个“使无效”消息。“读使无效”消息同时需要“读响应”消息以及“使无效应答”消息进行答应。</li>
<li>写回：“写回”消息包含要回写到物理内存的地址和数据。(并且也许会“探测”其他CPU的缓存)。这个消息允许缓存在必要时换出处于“modified”状态的数据以腾出空间。</li>
</ul>
<p>再次重申，所有这些消息均需要在CPU之间传播电信号，都面临霍金提出的那两个IT难题。</p>
<h3 id="7-MESI状态转换"><a href="#7-MESI状态转换" class="headerlink" title="7. MESI状态转换"></a><strong>7. MESI状态转换</strong></h3><p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bys3d9lhjr1BiacWyP6ibVeLqs96SnuRicjvOIX3Aap5IXTx16wSUz2bciacQhVHWttg5qnnPiaHyzkTHKw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<ul>
<li>Transition (a)：缓存行被写回到物理内存，但是CPU仍然将它保留在缓存中，并在以后修改它。这个转换需要一个“写回”消息。</li>
<li>Transition (b)：CPU将数据写到缓存行，该缓存行目前处于排它访问。不需要发送或者接收任何消息。</li>
<li>Transition (c)：CPU收到一个“读使无效”消息，相应的缓存行已经被修改。CPU必须使无效本地副本，然后响应“读响应”和 “使无效应答”消息，同时发送数据给请求的CPU，标示它的本地副本不再有效。</li>
<li>Transition (d)：CPU进行一个原子读—修改—写操作，相应的数据没有在它的缓存中。它发送一个“读使无效”消息，通过“读响应”消息接收数据。一旦它接收到一个完整的“使无效应答”响应集合，CPU就完成此转换。</li>
<li>Transition (e)：CPU进行一个原子读—修改—写操作，相应的数据在缓存中是只读的。它必须发送一个“使无效”消息，并等待“使无效应答”响应集合以完成此转换。</li>
<li>Transition (f)：其他某些CPU读取缓存行，其数据由本CPU提供，本CPU包含一个只读副本。数据只读的原因，可能是由于数据已经回写到内存中。这个转换开始于接收到一个“读”消息，最终本CPU响应了一个“读响应” 消息。</li>
<li>Transition (g)：其他CPU读取数据，并且数据是从本CPU的缓存或者物理内存中提供的。无论哪种情况，本CPU都会保留一个只读副本。这个事务开始于接收到一个“读”消息，最终本CPU响应一个“读响应”消息。</li>
<li>Transition (h)：当前CPU很快将要写入一些数据到缓存行，于是发送一个“使无效”消息。直到它接收到所有“使无效应答”消息后，CPU才完成转换。可选的，所有其他CPU通过“写回”消息将缓存行的数据换出（可能是为其他缓存行腾出空间）。这样，当前CPU就是最后一个缓存该数据的CPU。</li>
<li>Transition (i)：其他某些CPU进行了一个原子读—修改—写操作，相应的缓存行仅仅被本CPU持有。本CPU将缓存行变成无效状态。这个转换开始于接收到“读使无效”消息，最终本CPU响应一个“读响应”消息以及一个“使无效应答”消息。</li>
<li>Transition (j)：本CPU保存一个数据到缓存行，但是数据还没有在它的缓存行中。因此发送一个“读使无效”消息。直到它接收到“读响应”消息以及所有“使无效应答”消息后，才完成事务。缓存行可能会很快转换到“修改”状态，这是在存储完成后由Transition (b)完成的。</li>
<li>Transition (k)：本CPU装载一个数据，但是数据还没有在缓存行中。CPU发送一个“读”消息，当它接收到相应的“读响应”消息后完成转换。</li>
<li>Transition (l)：其他CPU存储一个数据到缓存行，但是该缓存行处于只读状态（因为其他CPU也持有该缓存行）。这个转换开始于接收到一个“使无效”消息，当前CPU最终响应一个“使无效应答”消息。</li>
</ul>
<h2 id="系列二：从硬件说起之内存屏障"><a href="#系列二：从硬件说起之内存屏障" class="headerlink" title="系列二：从硬件说起之内存屏障"></a>系列二：从硬件说起之内存屏障</h2><h3 id="1-内存Cache还有哪些不足？"><a href="#1-内存Cache还有哪些不足？" class="headerlink" title="1. 内存Cache还有哪些不足？"></a>1. 内存Cache还有哪些不足？</h3><p>上一篇文章我们谈到了内存Cache，并且描述了典型的Cache一致性协议MESI。Cache的根本目的，是解决内存与CPU速度多达两个数量级的性能差异。一个包含Cache的计算机系统，其结构可以简单的表示为下图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byscTZBf0ibHrT3zByX1gPcNKZYK0ticYUbtnCXAicuooM6jUaicuJJnGlE18fWrTAFa9YthfQHSBicenAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>仅仅只有Cache的计算机系统，它还存在如下问题：</p>
<ol>
<li>Cache的速度，虽然比内存有了极大的提升，但是仍然比CPU慢几倍。</li>
<li>在发生“warmup cache miss”、“capacity miss”、“associativity miss”时，CPU必须等待从内存中读取数据，此时CPU会处于一种Stall的状态。其等待时间可能达到几百个CPU指令周期。</li>
</ol>
<p>显然，这是现代计算机不能承受之重：）</p>
<h3 id="2-Write-buffer是为了解决什么问题？"><a href="#2-Write-buffer是为了解决什么问题？" class="headerlink" title="2. Write buffer是为了解决什么问题？"></a>2. Write buffer是为了解决什么问题？</h3><p>如果CPU仅仅是执行foo = 1这样的语句，它其实无须从内存或者缓存中读取foo现在的值。因为无论foo当前的值是什么，它都会被覆盖。在仅仅只有Cache的系统中，foo = 1 这样的操作也会形成写停顿。自然而然的，CPU设计者应当会想到在Cache 和CPU之间再添加一级缓存。由于这样的缓存主要是应对写操作引起的Cache Miss，并且缓存的数据与写操作相关，因此CPU设计者将它命名为“Write buffer”。调整后的结构示意图如下(图中的store buffer即为write buffer)：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byscTZBf0ibHrT3zByX1gPcNKhtcDw4A3k4eiaKhJwL8LIjZTNaicaEwmEgiakK63Ldff9f3MRsFDUgzoQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>通过增加这些Write buffer，CPU可以简单的将要保存的数据放到Write buffer 中，并且继续运行，而不会真正去等待Cache从内存中读取数据并返回。</p>
<p>对于特定CPU来说，这些Write buffer是属于本地的。或者在硬件多线程系统中，它对于特定核来说，是属于本地的。无论哪一种情况，一个特定CPU仅仅允许访问分配给它的Writebuffer。例如，在上图中，CPU 0不能访问CPU 1的存储缓冲，反之亦然。</p>
<p>Write buffer进一步提升了系统性能，但是它也会为硬件设计者带来一些困扰：</p>
<p><strong>第一个困扰：违反了自身一致性。</strong></p>
<p>考虑如下代码：变量“a”和“b”都初始化为0，包含变量“a”缓存行，最初被CPU 1所拥有，而包含变量“b”的缓存行最初被CPU0所拥有：</p>
<p>a = 1;<br>b = a + 1;<br>assert(b == 2);</p>
<p>没有哪一位软件工程师希望断言被触发！</p>
<p>然而，如果采用上图中的简单系统结构，断言确实会被触发。理解这一点的关键在于：a最初被CPU 1所拥有，而CPU 0在执行a = 1时，将a的新值存储在CPU 0的Write buffer中。</p>
<p>在这个简单系统中，触发断言的事件顺序可能如下：</p>
<ul>
<li>1．CPU 0 开始执行a = 1。</li>
<li>2．CPU 0在缓存中查找“a”，并且发现缓存缺失。</li>
<li>3．因此，CPU 0发送一个“读使无效（read-invalidate message）”消息，以获得包含“a”的独享缓存行。</li>
<li>4．CPU 0将“a”记录到存储缓冲区。</li>
<li>5．CPU 1接收到“读使无效”消息，它通过发送缓存行数据，并从它的缓存行中移除数据来响应这个消息。</li>
<li>6．CPU 0开始执行b = a + 1。</li>
<li>7．CPU 0从CPU 1接收到缓存行，它仍然拥有一个为“0”的“a”值。</li>
<li>8．CPU 0从它的缓存中读取到“a”的值，发现其值为0。</li>
<li>9．CPU 0将存储队列中的条目应用到最近到达的缓存行，设置缓存行中的“a”的值为1。</li>
<li>10．CPU 0将前面加载的“a”值0加1，并存储该值到包含“b”的缓存行中（假设已经被CPU 0所拥有）。</li>
<li>11．CPU 0 执行assert(b == 2)，并引起错误。</li>
</ul>
<p>针对这种情况，硬件设计者对软件工程师还是给予了必要的同情。他们会对系统进行稍许的改进，如下图：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byscTZBf0ibHrT3zByX1gPcNKXRbVr6MNkyYxDrWhEhKAxhHhBke0KPVnh9xITIT6hndARqjldHRWmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>在调整后的架构中，每个CPU在执行加载操作时，将考虑（或者嗅探）它的Writebuffer。这样，在前面执行顺序的第8步，将在存储缓冲区中为“a”找到正确的值1 ，因此最终的“b”值将是2，这正是我们期望的。</p>
<p>Write buffer带来的第二个困扰，是违反了全局内存序。考虑如下的代码顺序，其中变量“a”、“b”的初始值是0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>   a = <span class="number">1</span>;</span><br><span class="line"> <span class="number">4</span>   b = <span class="number">1</span>;</span><br><span class="line"> <span class="number">5</span> &#125;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span> <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> 8 </span>&#123;</span><br><span class="line"> <span class="number">9</span>   <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">10</span>   assert(a == <span class="number">1</span>);</span><br><span class="line"><span class="number">11</span> &#125;</span><br></pre></td></tr></table></figure>

<p>假设CPU 0执行foo()，CPU1执行bar()，再进一步假设包含“a”的缓存行仅仅位于CPU1的缓存中，包含“b”的缓存行被CPU 0所拥有。那么操作顺序可能如下：</p>
<ul>
<li>1．CPU 0 执行a = 1。缓存行不在CPU0的缓存中，因此CPU0将“a”的新值放到Write buffer，并发送一个“读使无效”消息。</li>
<li>2．CPU 1 执行while (b == 0) continue，但是包含“b”的缓存行不在它的缓存中，因此它发送一个“读”消息。</li>
<li>3．CPU 0 执行 b = 1，它已经拥有了该缓存行（换句话说，缓存行要么已经处于“modified”，要么处于“exclusive”状态），因此它存储新的“b”值到它的缓存行中。</li>
<li>4．CPU 0 接收到“读”消息，并且发送缓存行中的最近更新的“b”的值到CPU1，同时将缓存行设置为“shared”状态。</li>
<li>5．CPU 1 接收到包含“b”值的缓存行，并将其值写到它的缓存行中。</li>
<li>6．CPU 1 现在结束执行while (b ==0) continue，因为它发现“b”的值是1，它开始处理下一条语句。</li>
<li>7．CPU 1 执行assert(a == 1)，并且，由于CPU 1工作在旧的“a”的值，因此断言验证失败。</li>
<li>8．CPU 1 接收到“读使无效”消息，并且发送包含“a”的缓存行到CPU 0，同时在它的缓存中，将该缓存行变成无效。但是已经太迟了。</li>
<li>9．CPU 0 接收到包含“a”的缓存行，并且及时将存储缓冲区的数据保存到缓存行中，CPU1的断言失败受害于该缓存行。</li>
</ul>
<p>请注意，“内存屏障”已经在这里隐隐约约露出了它锋利的爪子！！！！</p>
<h3 id="3-使无效队列又是为了解决什么问题？"><a href="#3-使无效队列又是为了解决什么问题？" class="headerlink" title="3. 使无效队列又是为了解决什么问题？"></a>3. 使无效队列又是为了解决什么问题？</h3><p><strong>一波未平，另一波再起。</strong></p>
<p>问题的复杂性还不仅仅在于Writebuffer，因为仅仅有Write buffer，硬件还会形成严重的性能瓶颈。</p>
<p>问题在于，每一个核的Writebuffer相对而言都比较小，这意味着执行一段较小的存储操作序列的CPU，很快就会填满它的Writebuffer。此时，CPU在能够继续执行前，必须等待Cache刷新操作完成，以清空它的Write buffer。</p>
<p>清空Cache是一个耗时的操作，因为必须要在所在CPU之间广播MESI消息(使无效消息)，并等待对这些MESI消息的响应。为了加快MESI消息响应速度，CPU设计者增加了使无效队列。也就是说，CPU将接收到的使无效消息暂存起来，在发送使无效消息应答时，并不真正将Cache中的值无效。而是等待在合适的时候，延迟使无效操作。</p>
<p>下图是增加了使无效队列的系统结构：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6byscTZBf0ibHrT3zByX1gPcNKVaIcE4niciclcQDUZfFT2zNff1ukT3xC3IaZSnPmdRa0hZevyS1SibIBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>将一个条目放进使无效队列，实际上是由CPU承诺：在发送任何与该缓存行相关的MESI协议消息前，处理该条目。在Cache竞争不太剧烈的情况下，CPU会很出色地完成此事。</p>
<p>使无效队列带来的问题是：在没有真正将Cache无效之前，就告诉其他CPU已经使无效了。这多少有一点欺骗的意思。然而现代CPU确实是这样设计的。</p>
<p>这个事实带来了额外的内存乱序的机会，看看如下示例：</p>
<p>假设“a”和“b”被初始化为0，“a”是只读的（MESI“shared”状态），“b”被CPU 0拥有（MESI“exclusive”或者“modified”状态）。然后假设CPU 0执行foo()而CPU1执行bar()，代码片段如下：</p>
<p>  1 void foo(void)<br>  2 {<br>  3   a = 1;<br>  4   smp_mb();<br>  5   b = 1;<br>  6 }<br>  7<br>  8 void bar(void)<br>  9 {<br> 10   while (b == 0) continue;<br> 11   assert(a == 1);<br> 12 }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">操作顺序可能如下：</span><br><span class="line"></span><br><span class="line">*   1．CPU 0执行a = 1。在CPU0中，相应的缓存行是只读的，因此CPU 0将“a”的新值放入存储缓冲区，并发送一个“使无效”消息，这是为了使CPU1的缓存中相应的缓存行失效。</span><br><span class="line">*   2．CPU 1执行while (b == 0)continue，但是包含“b”的缓存行不在它的缓存中，因此它发送一个“读”消息。</span><br><span class="line">*   3．CPU 1接收到CPU 0的“使无效”消息，将它排队，并立即响应该消息。</span><br><span class="line">*   4．CPU 0接收到来自于CPU 1的响应消息，因此它放心的通过第4行的smp_mb()，从存储缓冲区移动“a”的值到缓存行。</span><br><span class="line">*   5．CPU 0执行b = 1。它已经拥有这个缓存行（也就是说，缓存行已经处于“modified”或者“exclusive”状态），因此它将“b”的新值存储到缓存行中。</span><br><span class="line">*   6．CPU 0接收到“读”消息，并且发送包含“b”的新值的缓存行到CPU 1，同时在自己的缓存中，标记缓存行为“shared”状态。</span><br><span class="line">*   7．CPU 1接收到包含“b”的缓存行并且将其应用到本地缓存。</span><br><span class="line">*   8．CPU 1现在可以完成while (b ==0) continue，因为它发现“b”的值为1，接着处理下一条语句。</span><br><span class="line">*   9．CPU 1执行assert(a == 1)，并且，由于旧的“a”值还在CPU 1的缓存中，因此陷入错误。</span><br><span class="line">*   10．虽然陷入错误，CPU 1处理已经排队的“使无效”消息，并且（迟到）在自己的缓存中刷新包含“a”值的缓存行。</span><br><span class="line"></span><br><span class="line">### 4. 内存屏障</span><br><span class="line"></span><br><span class="line">既然硬件设计者通过Write buffer和使无效队列引入了额外的内存乱序问题，那么就应当为软件工程师提供某种方法来解决这个问题。即使相应的解决方法会折磨软件工程师。</span><br><span class="line"></span><br><span class="line">答案就是内存屏障。对于Linux内核资深工程师来说，这个答案也显得比较沉重，它太折磨人了：）</span><br><span class="line"></span><br><span class="line">我们先看看Write buffer一节中，触发断言的例子，应该怎么修改。</span><br><span class="line"></span><br><span class="line">在那个例子中，硬件设计者不能直接帮助我们，因为 CPU没有办法识别那些相关联的变量（例子中的a和b），更不用说它们如何关联。因此，硬件设计者提供内存屏障指令，以允许软件告诉CPU这些关系的存在。程序必须修改，以包含内存屏障：</span><br><span class="line">```C</span><br><span class="line">void foo(void)</span><br><span class="line">&#123;</span><br><span class="line">   a = 1;</span><br><span class="line">   smp_mb();</span><br><span class="line">   b = 1;</span><br><span class="line">&#125;</span><br><span class="line">void bar(void)</span><br><span class="line">&#123;</span><br><span class="line">   while (b == 0) continue;</span><br><span class="line">   assert(a == 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存屏障smp_mb()将导致CPU在刷新后续的缓存行（包含b的缓存行）之前，前面的Write buffer被先刷新。在继续处理之前，CPU可能采取的动作是：</p>
<ul>
<li>1、简单的停顿下来，直到存储缓冲区变成空；</li>
<li>2、也可能是使用存储缓冲区来持有后续的存储操作，直到前面所有的存储缓冲区已经被保存到缓存行中。</li>
</ul>
<p>理解其中第2点，能够帮助我们理解“内存屏障”这个单词的来历！！后一种情况下，操作序列可能如下所示：</p>
<ul>
<li>1．CPU 0执行a= 1。缓存行不在CPU0的缓存中，因此CPU 0将“a”的新值放到存储缓冲中，并发送一个“读使无效”消息。</li>
<li>2．CPU 1 执行while(b == 0) continue，但是包含“b”的缓存行不在它的缓存中，因此它发送一个“读”消息。</li>
<li>3．CPU 0执行smp_mb()，并标记当前所有存储缓冲区的条目。（也就是说a = 1这个条目）。</li>
<li>4．CPU 0执行b= 1。它已经拥有这个缓存行了。（也就是说, 缓存行已经处于“modified”或者“exclusive”状态），但是在存储缓冲区中存在一个标记条目。因此，它不将“b”的新值存放到缓存行，而是存放到存储缓冲区中。（但是“b”不是一个标记条目）。</li>
<li>5．CPU 0接收“读”消息，随后发送包含原始“b”值的缓存行给CPU1。它也标记该缓存行的复制为“shared”状态。</li>
<li>6．CPU 1读取到包含“b”的缓存行，并将它复制到本地缓存中。</li>
<li>7．CPU 1现在可以装载“b”的值了，但是，由于它发现其值仍然为“0”，因此它重复执行while语句。“b”的新值被安全的隐藏在CPU0的存储缓冲区中。</li>
<li>8．CPU 1接收到“读使无效”消息，发送包含“a”的缓存行给CPU 0，并且使它的缓存行无效。</li>
<li>9．CPU 0接收到包含“a”的缓存行，使用存储缓冲区的值替换缓存行，将这一行设置为“modified”状态。</li>
<li>10．由于被存储的“a”是存储缓冲区中唯一被smp_mb()标记的条目，因此CPU0能够存储“b”的新值到缓存行中，除非包含“b”的缓存行当前处于“shared”状态。</li>
<li>11．CPU 0发送一个“使无效”消息给CPU 1。</li>
<li>12．CPU 1接收到“使无效”消息，使包含“b”的缓存行无效，并且发送一个“使无效应答”消息给 CPU 0。</li>
<li>13．CPU 1执行while(b == 0) continue，但是包含“b”的缓存行不在它的缓存中，因此它发送一个“读”消息给 CPU 0。</li>
<li>14．CPU 0接收到“使无效应答”消息，将包含“b”的缓存行设置成“exclusive”状态。CPU 0现在存储新的“b”值到缓存行。</li>
<li>15．CPU 0接收到“读”消息，同时发送包含新的“b”值的缓存行给 CPU 1。它也标记该缓存行的复制为“shared”状态。</li>
<li>16．CPU 1接收到包含“b”的缓存行，并将它复制到本地缓存中。</li>
<li>17．CPU 1现在能够装载“b”的值了，由于它发现“b”的值为1，它退出while循环并执行下一条语句。</li>
<li>18．CPU 1执行assert(a== 1)，但是包含“a”的缓存行不在它的缓存中。一旦它从CPU0获得这个缓存行，它将使用最新的“a”的值，因此断言语句将通过。</li>
</ul>
<p>正如你看到的那样，这个过程涉及不少工作。即使某些事情从直觉上看是简单的操作，就像“加载a的值”这样的操作，都会包含大量复杂的步骤。</p>
<p>前面提到的，其实是写端的屏障，它解决Write buffer引入的内存乱序。接下来我们看看读端的屏障，它解决使无效队列引入的内存乱序。</p>
<p>要避免使无效队列例子中的错误，应当再使用读端内存屏障：</p>
<p>读端内存屏障指令能够与使无效队列交互，这样，当一个特定的CPU执行一个内存屏障时，它标记无效队列中的所有条目，并强制所有后续的装载操作进行等待，直到所有标记的条目都保存到CPU的Cache中。因此，我们可以在bar函数中添加一个内存屏障，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> 2 </span>&#123;</span><br><span class="line"> <span class="number">3</span>   a = <span class="number">1</span>;</span><br><span class="line"> <span class="number">4</span>   smp_mb();</span><br><span class="line"> <span class="number">5</span>   b = <span class="number">1</span>;</span><br><span class="line"> <span class="number">6</span> &#125;</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>   <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">11</span>   smp_mb();</span><br><span class="line"><span class="number">12</span>   assert(a == <span class="number">1</span>);</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<p>有了这个变化后，操作顺序可能如下：</p>
<ul>
<li>1．CPU 0执行a= 1。相应的缓存行在CPU0的缓存中是只读的，因此CPU0将“a”的新值放入它的存储缓冲区，并且发送一个“使无效”消息以刷新CPU1相应的缓存行。</li>
<li>2．CPU 1 执行while(b == 0) continue，但是包含“b”的缓存行不在它的缓存中，因此它发送一个“读”消息。</li>
<li>3．CPU 1 接收到 CPU 0的“使无效”消息，将它排队，并立即响应它。</li>
<li>4．CPU 0 接收到CPU1的响应，因此它放心的通过第4行的smp_mb()语句，将“a”从它的存储缓冲区移到缓存行。</li>
<li>5．CPU 0 执行b= 1。它已经拥有该缓存行（换句话说, 缓存行已经处于“modified”或者“exclusive”状态），因此它存储“b”的新值到缓存行。</li>
<li>6．CPU 0 接收到“读”消息，并且发送包含新的“b”值的缓存行给CPU1，同时在自己的缓存中，标记缓存行为“shared”状态。</li>
<li>7．CPU 1 接收到包含“b”的缓存行并更新到它的缓存中。</li>
<li>8．CPU 1 现在结束执行while (b == 0) continue，因为它发现“b”的值为 1，它处理下一条语句，这是一条内存屏障指令。</li>
<li>9．CPU 1 必须停顿，直到它处理完使无效队列中的所有消息。</li>
<li>10．CPU 1 处理已经入队的“使无效”消息，从它的缓存中使无效包含“a”的缓存行。</li>
<li>11．CPU 1 执行assert(a== 1)，由于包含“a”的缓存行已经不在它的缓存中，它发送一个“读”消息。</li>
<li>12．CPU 0 以包含新的“a”值的缓存行响应该“读”消息。</li>
<li>13．CPU 1 接收到该缓存行，它包含新的“a”的值1，因此断言不会被触发。</li>
</ul>
<p>即使有很多MESI消息传递，CPU最终都会正确的应答。这一节阐述了CPU设计者为什么必须格外小心地处理它们的缓存一致性优化操作。</p>
<p>但是，这里真的需要一个读端内存屏障么？在assert()之前，不是有个循环么？</p>
<p>难道在循环结束之前，会执行assert(a == 1)？</p>
<p>对此有疑问的读者，您需要补充一点关于猜测（冒险）执行的背景知识！可以找CPU参考手册看看。简单的说，在循环的时候，a== 1这个比较条件，有可能会被CPU预先加载a的值到流水线中。临时结果不会被保存到Cache或者Write buffer中，而是在CPU流水线中的临时结果寄存器中暂存起来 。</p>
<p>这是不是非常的反直觉？然而事实就是如此。</p>
<p>对CPU世界中反直觉的东西有兴趣的朋友，甚至可以看看量子力学方面的书，量子计算机真的需要懂量子力学。让《深入理解并行编程》一书中提到的“<strong>薛定谔的猫</strong>”来烧一下脑，这只猫已经折磨了无数天才的大脑。除了霍金，还有爱因斯坦的大脑！</p>
<ol start="5">
<li>关于内存屏障进一步的思考</li>
</ol>
<p>本文仅仅从硬件的角度，引申出内存屏障。其目的是为了后续文章中，更好的讲解RCU。因此，并不会对内存屏障进行深入的剖析。但是，对于理解RCU来说，本文中的内存屏障知识已经可以了。</p>
<p>更深入的思考包括：</p>
<ul>
<li>1、读屏障、写屏障、读依赖屏障的概念</li>
<li>2、各个体系架构中，屏障的实现、及其微妙的差别</li>
<li>3、深入思考内存屏障是否是必须的，有没有可能通过修改硬件，让屏障不再有用？</li>
<li>4、内存屏障的传递性，这是Linux系统中比较微妙而难于理解的概念。</li>
<li>5、单核架构中的屏障，是为了解决什么问题？怎么使用？</li>
<li>6、屏障在内核同步原语中的使用，满足了什么样的同步原语语义？</li>
</ul>
<h2 id="系列三：概念"><a href="#系列三：概念" class="headerlink" title="系列三：概念"></a>系列三：概念</h2><h3 id="1-RCU有什么用？"><a href="#1-RCU有什么用？" class="headerlink" title="1. RCU有什么用？"></a>1. RCU有什么用？</h3><p>RCU主要用于对性能要求苛刻的并行实时计算。例如：天气预报、模拟核爆炸计算、内核同步等等。</p>
<p>假设你正在编写一个并行实时程序，该程序需要访问随时变化的数据。这些数据可能是随着温度、湿度的变化而逐渐变化的大气压。这个程序的实时响应要求是如此严格，需要处理的数据量如此巨大，以至于不允许任何自旋或者阻塞，因此不能使用任何锁。</p>
<p>幸运的是，温度和压力的范围通常变化不大，因此使用默认的数据集也是可行的。当温度、湿度和压力抖动时，有必要使用实时数据。但是温度、湿度和压力是逐渐变化的，我们可以在几分钟内更新数据，但没必要实时更新值。</p>
<p>在这种情况下，可以使用一个全局指针，即gptr，通常为NULL，表示要使用默认值。偶尔也可以将gptr指向假设命名为a、b和c的变量，以反映气压的变化。</p>
<p>传统的软件可以使用自旋锁这样的同步机制，来保护gptr指针的读写。一旦旧的值不被使用，就可以将旧指针指向的数据释放。这种简单的方法有一个最大的问题：它会使软件效率下降数个数量级（注意，不是下降数倍而是下降数个数量级）。</p>
<p>在现代计算系统中，向gptr写入a、b、c这样的值，并发的读者要么看到一个NULL指针要么看到指向新结构gptr的指针，不会看到中间结果。也就是说，对于指针赋值来说，某种意义上这种赋值是原子的。读者不会看到a、b、c之外的其他结果。并且，更好的一点，也是更重要的一点是：读者不需要使用任何代价高昂的同步原语，因此这种方法非常适合于实时使用。</p>
<p>真正的难点在于：在读者获得gptr的引用时，它可能看到a、b、c这三个值中任意一个值，写者何时才能安全的释放a、b、c所指向的内存数据结构？</p>
<p>引用计数的方案很有诱惑力，但正如锁和顺序锁一样，引用计数可能消耗掉数百个CPU指令周期，更致命的是，它会引用缓存行在CPU之间的来回颠簸，破坏各个CPU的缓存，引起系统整体性能的下降。很明显，这种选择不是我们所期望的。</p>
<p>想要理解Linux经典RCU实现的读者，应当认真阅读下面这段话：</p>
<p>一种实现方法是，写者完全不知道有哪些读者存在。这种方法显然让读者的性能最佳，但留给写者的问题是：如何才能确定所有的老读者已经完成。</p>
<p>最简单的实现是：让线程不会被抢占，或者说，读者在读RCU数据期间不能被抢占。在这种不可抢占的环境中，每个线程将一直运行，直到它明确地和自愿地阻塞自己（现实世界确实有这样的操作系统，它由线程自己决定何时释放CPU。例如大名鼎鼎的Solaris操作系统）。这要求一个不能阻塞的无限循环将使该CPU在循环开始后无法用于任何其他目的，还要求还要求线程在持有自旋锁时禁止阻塞。否则会形成死锁。</p>
<p>这种方法的示意图下所示，图中的时间从顶部推移到底部，CPU 1的list_del()操作是RCU写者操作，CPU2、CPU3在读端读取list节点。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CibcLM8KpS817AhIUP9My6jtHialWk6H6ZdXfNkmuDJND71PsRmvUFy1A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>Linux经典RCU的概念即是如此。虽然这种方法在生产环境上的实现可能相当复杂，但是玩具实现却非常简单。</p>
<p>for_each_online_cpu(cpu)<br>  run_on(cpu);</p>
<p>for_each_online_cpu()原语遍历所有CPU，run_on()函数导致当前线程在指定的CPU上执行，这会强制目标CPU执行上下文切换。因此，一旦for_each_online_cpu()完成，每个CPU都执行了一次上下文切换，这又保证了所有之前存在的读线程已经完成。</p>
<p>请注意，这个方法不能用于生产环境。正确处理各种边界条件和对性能优化的强烈要求意味着用于生产环境的代码实现将十分复杂。此外，可抢占环境的RCU实现需要读者实际做点什么事情（也就是在读临界区内，禁止抢占。这是Linux经典RCU读锁的实现）。不过，这种简单的不可抢占的方法在概念上是完整的，有助于我们理解RCU的基本原理。</p>
<h3 id="2-RCU是什么？"><a href="#2-RCU是什么？" class="headerlink" title="2. RCU是什么？"></a>2. RCU是什么？</h3><p>RCU是read-copy-update的简称，翻译为中文有点别扭“读-复制-更新”。它是是一种同步机制，有三种角色或者操作：读者、写者和复制操作，我理解其中的复制操作就是不同CPU上的读者复制了不同的数据值，或者说拥有同一个指针的不同拷贝值，也可以理解为：在读者读取值的时候，写者复制并替换其内容（后一种理解来自于RCU作者的解释）。它于2002年10月引入Linux内核。</p>
<p>RCU允许读操作可以与更新操作并发执行，这一点提升了程序的可扩展性。常规的互斥锁让并发线程互斥执行，并不关心该线程是读者还是写者，而读/写锁在没有写者时允许并发的读者，相比于这些常规锁操作，RCU在维护对象的多个版本时确保读操作保持一致，同时保证只有所有当前读端临界区都执行完毕后才释放对象。RCU定义并使用了高效并且易于扩展的机制，用来发布和读取对象的新版本，还用于延后旧版本对象的垃圾收集工作。这些机制恰当地在读端和更新端并行工作，使得读端特别快速。在某些场合下（比如非抢占式内核里），RCU读端的函数完全是零开销。</p>
<p>Seqlock也可以让读者和写者并发执行，但是二者有什么区别？</p>
<p>首先是二者的目的不一样。Seqlock是为了保证读端在读取值的时候，写者没有对它进行修改，而RCU是为了多核扩展性。</p>
<p>其次是保护的数据结构大小不一样。Seqlock可以保护一组相关联的数据，而RCU只能保护指针这样的unsigned long类型的数据。</p>
<p>最重要的区别还在于效率，Seqlock本质上是与自旋锁同等重量级的原语，其效率与RCU不在同一个数量级上面。</p>
<p>下面从三个基础机制来阐述RCU究竟是什么？</p>
<p>RCU由三种基础机制构成，第一个机制用于插入，第二个用于删除，第三个用于让读者可以不受并发的插入和删除干扰。分别是：</p>
<ul>
<li>发布/订阅机制，用于插入。</li>
<li>等待已有的RCU读者完成的机制，用于删除。</li>
<li>维护对象多个版本的机制，以允许并发的插入和删除操作。</li>
</ul>
<h4 id="发布-订阅机制"><a href="#发布-订阅机制" class="headerlink" title="发布/订阅机制"></a>发布/订阅机制</h4><p>RCU的一个关键特性是可以安全的读取数据，即使数据此时正被修改。RCU通过一种发布/订阅机制达成了并发的数据插入。举个例子，假设初始值为NULL的全局指针gp现在被赋值指向一个刚分配并初始化的数据结构。如下所示的代码片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>  &#123;</span></span><br><span class="line"><span class="number">2</span>     <span class="keyword">int</span> a;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span> b;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span> c;</span><br><span class="line"><span class="number">5</span>  &#125;;</span><br><span class="line"><span class="number">6</span>  <span class="class"><span class="keyword">struct</span> <span class="title">foo</span>  *<span class="title">gp</span>  = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span>  <span class="comment">/* .  .  .  */</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span>  p =  kmalloc(<span class="keyword">sizeof</span>(*p),  GFP_KERNEL);</span><br><span class="line"><span class="number">11</span>  p-&gt;a =  <span class="number">1</span>;</span><br><span class="line"><span class="number">12</span>  p-&gt;b =  <span class="number">2</span>;</span><br><span class="line"><span class="number">13</span>  p-&gt;c =  <span class="number">3</span>;</span><br><span class="line"><span class="number">14</span>  gp  =  p;</span><br></pre></td></tr></table></figure>

<p><strong>“发布”数据结构（不安全）</strong></p>
<p>不幸的是，这块代码无法保证编译器和CPU会按照编程顺序执行最后4条赋值语句。如果对gp的赋值发生在初始化p的各字段之前，那么并发的读者会读到未初始化的值。这里需要内存屏障来保证事情按顺序发生，可是内存屏障又向来以难用而闻名。所以这里我们用一句rcu_assign_ pointer()原语将内存屏障封装起来，让其拥有发布的语义。最后4行代码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  p-&gt;a =  <span class="number">1</span>;</span><br><span class="line"><span class="number">2</span>  p-&gt;b =  <span class="number">2</span>;</span><br><span class="line"><span class="number">3</span>  p-&gt;c =  <span class="number">3</span>;</span><br><span class="line"><span class="number">4</span>  rcu_assign_pointer(gp,  p);</span><br></pre></td></tr></table></figure>

<p>rcu_assign_pointer()“发布”一个新结构，强制让编译器和CPU在为p的各字段赋值后再去为gp赋值。</p>
<p>不过，只保证更新者的执行顺序并不够，因为读者也需要保证读取顺序。请看下面这个例子中的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  p =  gp;</span><br><span class="line"><span class="number">2</span>  <span class="keyword">if</span> (p  !=  <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">3</span>     do_something_with(p-&gt;a,  p-&gt;b, p-&gt;c);</span><br><span class="line"><span class="number">4</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>这块代码看起来好像不会受到乱序执行的影响，可惜事与愿违，在DEC Alpha CPU机器上，还有启用编译器值猜测（value-speculation）优化时，会让p-&gt;a，p-&gt;b和p-&gt;c的值在p赋值之前被读取。</p>
<p>也许在启动编译器的值猜测优化时比较容易观察到这一情形，此时编译器会先猜测p-&gt;a、p-&gt;b、p-&gt;c的值，然后再去读取p的实际值来检查编译器的猜测是否正确。这种类型的优化十分激进，甚至有点疯狂，但是这确实发生在剖析驱动（profile-driven）优化的上下文中。</p>
<p>然而读者可能会说，我们一般不会使用编译器猜测优化。那么我们可以考虑DEC Alpha CPU这样的极端弱序的CPU。在这个CPU上面，引起问题的根源在于：在同一个CPU内部，使用了不止一个缓存来缓存CPU数据。这样可能使用p和p-&gt;a被分布不同一个CPU的不同缓存中，造成缓存一致性方面的问题。</p>
<p>显然，我们必须在编译器和CPU层面阻止这种危险的优化。rcu_dereference()原语用了各种内存屏障指令和编译器指令来达到这一目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  rcu_read_lock();</span><br><span class="line"><span class="number">2</span>  p =  rcu_dereference(gp);</span><br><span class="line"><span class="number">3</span>  <span class="keyword">if</span> (p  !=  <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">4</span>     do_something_with(p-&gt;a,  p-&gt;b, p-&gt;c);</span><br><span class="line"><span class="number">5</span>  &#125;</span><br><span class="line"><span class="number">6</span>  rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<p>其中rcu_read_ lock()和rcu_read_unlock()这对原语定义了RCU读端的临界区。事实上，在没有配置CONFIG_PREEMPT的内核里，这对原语就是空函数。在可抢占内核中，这这对原语就是关闭/打开抢占。</p>
<p>rcu_dereference()原语用一种“订阅”的办法获取指定指针的值。保证后续的解引用操作可以看见在对应的“发布”操作（rcu_assign_pointer()）前进行的初始化，即：在看到p的新值之前，能够看到p-&gt;a、p-&gt;b、p-&gt;c的新值。请注意，rcu_assign_pointer()和rcu_dereference()这对原语既不会自旋或者阻塞，也不会阻止list_add_ rcu()的并发执行。</p>
<p>虽然理论上rcu_assign_pointer()和rcu_derederence()可以用于构造任何能想象到的受RCU保护的数据结构，但是实践中常常只用于构建更上层的原语。例如，将rcu_assign_pointer()和rcu_dereference()原语嵌入在Linux链表的RCU变体中。Linux有两种双链表的变体，循环链表struct list_head和哈希表structhlist_head/struct hlist_node。前一种如下图所示。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CqkeScQFG8acKnfmJjmZLVRVHJicad7xpGiaEgw7y6mCEiazhQSfoYibn3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>对链表采用指针发布的例子如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">foo</span>  &#123;</span></span><br><span class="line"><span class="number">2</span>    <span class="class"><span class="keyword">struct</span>  <span class="title">list_head</span>  *<span class="title">list</span>;</span></span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span>  a;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span>  b;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span>  c;</span><br><span class="line"><span class="number">6</span>  &#125;;</span><br><span class="line"><span class="number">7</span> LIST_HEAD(head);</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="comment">/*  . .  .  */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>  p  = kmalloc(<span class="keyword">sizeof</span>(*p),  GFP_KERNEL);</span><br><span class="line"><span class="number">12</span> p-&gt;a  =  <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span> p-&gt;b  =  <span class="number">2</span>;</span><br><span class="line"><span class="number">14</span> p-&gt;c  =  <span class="number">3</span>;</span><br><span class="line"><span class="number">15</span> list_add_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;head);</span><br></pre></td></tr></table></figure>

<h4 id="RCU发布链表"><a href="#RCU发布链表" class="headerlink" title="RCU发布链表"></a>RCU发布链表</h4><p>第15行必须用某些同步机制（最常见的是各种锁）来保护，防止多核list_add()实例并发执行。不过，同步并不能阻止list_add()的实例与RCU的读者并发执行。</p>
<p>订阅一个受RCU保护的链表的代码非常直接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  rcu_read_lock();</span><br><span class="line"><span class="number">2</span>  list_for_each_entry_rcu(p,  head, <span class="built_in">list</span>)  &#123;</span><br><span class="line"><span class="number">3</span>    do_something_with(p-&gt;a,  p-&gt;b, p-&gt;c);</span><br><span class="line"><span class="number">4</span>  &#125;</span><br><span class="line"><span class="number">5</span>  rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<p>list_add_rcu()原语向指定的链表发布了一项条目，保证对应的list_for_each_ entry_rcu()可以订阅到同一项条目。</p>
<p>Linux的其他链表、哈希表都是线性链表，这意味着它的头结点只需要一个指针，而不是象循环链表那样需要两个。因此哈希表的使用可以减少哈希表的hash bucket数组一半的内存消耗。</p>
<p>向受RCU保护的哈希表发布新元素和向循环链表的操作十分类似，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">struct</span>  <span class="title">foo</span>  &#123;</span></span><br><span class="line"><span class="number">2</span>    <span class="class"><span class="keyword">struct</span>  <span class="title">hlist_node</span>  *<span class="title">list</span>;</span></span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span>  a;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span>  b;</span><br><span class="line"><span class="number">5</span>     <span class="keyword">int</span>  c;</span><br><span class="line"><span class="number">6</span>  &#125;;</span><br><span class="line"><span class="number">7</span> HLIST_HEAD(head);</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="comment">/*  . .  .  */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>  p  = kmalloc(<span class="keyword">sizeof</span>(*p),  GFP_KERNEL);</span><br><span class="line"><span class="number">12</span> p-&gt;a  =  <span class="number">1</span>;</span><br><span class="line"><span class="number">13</span> p-&gt;b  =  <span class="number">2</span>;</span><br><span class="line"><span class="number">14</span> p-&gt;c  =  <span class="number">3</span>;</span><br><span class="line"><span class="number">15</span> hlist_add_head_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;head);</span><br></pre></td></tr></table></figure>

<p>和之前一样，第15行必须用某种同步机制，比如锁来保护。订阅受RCU保护的哈希表和订阅循环链表没什么区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> rcu_read_lock();</span><br><span class="line"><span class="number">2</span> hlist_for_each_entry_rcu(p, q,  head,  <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="number">3</span>    do_something_with(p-&gt;a, p-&gt;b,  p-&gt;c);</span><br><span class="line"><span class="number">4</span>  &#125;</span><br><span class="line"><span class="number">5</span>  rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CbnHHm2R3ibOviaSz7hOGXLpOqj2Zo3Ny9Yf8gl4ZYqrSlwneO09P0WxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>请注意，list_replace_rcu()、list_del_rcu()、hlist_replace_rcu()和hlist_ del_rcu()这些API引入了一点复杂性。何时才能安全地释放刚被替换或者删除的数据元素？我们怎么能知道何时所有读者释放了他们对数据元素的引用？</p>
<p>2、等待已有的RCU读者执行完毕</p>
<p>从最基本的角度来说，RCU就是一种等待事物结束的方式。当然，有很多其他的方式可以用来等待事物结束，比如引用计数、读/写锁、事件等等。RCU的最伟大之处在于它可以等待（比如）20,000种不同的事物，而无需显式地去跟踪它们中的每一个，也无需去担心对性能的影响，对扩展性的限制，复杂的死锁场景，还有内存泄漏带来的危害等等使用显式跟踪手段会出现的问题。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CMdqUcPO5DTs2Kqw0uxrAPfDe6J6UicdOV3ItiaIiabodDJBhwbotCHyeA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>在RCU的例子中，被等待的事物称为“RCU读端临界区”。RCU读端临界区从rcu_read_lock()原语开始，到对应的rcu_read_unlock()原语结束。RCU读端临界区可以嵌套，也可以包含一大块代码，只要这其中的代码不会阻塞或者睡眠（先不考虑可睡眠RCU）。如果你遵守这些约定，就可以使用RCU去等待任何代码的完成。</p>
<p>RCU通过间接地确定这些事物何时完成，才完成了这样的壮举。</p>
<p>如上图所示，RCU是一种等待已有的RCU读端临界区执行完毕的方法，这里的执行完毕也包括在临界区里执行的内存操作。不过请注意，在某个宽限期开始后才启动的RCU读端临界区会扩展到该宽限期的结尾处。</p>
<p>下列伪代码展示了写者使用RCU等待读者的基本方法。</p>
<ul>
<li>1．作出改变，比如替换链表中的一个元素。</li>
<li>2．等待所有已有的RCU读端临界区执行完毕（比如使用synchronize_rcu()原语）。这里要注意的是后续的RCU读端临界区无法获取刚刚删除元素的引用。</li>
<li>3．清理，比如释放刚才被替换的元素。</li>
</ul>
<p>下图所示的代码片段演示了这个过程，其中字段a是搜索关键字。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">foo</span>  &#123;</span></span><br><span class="line"><span class="number">2</span>    <span class="class"><span class="keyword">struct</span>  <span class="title">list_head</span>  *<span class="title">list</span>;</span></span><br><span class="line"><span class="number">3</span>     <span class="keyword">int</span>  a;</span><br><span class="line"><span class="number">4</span>     <span class="keyword">int</span>  b;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">int</span>  c;</span><br><span class="line"><span class="number">6</span>  &#125;;</span><br><span class="line"><span class="number">7</span> LIST_HEAD(head);</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="comment">/*  . .  .  */</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>  p  = search(head,  key);</span><br><span class="line"><span class="number">12</span>  <span class="keyword">if</span>  (p ==  <span class="literal">NULL</span>)  &#123;</span><br><span class="line"><span class="number">13</span>     <span class="comment">/*  Take appropriate  action,  unlock, and</span></span><br><span class="line"><span class="comment">  return. */</span></span><br><span class="line"><span class="number">14</span>  &#125;</span><br><span class="line"><span class="number">15</span>  q  = kmalloc(<span class="keyword">sizeof</span>(*p),  GFP_KERNEL);</span><br><span class="line"><span class="number">16</span>  *q  =  *p;</span><br><span class="line"><span class="number">17</span> q-&gt;b  =  <span class="number">2</span>;</span><br><span class="line"><span class="number">18</span> q-&gt;c  =  <span class="number">3</span>;</span><br><span class="line"><span class="number">19</span> list_replace_rcu(&amp;p-&gt;<span class="built_in">list</span>, &amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="number">20</span> synchronize_rcu();</span><br><span class="line"><span class="number">21</span> kfree(p);</span><br></pre></td></tr></table></figure>

<p>第19、20和21行实现了刚才提到的三个步骤。第16至19行正如RCU其名（读-复制-更新），在允许并发读的同时，第16行复制，第17到19行更新。</p>
<p>synchronize_rcu()原语可以相当简单。然而，想要达到产品质量，代码实现必须处理一些困难的边界情况，并且还要进行大量优化，这两者都将导致明显的复杂性。理解RCU的难点，主要在于synchronize_rcu()的实现。</p>
<p>3、维护最近被更新对象的多个版本</p>
<p>下面展示RCU如何维护链表的多个版本，供并发的读者访问。通过两个例子来说明在读者还处于RCU读端临界区时，被读者引用的数据元素如何保持完整性。第一个例子展示了链表元素的删除，第二个例子展示了链表元素的替换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子1：在删除过程中维护多个版本</span></span><br><span class="line"><span class="number">1</span>  p =  search(head,  key);</span><br><span class="line"><span class="number">2</span>  <span class="keyword">if</span> (p  !=  <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">3</span>     list_del_rcu(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="number">4</span>     synchronize_rcu();</span><br><span class="line"><span class="number">5</span>     kfree(p);</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure>

<p>如下图，每个元素中的三个数字分别代表字段a、b、c的值。红色的元素表示RCU读者此时正持有该元素的引用。请注意，我们为了让图更清楚，忽略了后向指针和从尾指向头的指针。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CZa3rglOfibAmxaSickQbKevzZUvSUhDIFaQLibIrgYbvj9eMeF0RGPq4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>等第3行的list_del_rcu()执行完毕后，“5、6、7”元素从链表中被删除。因为读者不直接与更新者同步，所以读者可能还在并发地扫描链表。这些并发的读者有可能看见，也有可能看不见刚刚被删除的元素，这取决于扫描的时机。不过，刚好在取出指向被删除元素指针后被延迟的读者（比如，由于中断、ECC内存错误），就有可能在删除后还看见链表元素的旧值。因此，我们此时有两个版本的链表，一个有元素“5、6、7”，另一个没有。元素“5、6、7”用黄色标注，表明老读者可能还在引用它，但是新读者已经无法获得它的引用。</p>
<p>请注意，读者不允许在退出RCU读端临界区后还维护元素“5、6、7”的引用。因此，一旦第4行的synchronize_rcu()执行完毕，所有已有的读者都要保证已经执行完，不能再有读者引用该元素。这样我们又回到了唯一版本的链表。</p>
<p>此时，元素“5、6、7”可以安全被释放了。这样我们就完成了元素“5、6、7”的删除。</p>
<p>例子2：在替换过程中维护多个版本<br>1  q =  kmalloc(sizeof(*p),  GFP_KERNEL);<br>2  *q  =  *p;<br>3  q-&gt;b  =  2;<br>4  q-&gt;c  =  3;<br>5 list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list);<br>6 synchronize_rcu();<br>7  kfree(p);</p>
<p>链表的初始状态包括指针p都和“删除”例子中一样。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Ass1lsY6bytou4OgwWxeffVDBGZibX53CUPwibSIAu08bAmGBwPq3nUY0Kpq7xJTBxgh5tzAMJ4lXhTOOt6JQUfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p><strong>RCU从链表中替换元素</strong>  </p>
<p>和前面一样，每个元素中的三个数字分别代表字段a、b、c。红色的元素表示读者可能正在引用，并且因为读者不直接与更新者同步，所以读者有可能与整个替换过程并发执行。请注意我们为了图表的清晰，再一次忽略了后向指针和从尾指向头的指针。</p>
<p>下面描述了元素“5、2、3”如何替换元素“5、6、7”的过程，任何特定读者可能看见这两个值其中一个。</p>
<ul>
<li>第1行用kmalloc()分配了要替换的元素。此时，没有读者持有刚分配的元素的引用（用绿色表示），并且该元素是未初始化的（用问号表示）。</li>
<li>第2行将旧元素复制给新元素。新元素此时还不能被读者访问，但是已经初始化了。</li>
<li>第3行将q-&gt;b的值更新为2，第4行将q-&gt;c的值更新为3。</li>
<li>现在，第5行开始替换，这样新元素终于对读者可见了，因此颜色也变成了红色。此时，链表就有两个版本了。已经存在的老读者可能看到元素“5、6、7”（现在颜色是黄色的），而新读者将会看见元素“5、2、3”。不过这里可以保证任何读者都能看到一个完好的链表。</li>
<li>随着第6行synchronize_rcu()的返回，宽限期结束，所有在list_replace_rcu()之前开始的读者都已经完成。特别是任何可能持有元素“5、6、7”引用的读者保证已经退出了它们的RCU读端临界区，不能继续持有引用。因此，不再有任何读者持有旧数据的引用,，如第6排绿色部分所示。这样我们又回到了单一版本的链表，只是用新元素替换了旧元素。</li>
<li>等第7行的kfree()完成后，链表就成了最后一排的样子。</li>
</ul>
<p>不过尽管RCU是因替换的例子而得名的，但是RCU在内核中的主要用途还是用于简单的删除。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核同步</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>内核同步</tag>
        <tag>转载</tag>
        <tag>RCu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux虚拟文件系统（1）</title>
    <url>/p/d3c4cc3d.html</url>
    <content><![CDATA[<h1 id="VFS简介"><a href="#VFS简介" class="headerlink" title="VFS简介"></a>VFS简介</h1><p>说明：本系列文章均以Linux 4.4为原型进行分析 Linux将系统中很多资源都抽象成文件，如Socket、设备节点、以及内存。可以如此做，归功于Linux操作系统的虚拟文件系统（VFS）。 有了VFS，无论底层文件系统格式是FAT、ext格式甚至是内存，（一般情况下）上层应用无论关心底层这些文件系统的实现细节，可以按照统一的方式对文件进行操作。 ![Linux虚拟文件系统（1）](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-07-28 下午10.54.04.png “Linux虚拟文件系统（1）”) 如上图，用户态应用通过glibc提供的API对文件进行操作，如open()、read()、 write()等。Glibc将这些函数转换成Linux提供的系统调用，操作系统根据系统调用号执行对应的操作函数，如<strong>syscall_open/</strong>syscall_read/__syscall_write等。这样就走到了Linux的虚拟文件系统层（上图VFS）。 </p><a id="more"></a>
<h1 id="Linux文件系统模型"><a href="#Linux文件系统模型" class="headerlink" title="Linux文件系统模型"></a>Linux文件系统模型</h1><p>Linux VFS最重要的数据结构包括</p>
<ul>
<li><strong>SuperBlock</strong>：存储与已加载（Mount）的文件系统相关的信息</li>
<li><strong>inode</strong>：与系统中文件关联的相关信息</li>
<li><strong>dentry</strong>：文件系统目录描述符，用来关联文件系统中的目录</li>
<li><strong>file</strong>：与特定进程锁打开文件相关的结构体</li>
</ul>
<p>下图（引自&lt;<a href="http://johnchukwuma.com/training/UnderstandingTheLinuxKernel3rdEdition.pdf" target="_blank" rel="noopener">Understanding the Linux Kernel</a>&gt;）描述了这些数据结构间的关系。三个进程打开同一个文件，其中进程3通过不同的文件硬链接访问这个文件。可以看出进程打开一个文件后，通过对应的文件描述符关联了到文件对象。相同的硬链接文件，它对应的dentry对象也是相同的（虽然是同一个文件，不同硬链接的dentry对象也是不同的）。注：f_dentry目前已经由struct path <strong>f_path</strong>成员取代。不同的dentry对象最终指向的是同一个在某个超级块上的inode节点，最终指向磁盘文件。 注意到其中process 1访问对应dentry有一个dentry cache，这是Linux的一种缓存机制。可以将最近加载或者使用的dentry节点缓存到内存中，加速访问。 ![Linux虚拟文件系统（1）](<a href="http://pic.l2h.site/l2hsite图片" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite图片</a> 1.png “Linux虚拟文件系统（1）”) 下边看一下具体的数据结构。</p>
<h2 id="Super-Block"><a href="#Super-Block" class="headerlink" title="Super Block"></a>Super Block</h2><p>系统中定义了一个已经挂载的超级块的链表super_blocks（双向循环链表），用锁sb_lock保护。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// . fs/super.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(super_blocks)</span></span>;     <span class="comment">//系统中超级块全局链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(sb_lock)</span></span>;    <span class="comment">//超级块访问保护自旋锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// . include/linux/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">s_list</span>;</span>		<span class="comment">/* 超级块链表指针 */</span></span><br><span class="line">  <span class="keyword">dev_t</span>			s_dev;		<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>		s_blocksize_bits;  <span class="comment">//块大小所占用的bit数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		s_blocksize;       <span class="comment">//块大小（字节为单位）</span></span><br><span class="line">  <span class="keyword">loff_t</span>			s_maxbytes;	<span class="comment">/* 最大文件大小 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>	*<span class="title">s_type</span>;</span>   <span class="comment">//文件系统类型</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>	*<span class="title">s_op</span>;</span>     <span class="comment">//超级块操作</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>	*<span class="title">dq_op</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>	*<span class="title">s_qcop</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		s_flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		s_iflags;	<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		s_magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">s_root</span>;</span>       <span class="comment">//文件系统根目录对应的Dentry</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">s_umount</span>;</span></span><br><span class="line">  <span class="keyword">int</span>			s_count;</span><br><span class="line">  <span class="keyword">atomic_t</span>		s_active;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="keyword">void</span>                    *s_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span>	<span class="title">s_anon</span>;</span>		<span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">s_mounts</span>;</span>	<span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">  <span class="comment">//省略部分变量。。。。。</span></span><br><span class="line">  <span class="keyword">int</span> s_stack_depth;</span><br><span class="line">  <span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">  <span class="keyword">spinlock_t</span>		s_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">s_inodes</span>;</span>	<span class="comment">/* all inodes */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="title">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line">   <span class="keyword">void</span> (*destroy_inode)(struct inode *);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> (*dirty_inode) (struct inode *, <span class="keyword">int</span> flags);</span><br><span class="line"><span class="comment">//省略大部分变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="dentry"><a href="#dentry" class="headerlink" title="dentry"></a>dentry</h2><p>与目录相关的文件结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/fs/dcache.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">  <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;		<span class="comment">/* 目录项高速缓存标记protected by d_lock */</span></span><br><span class="line">  <span class="keyword">seqcount_t</span> d_seq;		<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>	<span class="comment">/* lookup hash list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>	<span class="comment">/* 指向父目录的denetry */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>           <span class="comment">/* 目录名 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>		<span class="comment">/* 目录inode节点 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];	<span class="comment">/* small names */</span></span><br><span class="line">  <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span>	<span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span>  <span class="comment">/*存在与dentry相关的操作函数*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>	<span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;		<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">  <span class="keyword">void</span> *d_fsdata;			<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>		<span class="comment">/* LRU list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>	<span class="comment">/* child of parent list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>	<span class="comment">/* our children */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>	<span class="comment">/* inode alias list */</span></span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">  &#125; d_u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> dentry_d_lock_class</span><br><span class="line">&#123;</span><br><span class="line">  DENTRY_D_LOCK_NORMAL, </span><br><span class="line">  DENTRY_D_LOCK_NESTED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> (*d_revalidate)(struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*d_weak_revalidate)(struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*d_hash)(<span class="keyword">const</span> struct dentry *, struct qstr *);</span><br><span class="line">  <span class="keyword">int</span> (*d_compare)(<span class="keyword">const</span> struct dentry *, <span class="keyword">const</span> struct dentry *,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> struct qstr *);</span><br><span class="line">  <span class="keyword">int</span> (*d_delete)(<span class="keyword">const</span> struct dentry *);</span><br><span class="line">  <span class="keyword">void</span> (*d_release)(struct dentry *);</span><br><span class="line">  <span class="keyword">void</span> (*d_prune)(struct dentry *);</span><br><span class="line">  <span class="keyword">void</span> (*d_iput)(struct dentry *, struct inode *);</span><br><span class="line">  <span class="keyword">char</span> *(*d_dname)(struct dentry *, <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *(*<span class="title">d_automount</span>)(<span class="title">struct</span> <span class="title">path</span> *);</span></span><br><span class="line">  <span class="keyword">int</span> (*d_manage)(struct dentry *, <span class="keyword">bool</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">d_select_inode</span>)(<span class="title">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span>);</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">d_real</span>)(<span class="title">struct</span> <span class="title">dentry</span> *, <span class="title">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  <span class="keyword">umode_t</span>			i_mode;     <span class="comment">//文件类型与访问权限</span></span><br><span class="line">  <span class="keyword">unsigned</span> short		i_opflags; </span><br><span class="line">  <span class="keyword">kuid_t</span>			i_uid; <span class="comment">//所有者标识</span></span><br><span class="line">  <span class="keyword">kgid_t</span>			i_gid; <span class="comment">//组标识</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		i_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_acl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>	*<span class="title">i_op</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	*<span class="title">i_sb</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">i_mapping</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="keyword">void</span>			*i_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		i_ino;    <span class="comment">//索引节点号</span></span><br><span class="line">  <span class="keyword">union</span> &#123;                         <span class="comment">//Hard Link数量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">dev_t</span>			i_rdev;</span><br><span class="line">  <span class="keyword">loff_t</span>			i_size;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>		<span class="title">i_atime</span>;</span>i_mtime; i_ctime; <span class="comment">//文件的访问时间等</span></span><br><span class="line">  <span class="keyword">spinlock_t</span>		i_lock;	<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short          i_bytes;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>		i_blkbits;</span><br><span class="line">  <span class="keyword">blkcnt_t</span>		i_blocks;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">  <span class="keyword">seqcount_t</span>		i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Misc */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		i_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">i_mutex</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_when;	<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_time_when;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">i_hash</span>;</span>           <span class="comment">//Inode Hash指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_io_list</span>;</span>	<span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>	*<span class="title">i_wb</span>;</span>		<span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">  <span class="keyword">int</span>			i_wb_frn_winner;</span><br><span class="line">  u16			i_wb_frn_avg_time;</span><br><span class="line">  u16			i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_lru</span>;</span>		<span class="comment">/* inode LRU list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_sb_list</span>;</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">i_dentry</span>;</span>       <span class="comment">//引用索引节点的dentry链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">i_rcu</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  u64			i_version;</span><br><span class="line">  <span class="keyword">atomic_t</span>		i_count;</span><br><span class="line">  <span class="keyword">atomic_t</span>		i_dio_count;</span><br><span class="line">  <span class="keyword">atomic_t</span>		i_writecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">  <span class="keyword">atomic_t</span>		i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">i_fop</span>;</span>	<span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>	*<span class="title">i_flctx</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	<span class="title">i_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_devices</span>;</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">i_bdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">    <span class="keyword">char</span>			*i_link;</span><br><span class="line">  &#125;;</span><br><span class="line">  __u32			i_generation;  <span class="comment">//索引节点版本号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">  __u32			i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>			*i_private; <span class="comment">/* fs or device private pointer */</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="title">struct</span> <span class="title">inode</span> *,<span class="title">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * (*follow_link) (struct dentry *, <span class="keyword">void</span> **);</span><br><span class="line">	<span class="keyword">int</span> (*permission) (struct inode *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="title">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*readlink) (struct dentry *, <span class="keyword">char</span> __user *,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span> (*put_link) (struct inode *, <span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*create) (struct inode *,struct dentry *, <span class="keyword">umode_t</span>, <span class="keyword">bool</span>);</span><br><span class="line">	<span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">mkdir</span>) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">rmdir</span>) (struct inode *,struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*mknod) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>,<span class="keyword">dev_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*rename) (struct inode *, struct dentry *,</span><br><span class="line">			struct inode *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*rename2) (struct inode *, struct dentry *,</span><br><span class="line">			struct inode *, struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setattr) (struct dentry *, struct iattr *);</span><br><span class="line">	<span class="keyword">int</span> (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</span><br><span class="line">	<span class="keyword">int</span> (*setxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">size_t</span>,<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*getxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*listxattr) (struct dentry *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*removexattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">	<span class="keyword">int</span> (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,</span><br><span class="line">		      u64 len);</span><br><span class="line">	<span class="keyword">int</span> (*update_time)(struct inode *, struct timespec *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*atomic_open)(struct inode *, struct dentry *,</span><br><span class="line">			   struct file *, <span class="keyword">unsigned</span> open_flag,</span><br><span class="line">			   <span class="keyword">umode_t</span> create_mode, <span class="keyword">int</span> *opened);</span><br><span class="line">	<span class="keyword">int</span> (*tmpfile) (struct inode *, struct dentry *, <span class="keyword">umode_t</span>);</span><br><span class="line">	<span class="keyword">int</span> (*set_acl)(struct inode *, struct posix_acl *, <span class="keyword">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br></pre></td></tr></table></figure>

<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">  &#125; f_u;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">spinlock_t</span>		f_lock;</span><br><span class="line">  <span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags;</span><br><span class="line">  <span class="keyword">fmode_t</span>			f_mode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">  <span class="keyword">loff_t</span>			f_pos;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">  u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">  <span class="keyword">void</span>			*private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">  <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_handle</span> &#123;</span></span><br><span class="line">  __u32 handle_bytes;</span><br><span class="line">  <span class="keyword">int</span> handle_type;</span><br><span class="line">  <span class="comment">/* file identifier */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> f_handle[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">flush</span>) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">	<span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">	<span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">			  <span class="keyword">loff_t</span> len);</span><br><span class="line">	<span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一张图说明这几个VFS重要结构体的指向关系 <img src="http://pic.l2h.site/l2hsitevfs_struct_relation2.png" alt="Linux虚拟文件系统（1）" title="Linux虚拟文件系统（1）"></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VFS</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux虚拟文件系统（2）-- 初始化流程</title>
    <url>/p/91ca183b.html</url>
    <content><![CDATA[<p>本文介绍Linux虚拟文件系统的初始化过程。如下图:</p><p>+—–&gt; start_kernel()<br>|<br>|<br>+—–&gt; vfs_caches_init_early()<br>|<br>|<br>+—–&gt; vfs_caches_init()<br>|                        +—&gt;new thread(kernel_init)<br>|                        |       +<br>|                        |       |<br>+—–&gt; rest_init()+——       v<br>                           kernel_init_freeable<br>                                 +<br>                                 |<br>                                 v<br>                             do_basic_setup<br>                                 +<br>                                 |<br>                                 v<br>                           prepare_namespace</p><a id="more"></a>

<p>在Linux kernel的入口函数start_kernel中，系统调用vfs_caches_init_early和vfs_caches_init进行必要的初始化。</p>
<h1 id="vfs-caches-init-early"><a href="#vfs-caches-init-early" class="headerlink" title="vfs_caches_init_early"></a>vfs_caches_init_early</h1><p>Dentry和inode cache是linux为了加速对虚拟文件系统管理，在内存中分配的的hash Cache，用来存放最近访问的inode或dentry节点。 一般而言，最近访问的节点也是最容易被再次访问的。当要访问inode或dentry节点时，先到内存中的cache查找（Hash链表）。如果可以找到，便可以直接使用内存中的节点，否则才到文件系统中去找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">dcache_init_early</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If hashes are distributed across NUMA nodes, defer</span></span><br><span class="line"><span class="comment">   * hash allocation until vmalloc space is available.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (hashdist)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  dentry_hashtable =</span><br><span class="line">    alloc_large_system_hash(<span class="string">"Dentry cache"</span>,</span><br><span class="line">          <span class="keyword">sizeof</span>(struct hlist_bl_head),</span><br><span class="line">          dhash_entries,</span><br><span class="line">          <span class="number">13</span>,</span><br><span class="line">          HASH_EARLY,</span><br><span class="line">          &amp;d_hash_shift,</span><br><span class="line">          &amp;d_hash_mask,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; d_hash_shift); loop++)</span><br><span class="line">    INIT_HLIST_BL_HEAD(dentry_hashtable + loop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">inode_init_early</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line">	<span class="keyword">if</span> (hashdist)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	inode_hashtable =</span><br><span class="line">		alloc_large_system_hash(<span class="string">"Inode-cache"</span>,</span><br><span class="line">					<span class="keyword">sizeof</span>(struct hlist_head),</span><br><span class="line">					ihash_entries,</span><br><span class="line">					<span class="number">14</span>,</span><br><span class="line">					HASH_EARLY,</span><br><span class="line">					&amp;i_hash_shift,</span><br><span class="line">					&amp;i_hash_mask,</span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; i_hash_shift); loop++)</span><br><span class="line">		INIT_HLIST_HEAD(&amp;inode_hashtable[loop]);</span><br><span class="line">&#125;</span><br><span class="line">```C</span><br><span class="line">上述代码可以看出，vfs_caches_init_early创建了inode和dentry cache的hash链表，但是这里并没有分配dentry和inode的cache（vfs_caches_init中才会创建）。Hash 链表的结构如下图所示。</span><br><span class="line"></span><br><span class="line">![Linux虚拟文件系统（<span class="number">2</span>）-- 初始化流程](http:<span class="comment">//pic.l2h.site/l2hsitehlist.png "Linux虚拟文件系统（2）-- 初始化流程")vfs_caches_init</span></span><br><span class="line">=========================================================================================================</span><br><span class="line"></span><br><span class="line">相较于vfs_caches_init_early, vfs_caches_init则会做更多的事情。如下代码</span><br><span class="line">```C</span><br><span class="line"><span class="keyword">void</span> __init vfs_caches_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  names_cachep = kmem_cache_create(<span class="string">"names_cache"</span>, PATH_MAX, <span class="number">0</span>,</span><br><span class="line">      SLAB_HWCACHE_ALIGN|SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  dcache_init();   <span class="comment">//初始化dentry cache，此时才会创建cache</span></span><br><span class="line">  inode_init();    <span class="comment">//类上</span></span><br><span class="line">  files_init();    <span class="comment">//初始化文件cache</span></span><br><span class="line">  files_maxfiles_init(); <span class="comment">//初始化系统最大文件数</span></span><br><span class="line">  mnt_init();      <span class="comment">// 初始化文件系统挂载相关资源并挂载特殊文件系统</span></span><br><span class="line">  bdev_cache_init(); <span class="comment">//初始化块设备管理伪文件系统</span></span><br><span class="line">  chrdev_init();   <span class="comment">//初始化字符设备相关</span></span><br><span class="line">&#125;</span><br><span class="line">```C</span><br><span class="line">_dcache_init/inode_init_: 初始化dentry和inode cache，如果没有创建对应的哈希链表，就创建之（前边vfs_caches_init_early已经创建） _files_init_: 根据当前系统内存计算最大文件数</span><br><span class="line"></span><br><span class="line">n = ((totalram_pages - memreserve) * (PAGE_SIZE / <span class="number">1024</span>)) / <span class="number">10</span>;</span><br><span class="line">files_stat.max_files = <span class="keyword">max_t</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>, n, NR_FILE);</span><br><span class="line"></span><br><span class="line">_mnt_init_：与文件系统mount相关的初始化。细节流程如下：</span><br></pre></td></tr></table></figure>

<p>+———————-+<br>| Create MNT cache and |<br>| MNT cache Hash table |<br>+———–+———-+<br>            |<br>+———–v———-+    +———————+<br>| Create Mount Point   |    | init mount tree     |<br>| Hash Table           |    |                     |<br>+———–+———-+    +———-^———-+<br>            |                          |<br>+———–v———-+    +———-+———-+<br>| kernfs_init()        |    | init_rootfs()       |<br>|                      |    |                     |<br>+———–+———-+    +———-^———-+<br>            |                          |<br>+———–v———-+    +———-+———-+<br>| sysfs_init()         +–&gt; | Register FS folder  |<br>|                      |    | to sysfs            |<br>+———————-+    +———————+</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，创建struct mount cache及哈希链表，之后创建文件系统加载点（struct mountpoint）Cache Hash。 其中前者为系统中已经Mount的VFS相关信息（包含不同VFS Mount的相互关系），后者主要存放的是系统加载点Dentry。 _kernfs_init_：主要创建kernfs_node的cache。kernfs_node主要为创建kernfs结构的结构体。kernfs的作用引用wiki如下：</span><br><span class="line"></span><br><span class="line">&gt; In the Linux kernel, **kernfs** is a set of functions that contain the functionality required for creating pseudo file systems used internally by various kernel subsystems. The creation of kernfs resulted from splitting off part of the internal logic used by sysfs, which provides a set of virtual files by exporting information about hardware devices and associated device drivers from the kernel&apos;s device model to user space, into an independent and reusable functionality so other kernel subsystems can implement their own pseudo file systems more easily and consistently</span><br><span class="line"></span><br><span class="line">_sysfs_init_：初始化sysfs，并向系统中注册该文件系统。sysfs.txt(Documentation/zh_CN/filesystems/sysfs.txt)对sysfs的简介如下：</span><br><span class="line"></span><br><span class="line">&gt; sysfs 是一个最初基于 ramfs 且位于内存的文件系统。它提供导出内核 数据结构及其属性，以及它们之间的关联到用户空间的方法。sysfs 目录的安排显示了内核数据结构之间的关系。顶层 sysfs 目录如下: block/ bus/ class/ dev/ devices/ firmware/ net/ fs/</span><br><span class="line"></span><br><span class="line">紧接着注册fs目录到sysfs(fs_kobj = kobject_create_and_add(&quot;fs&quot;, NULL);)，即构成sysfs顶级目录的fs目录。 _init_rootfs()_: 主要向系统中注册rootfs与tmpfs文件系统，以及执行Mount</span><br><span class="line">```C</span><br><span class="line">static struct file_system_type rootfs_fs_type = &#123;</span><br><span class="line">  .name		= &quot;rootfs&quot;,</span><br><span class="line">  .mount		= rootfs_mount,</span><br><span class="line">  .kill_sb	= kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line">int __init init_rootfs(void)</span><br><span class="line">&#123;</span><br><span class="line">  int err = register_filesystem(&amp;rootfs_fs_type);//注册rootfs到文件系统。注意如果kernel启动的cmd line如果传入了 &quot;root=xxx&quot;，此处便执行不到</span><br><span class="line">  if (err) return err;</span><br><span class="line">  if (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[0] &amp;&amp;  //如果kernel config打开CONFIG_TMPFS</span><br><span class="line">    (!root_fs_names || strstr(root_fs_names, &quot;tmpfs&quot;))) &#123; // 如果cmd line没有传入rootfs的类型，便执行shmem 的初始化</span><br><span class="line">    err = shmem_init();      //执行shmem_init</span><br><span class="line">    is_tmpfs = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    err = init_ramfs_fs();  //注册ramfs</span><br><span class="line">  &#125;</span><br><span class="line">  if (err) unregister_filesystem(&amp;rootfs_fs_type);</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line">static struct file_system_type shmem_fs_type = &#123;</span><br><span class="line">  .owner		= THIS_MODULE,</span><br><span class="line">  .name		= &quot;tmpfs&quot;,</span><br><span class="line">  .mount		= shmem_mount,  </span><br><span class="line">  .kill_sb	= kill_litter_super,</span><br><span class="line">  .fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line">int __init shmem_init(void)</span><br><span class="line">&#123;</span><br><span class="line">  int error;</span><br><span class="line">  /* If rootfs called this, don&apos;t re-init */</span><br><span class="line">  if (shmem_inode_cachep) return 0;</span><br><span class="line">  error = shmem_init_inodecache();  //初始化shmem的inode cache</span><br><span class="line">  if (error) goto out3;</span><br><span class="line"></span><br><span class="line">  error = register_filesystem(&amp;shmem_fs_type); //注册tmpfs文件系统</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    printk(KERN_ERR &quot;Could not register tmpfs\\n&quot;);</span><br><span class="line">    goto out2;</span><br><span class="line">  &#125;</span><br><span class="line">  shm_mnt = kern_mount(&amp;shmem_fs_type);  //执行shmem的mount调用</span><br><span class="line">  if (IS_ERR(shm_mnt)) &#123;</span><br><span class="line">    error = PTR_ERR(shm_mnt);</span><br><span class="line">    printk(KERN_ERR &quot;Could not kern_mount tmpfs\\n&quot;);</span><br><span class="line">    goto out1;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">out1:</span><br><span class="line">  unregister_filesystem(&amp;shmem_fs_type);</span><br><span class="line">out2:</span><br><span class="line">  shmem_destroy_inodecache();</span><br><span class="line">out3:</span><br><span class="line">  shm_mnt = ERR_PTR(error);</span><br><span class="line">  return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后的文章会介绍shmem的mount，shmem_mount <em>init_mount_tree()</em>: 如其名，初始化文件系统挂载树。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_mount_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">  type = get_fs_type(<span class="string">"rootfs"</span>); <span class="comment">//获取已注册到kernel中的rootfs</span></span><br><span class="line">  <span class="keyword">if</span> (!type)</span><br><span class="line">    panic(<span class="string">"Can't find rootfs type"</span>); <span class="comment">//前方init_rootfs已经向系统注册rootfs，若此处找不到，视为异常</span></span><br><span class="line">  mnt = vfs_kern_mount(type, <span class="number">0</span>, <span class="string">"rootfs"</span>, <span class="literal">NULL</span>); <span class="comment">//挂载rootfs，其中会执行对应rootfs的mount callback，具体下一篇文章介绍</span></span><br><span class="line">  put_filesystem(type);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">    panic(<span class="string">"Can't create rootfs"</span>);</span><br><span class="line"></span><br><span class="line">  ns = create_mnt_ns(mnt);     <span class="comment">//创建mnt命名空间，并将rootfs加入到对应命名空间，作为命名空间的root</span></span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(ns))</span><br><span class="line">    panic(<span class="string">"Can't allocate initial namespace"</span>);</span><br><span class="line"></span><br><span class="line">  init_task.nsproxy-&gt;mnt_ns = ns;</span><br><span class="line">  get_mnt_ns(ns);</span><br><span class="line">  root.mnt = mnt;</span><br><span class="line">  root.dentry = mnt-&gt;mnt_root;</span><br><span class="line">  mnt-&gt;mnt_flags |= MNT_LOCKED;</span><br><span class="line">  set_fs_pwd(current-&gt;fs, &amp;root);   <span class="comment">//设定init进程的当前目录为挂载点的主目录</span></span><br><span class="line">  set_fs_root(current-&gt;fs, &amp;root);  <span class="comment">//设定init进程的root为挂载点的主目录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，vfs_caches_init初始化流程结束</p>
<h1 id="do-basic-setup"><a href="#do-basic-setup" class="headerlink" title="do_basic_setup"></a>do_basic_setup</h1><p>在rest_init函数中，kernel创建kernel_init线程，该线程会执行do_basic_setup。其执行do_initcalls–&gt;rootfs_initcall(populate_rootfs);–&gt;rootfs_initcall( default_rootfs);    populate_rootfs主要是将打包在initramfs中的cpio档填充到rootfs，而default_rootfs主要创建/dev，/dev/console和/root</p>
<h1 id="prepare-namespace"><a href="#prepare-namespace" class="headerlink" title="prepare_namespace"></a>prepare_namespace</h1><p>当/sbin/init 或者 init不存在时，便执行prepare_namespace。其主要作用也能够便是挂载MTD device或UBI device到root。这里引用<a href="https://www.ibm.com/developerworks/cn/linux/l-initrd.html" target="_blank" rel="noopener">IBM developworkers</a>的说明对prepare_namespace作介绍如下：</p>
<blockquote>
<p>在内核和 initrd 映像被解压并拷贝到内存中之后，内核就会被调用了。它会执行不同的初始化操作，最终您会发现自己到了 <code>init/main.c:init()</code>（subdir/file:function）函数中。这个函数执行了大量的子系统初始化操作。此处会执行一个对 <code>init/do_mounts.c:prepare_namespace()</code> 的调用，这个函数用来准备名称空间（挂载 dev 文件系统、RAID 或 md、设备以及最后的 initrd）。加载 initrd 是通过调用 <code>init/do_mounts_initrd.c:initrd_load()</code> 实现的。 <code>initrd_load()</code> 函数调用了 <code>init/do_mounts_rd.c:rd_load_image()</code>，它通过调用 <code>init/do_mounts_rd.c:identify_ramdisk_image()</code> 来确定要加载哪个 RAM 磁盘。这个函数会检查映像文件的 magic 号来确定它是 minux、etc2、romfs、cramfs 或 gzip 格式。在返回到 <code>initrd_load_image</code> 之前，它还会调用 <code>init/do_mounts_rd:crd_load()</code>。这个函数负责为 RAM 磁盘分配空间，并计算循环冗余校验码（CRC），然后对 RAM 磁盘映像进行解压，并将其加载到内存中。现在，我们在一个适合挂载的块设备中就有了这个 initrd 映像。 现在使用一个 <code>init/do_mounts.c:mount_root()</code> 调用将这个块设备挂载到根文件系统上。它会创建根设备，并调用 <code>init/do_mounts.c:mount_block_root()</code>。在这里调用 <code>init/do_mounts.c:do_mount_root()</code>，后者又会调用 <code>fs/namespace.c:sys_mount()</code> 来真正挂载根文件系统，然后 <code>chdir</code> 到这个文件系统中。这就是我们在清单 6 中所看到的熟悉消息 <code>VFS: Mounted root (ext2 file system).</code> 的地方。 最后，返回到 <code>init</code> 函数中，并调用 <code>init/main.c:run_init_process</code>。这会导致调用 <code>execve</code> 来启动 init 进程（在本例中是 <code>/linuxrc</code>）。linuxrc 可以是一个可执行程序，也可以是一个脚本（条件是它有脚本解释器可用）。这些函数的调用层次结构如下边清单所示。尽管此处并没有列出拷贝和挂载初始 RAM 磁盘所涉及的所有函数，但是这足以为我们提供一个整体流程的粗略框架</p>
<p>init/main.c:init()<br>  init/do_mounts.c:prepare_namespace()<br>    init/do_mounts_initrd.c:initrd_load()<br>      init/do_mounts_rd.c:rd_load_image()<br>        init/do_mounts_rd.c:identify_ramdisk_image()<br>        init/do_mounts_rd.c:crd_load()<br>          lib/inflate.c:gunzip()<br>    init/do_mounts.c:mount_root()<br>      init/do_mounts.c:mount_block_root()<br>         init/do_mounts.c:do_mount_root()<br>           fs/namespace.c:sys_mount()<br>  init/main.c:run_init_process()<br>    execve</p>
</blockquote>
<p>引用Kernel中的README The kernel has currently 3 ways to mount the root filesystem: a) all required device and filesystem drivers compiled into the kernel, no initrd. init/main.c:init() will call prepare_namespace() to mount the final root filesystem, based on the root= option and optional init= to run some other init binary than listed at the end of init/main.c:init(). b) some device and filesystem drivers built as modules and stored in an initrd. The initrd must contain a binary ‘/linuxrc’ which is supposed to load these driver modules. It is also possible to mount the final root filesystem via linuxrc and use the pivot_root syscall. The initrd is mounted and executed via prepare_namespace(). c) using initramfs. The call to prepare_namespace() must be skipped. This means that a binary must do all the work. Said binary can be stored into initramfs either via modifying usr/gen_init_cpio.c or via the new initrd format, an cpio archive. It must be called “/init”. This binary is responsible to do all the things prepare_namespace() would do. To maintain backwards compatibility, the /init binary will only run if it comes via an initramfs cpio archive. If this is not the case, init/main.c:init() will run prepare_namespace() to mount the final root and exec one of the predefined init binaries.</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VFS</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux虚拟文件系统（3）-- VFS系统调用之Mount</title>
    <url>/p/49330c35.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前2章分别介绍了VFS的基本数据结构和初始化流程。本章介绍VFS文件系统的使用。文件系统使用大多是从应用层系统调用开始的，下表是对文件系统系统调用的一个整理。</p><h1 id><a href="#" class="headerlink" title></a><img src="http://pic.l2h.site/l2hsitevfs-syscalls.png" alt="Linux虚拟文件系统（3）-- VFS系统调用" title="Linux虚拟文件系统（3）-- VFS系统调用"></h1><h1 id="MOUNT"><a href="#MOUNT" class="headerlink" title="MOUNT"></a>MOUNT</h1><p>文件系统可以使用的前提是系统挂载(Mount)成功。初始化过程中，Linux会预先挂载一些支撑系统运行的特殊文件系统，例如，sysfs、rootfs、tmpfs等。本节先介绍初始化过程中Kernel对rootfs和sysfs文件系统的直接挂载，接着以一个典型的文件系统类型（待补充）介绍在用户空间态做挂载后内核的执行流程。</p><a id="more"></a>

<h2 id="初始化过程中文件系统挂载"><a href="#初始化过程中文件系统挂载" class="headerlink" title="初始化过程中文件系统挂载"></a>初始化过程中文件系统挂载</h2><h3 id="rootfs-挂载"><a href="#rootfs-挂载" class="headerlink" title="rootfs 挂载"></a>rootfs 挂载</h3><p>前一篇文章中我们看到系统初始化过程中挂载了rootfs，即根文件系统(/)。这里我们看一下rootfs挂载的细节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">init_mount_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">  mnt = vfs_kern_mount(type, <span class="number">0</span>, <span class="string">"rootfs"</span>, <span class="literal">NULL</span>); <span class="comment">//挂载rootfs，其中会执行对应rootfs的mount callback</span></span><br><span class="line">  put_filesystem(type);</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">    panic(<span class="string">"Can't create rootfs"</span>);</span><br><span class="line"></span><br><span class="line">  ns = create_mnt_ns(mnt);     <span class="comment">//创建mnt命名空间，并将rootfs加入到对应命名空间，作为命名空间的root</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *</span></span><br><span class="line"><span class="class"><span class="title">vfs_kern_mount</span>(<span class="title">struct</span> <span class="title">file_system_type</span> *<span class="title">type</span>, <span class="title">int</span> <span class="title">flags</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">void</span> *<span class="title">data</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line">  mnt = alloc_vfsmnt(name);                         <span class="comment">//分配VFS Mount</span></span><br><span class="line">  <span class="keyword">if</span> (!mnt)</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; MS_KERNMOUNT)                         <span class="comment">//如果是kern_mount，做内部Mount标记</span></span><br><span class="line">    mnt-&gt;mnt.mnt_flags = MNT_INTERNAL;</span><br><span class="line"></span><br><span class="line">  root = mount_fs(type, flags, name, data);        <span class="comment">//真正执行fs的挂载</span></span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(root)) &#123;</span><br><span class="line">    mnt_free_id(mnt);free_vfsmnt(mnt); <span class="keyword">return</span> ERR_CAST(root); <span class="comment">//如果Mount失败，就作清理</span></span><br><span class="line">  &#125;</span><br><span class="line">  mnt-&gt;mnt.mnt_root = root;mnt-&gt;mnt.mnt_sb = root-&gt;d_sb;mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;mnt-&gt;mnt_parent = mnt;  <span class="comment">//挂载成功后，对vfsmount数据结构进行必要的赋值</span></span><br><span class="line">  </span><br><span class="line">  lock_mount_hash(); list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;root-&gt;d_sb-&gt;s_mounts);   unlock_mount_hash(); <span class="comment">//将新分配的VFS mount加入到root的mount列表</span></span><br><span class="line">  <span class="keyword">return</span> &amp;mnt-&gt;mnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *</span></span><br><span class="line"><span class="class"><span class="title">mount_fs</span>(<span class="title">struct</span> <span class="title">file_system_type</span> *<span class="title">type</span>, <span class="title">int</span> <span class="title">flags</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">void</span> *<span class="title">data</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span> </span><br><span class="line">        <span class="keyword">char</span> *secdata = <span class="literal">NULL</span>;<span class="keyword">int</span> error = -ENOMEM;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  root = type-&gt;mount(type, flags, name, data); <span class="comment">//执行mount函数进行mount，这里执行的是rootfs_mount</span></span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(root)) &#123;error = PTR_ERR(root); <span class="keyword">goto</span> out_free_secdata; &#125;</span><br><span class="line">  sb = root-&gt;d_sb;  BUG_ON(!sb);  WARN_ON(!sb-&gt;s_bdi);</span><br><span class="line">  sb-&gt;s_flags |= MS_BORN;</span><br><span class="line">  </span><br><span class="line">   error = security_sb_kern_mount(sb, flags, secdata);</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">goto</span> out_sb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">rootfs_mount</span><span class="params">(struct file_system_type *fs_type, <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> once;</span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">fill</span> = ramfs_fill_super;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; is_tmpfs) <span class="comment">//当CONFIG_TMPFS打开，使用shmem相关函数进行挂载和超级块填充，否则使用ramfs相关函数进行挂载和超级块填充</span></span><br><span class="line">		<span class="built_in">fill</span> = shmem_fill_super;</span><br><span class="line">	<span class="keyword">return</span> mount_nodev(fs_type, flags, data, <span class="built_in">fill</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_nodev</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> flags, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">       <span class="comment">//根据filesystem 类别获取超级块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">s</span> = <span class="title">sget</span>(<span class="title">fs_type</span>, <span class="title">NULL</span>, <span class="title">set_anon_super</span>, <span class="title">flags</span>, <span class="title">NULL</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(s))</span><br><span class="line">		<span class="keyword">return</span> ERR_CAST(s);</span><br><span class="line"></span><br><span class="line">	error = fill_super(s, data, flags &amp; MS_SILENT ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">//执行fill_super函数，即ramfs_fill_super或者shmem_fill_super</span></span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		deactivate_locked_super(s);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_flags |= MS_ACTIVE;</span><br><span class="line">	<span class="keyword">return</span> dget(s-&gt;s_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里以shmem_fill_super为例，会为rootfs分配shmem 类型超级块的私有结构并进行填充，同时分配Inode以及Dentry，用来构建所有文件系统树的根目录(即’/‘)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmem_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  sbinfo = kzalloc(<span class="built_in">max</span>((<span class="keyword">int</span>)<span class="keyword">sizeof</span>(struct shmem_sb_info),L1_CACHE_BYTES), GFP_KERNEL); </span><br><span class="line">  sbinfo-&gt;mode = S_IRWXUGO | S_ISVTX;</span><br><span class="line">  sbinfo-&gt;uid = current_fsuid();</span><br><span class="line">  sbinfo-&gt;gid = current_fsgid();</span><br><span class="line">  sb-&gt;s_fs_info = sbinfo;</span><br><span class="line">  <span class="comment">//以上分配shmem 超级块的私有信息结构并做必要初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!(sb-&gt;s_flags &amp; MS_KERNMOUNT)) &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  spin_lock_init(&amp;sbinfo-&gt;stat_lock);</span><br><span class="line">  <span class="keyword">if</span> (percpu_counter_init(&amp;sbinfo-&gt;used_blocks, <span class="number">0</span>, GFP_KERNEL))</span><br><span class="line">    <span class="keyword">goto</span> failed;</span><br><span class="line">  sbinfo-&gt;free_inodes = sbinfo-&gt;max_inodes;</span><br><span class="line">  sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">  sb-&gt;s_blocksize = PAGE_CACHE_SIZE;</span><br><span class="line">  sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;</span><br><span class="line">  sb-&gt;s_magic = TMPFS_MAGIC;</span><br><span class="line">  sb-&gt;s_op = &amp;shmem_ops;</span><br><span class="line">  sb-&gt;s_time_gran = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//超级块初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//从shmem初始化的cache中获取inode（作为/对应的inode）</span></span><br><span class="line">  inode = shmem_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | sbinfo-&gt;mode, <span class="number">0</span>, VM_NORESERVE); </span><br><span class="line">  inode-&gt;i_uid = sbinfo-&gt;uid;</span><br><span class="line">  inode-&gt;i_gid = sbinfo-&gt;gid;</span><br><span class="line">  <span class="comment">//设定超级块的root dentry（作为/对应的dentry）</span></span><br><span class="line">  sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shmem_fill_super可以直接分配shmem_inode cache，是因为初始化流程init_rootfs()中，已经执行了如下shmem的初始化（参考<a href="http://www.l2h.site/linux-vfs-2/" target="_blank" rel="noopener">Linux虚拟文件系统（2）– 初始化流程</a> ）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shmem_init()</span><br><span class="line">    |</span><br><span class="line">    +--&gt;shmem_init_inodecache()</span><br><span class="line">    |</span><br><span class="line">    +--&gt;register_filesystem(&amp;shmem_fs_type)</span><br><span class="line">    |</span><br><span class="line">    +--&gt;kern_mount(&amp;shmem_fs_type)</span><br><span class="line">         |</span><br><span class="line">         +-----&gt;vfs_kern_mount()</span><br><span class="line">                  |</span><br><span class="line">                  +---&gt;alloc_vfsmnt(name)</span><br><span class="line">                  |</span><br><span class="line">                  +---&gt;mount_fs(type, flags, name, data);</span><br><span class="line">                          |</span><br><span class="line">                          +----&gt;type-&gt;mount(type, flags, name, data)</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                               shmem_mount()</span><br></pre></td></tr></table></figure>

<h3 id="sysfs挂载"><a href="#sysfs挂载" class="headerlink" title="sysfs挂载"></a>sysfs挂载</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">sysfs_fs_type</span> = &#123;</span></span><br><span class="line">  .name		= <span class="string">"sysfs"</span>,</span><br><span class="line">  .mount		= sysfs_mount,</span><br><span class="line">  .kill_sb	= sysfs_kill_sb,</span><br><span class="line">  .fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">sysfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  sysfs_root = kernfs_create_root(<span class="literal">NULL</span>, KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK,<span class="literal">NULL</span>); <span class="comment">//创建sysfs的根目录</span></span><br><span class="line">  sysfs_root_kn = sysfs_root-&gt;kn;</span><br><span class="line">  err = register_filesystem(&amp;sysfs_fs_type);<span class="comment">//向系统注册sysfs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上过程在rootfs_init初始化过程中执行，主要为向系统中注册sysfs sysfs_mount主要做以下事情：</p>
<ol>
<li><blockquote>
<p>分配kernfs_kern_info</p>
</blockquote>
</li>
<li><blockquote>
<p>为sysfs分配superblock</p>
</blockquote>
</li>
<li><blockquote>
<p>调用kernfs_fill_super来填充超级块</p>
</blockquote>
</li>
</ol>
<h2 id="用户空间态一般文件系统挂载"><a href="#用户空间态一般文件系统挂载" class="headerlink" title="用户空间态一般文件系统挂载"></a>用户空间态一般文件系统挂载</h2><p>在用户空间态执行系统挂载的命令如下：</p>
<blockquote>
<p>mount [-t vfstype] [-o options] device dir</p>
</blockquote>
<p>其中-t参数表示您要挂载的文件系统类型，-o为可选参数，device代表您要挂载的设备（可以是一个设备文件，也可以一个二级制文件系统包）， dir表示文件系统要挂载到的目录。 假设用户（注意必须是root组用户才有权限执行）在根目录/执行如下挂载命令</p>
<blockquote>
<p>mount -t yaffs rawfs.bin ./test</p>
</blockquote>
<p>系统会执行系统调用，从用户空间态切换到内核态，并执行mount命令对应的系统调用sys_mount。从sys_mount开始，调用执行如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mount, <span class="keyword">char</span> __user *, dev_name, <span class="keyword">char</span> __user *, dir_name, <span class="keyword">char</span> __user *, type, <span class="keyword">unsigned</span> <span class="keyword">long</span>, flags, <span class="keyword">void</span> __user *, data)</span><br><span class="line">--&gt;kernel_type =copy_mount_string(type); <span class="comment">//从user space拷贝mount的vfs 类型</span></span><br><span class="line">--&gt;kernel_dev =copy_mount_string(dev_name); <span class="comment">//从user space拷贝设备名</span></span><br><span class="line">--&gt;copy_mount_options(data, &amp;data_page); <span class="comment">//从user space拷贝mount参数</span></span><br><span class="line">--&gt;do_mount(kernel_dev, dir_name, kernel_type, flags,(<span class="keyword">void</span> *) data_page); <span class="comment">//执行mount</span></span><br><span class="line">   --&gt; <span class="comment">//查找挂载点，这里会涉及到VFS操作时最常见的path_walk，之后章节会重点介绍</span></span><br><span class="line">   --&gt; <span class="comment">//执行必要的挂载flag设定</span></span><br><span class="line">   --&gt; <span class="comment">//检查挂载类型，根据挂载类型决定执行do_remount(),do_new_mount()，do_move_mount()或者其他</span></span><br></pre></td></tr></table></figure>

<p>因为上边的挂载命令是执行新的挂载，因此，这里执行到的是do_new_mount</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">--&gt;type = get_fs_type(fstype); <span class="comment">//根据传入的文件系统名，从已经加载到系统的文件系统链表中查找到对应的文件系统struct file_system_type，如果对应的文件系统模块没有加载到系统，此处会尝试加载。</span></span><br><span class="line">--&gt;mnt = vfs_kern_mount(type, flags, name, data); <span class="comment">//执行vfs_kern_mount,参见上一节“rootfs挂载”的介绍。</span></span><br></pre></td></tr></table></figure>

<p>vfs_kern_mount的流程与rootfs挂载中执行类似。此处差异只在于yaffs的type-&gt;mount(type, flags, name, data)执行的是yaffs的do_mount函数，<strong>之后会开专门的章节介绍yaffs</strong>。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VFS</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux虚拟文件系统（4）-- 路径名查找</title>
    <url>/p/90e06139.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>几乎所有Linux的文件操作，例，read、write、mkdir等都会涉及到路径名查找操作。而文件查找对Linux内核来说，主要指的是找到文件路径对应的Dentry节点。其主要过程就是对路径字符串进行一级级解析（以路径名中的.. , . , /等字符作为解析依据），找到路径的最后一级目录。若传入的路径字符串是以/开始的，那么查找会从系统根目录开始。否则，从当前工作目录开始查找。 <img src="http://pic.l2h.site/l2hsitevfs-4-find.jpeg" alt="Linux虚拟文件系统（4）-- 路径名查找" title="Linux虚拟文件系统（4）-- 路径名查找"> 然而，查找过程并非仅仅是对路径名一级级解析和匹配，其中还要考虑到如下细节：</p><a id="more"></a>
<ul>
<li>用户可能对要查找的路径没有访问权限</li>
<li>路径名查找是系统中频繁且常见的操作，如何保证查找的效率</li>
<li>多个进程 or 用户会同时操作到同一个路径，查找过程中需要做必要的保护</li>
<li>查找过程中可能经过符号链接，同时还要考虑避免符号链接的循环引用，造成无限查找</li>
<li>查找过程可能会跨越多个文件系统类别</li>
<li>…….</li>
</ul>
<p>引用内核文档对VFS路径查找的介绍：</p>
<blockquote>
<p>The most obvious aspect of pathname lookup, which very little exploration is needed to discover, is that it is complex.  There are many rules, special cases, and implementation alternatives that all combine to confuse the unwary reader.</p>
</blockquote>
<p><a href="http://www.l2h.site/linux-vfs-3/" target="_blank" rel="noopener">上篇文章</a>中介绍了Mount系统调用，其中do_mount函数会进行文件系统挂载点的查找，代码如下：</p>
<p>long do_mount(const char <em>dev_name, const char __user *dir_name,<br>const char *type_page, unsigned long flags, void *data_page)<br>{<br>……..<br>/</em> … and get the mountpoint */<br>retval = user_path(dir_name, &amp;path)<br>……..<br>}</p>
<p>user_path()函数传入要查找的路径名，返回struct path结构体类型供后续使用。user_path()最终会调用到filename_lookup(),执行文件查找工作。本章就对filename_lookup()函数进行深入剖析（以Linux 4.4内核为基础）。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>与路径查找相关的数据结构是struct nameidata，其具体字段及主要作用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span>              <span class="comment">//记录路径查找的结果</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span>                <span class="comment">//路径名最后一个分量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span>              <span class="comment">//路径查找的根目录信息，可能会在查找开始时由调用者传入</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>    *<span class="title">inode</span>;</span> <span class="comment">/* path.dentry.d_inode */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;       <span class="comment">//路径名查找标志</span></span><br><span class="line">    <span class="keyword">unsigned</span>    seq, m_seq; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span>     last_type;               <span class="comment">//记录当前查找到目录的类别Normal/Dot/DotDot/Root/Bind</span></span><br><span class="line">    <span class="keyword">unsigned</span>    depth;          <span class="comment">//查找过程中跨越的符号链接深度</span></span><br><span class="line">    <span class="keyword">int</span>     total_link_count;    <span class="comment">//查找过程中经过的符号链接总数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">link</span>;</span></span><br><span class="line">        <span class="keyword">void</span> *cookie;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> seq; </span><br><span class="line">    &#125; *<span class="built_in">stack</span>, internal[EMBEDDED_LEVELS]; <span class="comment">//用来记录查找过程中碰到的符号链接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">name</span>;</span>    <span class="comment">//</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">saved</span>;</span><span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span>    root_seq;      <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span>     dfd;                        <span class="comment">//</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="filename-lookup"><a href="#filename-lookup" class="headerlink" title="filename_lookup"></a>filename_lookup</h1><p>函数filename_lookup解析如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">filename_lookup</span><span class="params">(<span class="keyword">int</span> dfd, struct filename *name, <span class="keyword">unsigned</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct path *path, struct path *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(name);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(root)) &#123;</span><br><span class="line">        nd.root = *root;</span><br><span class="line">        flags |= LOOKUP_ROOT;</span><br><span class="line">    &#125;</span><br><span class="line">    set_nameidata(&amp;nd, dfd, name);</span><br><span class="line">    retval = path_lookupat(&amp;nd, flags | LOOKUP_RCU, path);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ECHILD))</span><br><span class="line">        retval = path_lookupat(&amp;nd, flags, path);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ESTALE))</span><br><span class="line">        retval = path_lookupat(&amp;nd, flags | LOOKUP_REVAL, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!retval))</span><br><span class="line">        audit_inode(name, path-&gt;dentry, flags &amp; LOOKUP_PARENT);</span><br><span class="line">    restore_nameidata();</span><br><span class="line">    putname(name);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kernel路径名查找的方式有两种：</p>
<ul>
<li>REF-Walk方式：指的是路径查找过程中，使用Spinlock（dentryàd_lock）并发使用或者修改目录项，来保证系统最终目录项内容的正确性。但是Spinlock因为会引发阻塞，所以效率会低于RCU-Walk.Kernel路径名查找的方式有两种：</li>
<li>RCU-Walk方式：采用RCU锁的方式进行查找，并发查找过程中并不会因为等待spinlock而阻塞，因此速度相对更快。但是它并不能保证所有情况下都能查找成功</li>
</ul>
<p>filename_lookup函数首先初始化上文介绍的nameidata结构体，接着进行RCU方式查找指定路径。若RCU查找失败，则退回传统的查找方式（REF-Walk）。正因为Linux路径查找穿插了两种查找方式的代码，所以读起来比较困难。本文接下来试图将两种查找方式分开进行介绍。</p>
<h1 id="REF-Walk"><a href="#REF-Walk" class="headerlink" title="REF-Walk"></a>REF-Walk</h1><p>path_lookupat主要代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">path_lookupat</span><span class="params">(struct nameidata *nd, <span class="keyword">unsigned</span> flags, struct path *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s = path_init(nd, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(err = link_path_walk(s, nd))</span><br><span class="line">        &amp;&amp; ((err = lookup_last(nd)) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        s = trailing_symlink(nd);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(s)) &#123;</span><br><span class="line">            err = PTR_ERR(s);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = complete_walk(nd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; nd-&gt;flags &amp; LOOKUP_DIRECTORY)</span><br><span class="line">        <span class="keyword">if</span> (!d_can_lookup(nd-&gt;path.dentry))</span><br><span class="line">            err = -ENOTDIR;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        *path = nd-&gt;path;</span><br><span class="line">        nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">        nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    terminate_walk(nd);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先path_init对nameidata做必要的初始赋值并返回路径字符串:</p>
<ul>
<li>如果执行路径查找函数的函数传入了root参数，那么会置起LOOKUP_ROOT标志，此时会对当前用户的对应root目录访问权限进行检查，若不允许，则返回错误。</li>
<li>如果未置起LOOKUP_ROOT，则判断路径名查找从根目录，当前目录或者对应文件描述符对应的目录开始查找，并修改nameidata的path字段，最后修改nameidata的inode字段作为查找起始点的inode。</li>
</ul>
<p>其次循环执行link_path_walk()，做真正的路径查找，直到碰到查找错误或者查找结束。接下来一节深入剖析。 之后执行complete_walk()，主要为再次确认要访问的dentry是否仍然有效（这取决于对应dentry的文件系统的d_weak_revalidate函数，一般情况下为NULL，且对REF-WALK模式来讲不会被调用到）。 最后执行terminate_walk()前，将nameidata的查找结果（即path）赋值给调用者传入的参数。而terminate_walk()则会将对路径的引用释放，同时将查找过程中跨越的符号链接引用释放掉并将nameidata的深度置为0。</p>
<h2 id="link-path-walk"><a href="#link-path-walk" class="headerlink" title="link_path_walk"></a>link_path_walk</h2><p>link_path_walk()首先跳过路径名中的斜杠/，接下来执行其核心：一个for循环。主要做如下事情：</p>
<ol>
<li>检查当前要查找目录是否有查找的权限（当前目录对应inode是否有EXEC权限），若没有则退出查找。</li>
<li>对当前查找目录计算其Hash长度</li>
<li>若当前查找目录为”..”，则置起来LOOKUP_JUMP标记，表示查找跳过该目录。否则开始路径查找walk_component()</li>
<li>若第三步查找返回为0，则进行下一路径分量的查找（Walk componet过程中会修改nameidata的path以及last等字段）</li>
<li>若第三步查找返回不为0且不为负数，则表示查找过程中碰到符号链接，修改符号链接对应节点的访问时间等信息，并将相关信息记录在nameidata的stack字段。</li>
<li>重新开始执行for循环，直到路径遍历结束（关键变量name为NULL）</li>
</ol>
<h2 id="walk-component"><a href="#walk-component" class="headerlink" title="walk_component"></a>walk_component</h2><p>walk_component主要做如下事情：</p>
<ol>
<li>处理点符号（即.或者..），这里主要处理的是..返回上一级目录，这里要特别处理的是上级目录可能与当前在两个不同的系统挂载点上。</li>
<li>若当前要查找的路径是普通路径，则进行路径的快查找lookup_fast，其会执行dentry = __d_lookup(parent, &amp;nd-&gt;last)，即从dentry高速缓存中查找。</li>
<li>若第2步查找失败则进行慢查找lookup_slow()，其调用__lookup_hash进行查找，这会执行lookup_real到对应文件系统的i_op到磁盘上去进行查找。</li>
<li>判断查找到的目录分量是否是符号链接，若是符号链接，则看当前遍历的符号链接数量是否超过系统中允许的最大数量（避免循环遍历），如超过则返回错误。否则，在nameidata中的stack字段为当前遍历到的符号链接分配空间并做相应赋值。注意，nameidata字段默认已经预留了储存符号链接的stack空间，只有当遍历过程经过的符号链接超过数量时，才需要重新分配。</li>
<li>将查找的目录分量信息记录在nameidata里，供下个查找循环使用</li>
</ol>
<h1 id="RCU-Walk"><a href="#RCU-Walk" class="headerlink" title="RCU-Walk"></a>RCU-Walk</h1><p>待添加</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>VFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac Mojave修改屏幕主题色</title>
    <url>/p/adc608f3.html</url>
    <content><![CDATA[<p>刚刚给Mac更新了系统，发现多了一项功能，即修改屏幕主题色。有浅色和深色两种选择。深色的还蛮酷的。修改方法：</p>
<blockquote>
<p>系统偏好设置-&gt;通用-&gt;外观</p>
</blockquote>
<p>选择你喜欢的主题色即可</p>
<p><img src="http://pic.l2h.site/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2019-08-13-%E4%B8%8B%E5%8D%884.57.03.png" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>MAC OS本地安装PyTorch</title>
    <url>/p/1ab046.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>PyTorchs是基于Python的机器学习操作库，他可以利用GPU的资源来进行复杂的<a href="https://www.l2h.site/category/machine-learning/" target="_blank" rel="noopener">深度学习</a>运算。</p><p><img src="http://pic.l2h.site/PyTorch.jpg" alt="pytorch"></p><p>如果需要充分利用Pytorch的CUDA支持，需要电脑上有NVIDIA GPU。不过本人电脑是Macbook Air，没有这样的条件。且入门学习实验，希望使用CPU支持即可。</p><p>官网上说明，Mac OS如果要使用CUDA支持，需要源代码编译PyTorch：</p><a id="more"></a>



<blockquote>
<p>Currently, CUDA support on macOS is only available by <a href="https://pytorch.org/get-started/locally/#mac-from-source" target="_blank" rel="noopener">building PyTorch from source</a></p>
</blockquote>
<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><h3 id="macOS-版本"><a href="#macOS-版本" class="headerlink" title="macOS 版本"></a>macOS 版本</h3><p>Mac OS 10.10 (Yosemite) or 更高</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Mac OS is 默认安装的Python 2.7. 一般建议使用Python 3.6或更高版本，这样与PyTorch搭配更好（官方称Python 2.7 也可使用）。Python 3.6可以使用Anaconda 或者Homebrew包管理器安装，或者从Python官网安装 </p>
<h2 id="Anaconda包管理器的安装"><a href="#Anaconda包管理器的安装" class="headerlink" title="Anaconda包管理器的安装"></a>Anaconda包管理器的安装</h2><p>打开Mac OS的终端，执行如下命令即可：</p>
<blockquote>
<p>$curl -O <a href="https://repo.anaconda.com/archive/Anaconda3-5.2.0-MacOSX-x86_64.sh" target="_blank" rel="noopener">https://repo.anaconda.com/archive/Anaconda3-5.2.0-MacOSX-x86_64.sh</a><br>$sudo sh Anaconda3-5.2.0-MacOSX-x86_64.sh</p>
</blockquote>
<p>安装后，可以在终端输入如下命令验证：</p>
<blockquote>
<p>$which python<br>/Users/xh/anaconda3/bin/python</p>
<p>$ python –version<br>Python 3.6.5 :: Anaconda, Inc.</p>
</blockquote>
<h2 id="安装PyTorch"><a href="#安装PyTorch" class="headerlink" title="安装PyTorch"></a>安装PyTorch</h2><p>使用Anaconda安装PyTorch也非常简单：</p>
<pre><code>conda install pytorch torchvision -c pytorch</code></pre><h2 id="验证PyTorch安装"><a href="#验证PyTorch安装" class="headerlink" title="验证PyTorch安装"></a>验证PyTorch安装</h2><p>可将如下代码保存为test.py文件，执行python test.py进行验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>执行后输出类似于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tensor([[<span class="number">0.3380</span>, <span class="number">0.3845</span>, <span class="number">0.3217</span>],</span><br><span class="line">        [<span class="number">0.8337</span>, <span class="number">0.9050</span>, <span class="number">0.2650</span>],</span><br><span class="line">        [<span class="number">0.2979</span>, <span class="number">0.7141</span>, <span class="number">0.9069</span>],</span><br><span class="line">        [<span class="number">0.1449</span>, <span class="number">0.1132</span>, <span class="number">0.1375</span>],</span><br><span class="line">        [<span class="number">0.4675</span>, <span class="number">0.3947</span>, <span class="number">0.1426</span>]]</span><br></pre></td></tr></table></figure>

<p>至此，安装结束。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC OS使用SCP命令进行SSH文件传输</title>
    <url>/p/672e2cb6.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>建站，进行文件传输是必不可少的。而本人又不希望给服务器开太多的服务端口，因此是拒绝FTP的。而一直知道SSH服务器支持文件传输，为何不复用该端口的服务进行呢？经过搜索，发现MAC OS下可以用SCP命令和服务器进行文件双向传输。</p><p><img src="http://pic.l2h.site/scp_command-1024x353.png" alt></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="上传文件到服务器"><a href="#上传文件到服务器" class="headerlink" title="上传文件到服务器"></a>上传文件到服务器</h3><blockquote>
<p><strong><em>scp</em></strong> /path/filename username@servername:/path/  </p>
</blockquote><a id="more"></a>


<ul>
<li><strong>/path/filename</strong>: 本地文件目录</li>
<li><strong>username</strong>: 在远端服务器的用户名</li>
<li><strong>servername</strong>：服务器域名或者ip地址</li>
<li><strong>/path/</strong>：远端服务器的目录（即要上传到的位置）</li>
</ul>
<p>回车后，会要求您输入远端用户的密码，输入密码后便开始上传</p>
<h3 id="上传目录到服务器"><a href="#上传目录到服务器" class="headerlink" title="上传目录到服务器"></a>上传目录到服务器</h3><blockquote>
<p><strong><em>scp</em></strong> <em>-r</em> local_dir username@servername:remote_dir  </p>
</blockquote>
<p>与上传文件的差异在于_<strong>-r</strong>_参数</p>
<h3 id="从服务器下载文件"><a href="#从服务器下载文件" class="headerlink" title="从服务器下载文件"></a>从服务器下载文件</h3><blockquote>
<p><strong><em>scp</em></strong> username@servername:/path/filename local_dir  </p>
</blockquote>
<ul>
<li><strong>local_dir</strong>：本地目录</li>
<li><strong>/path/filename</strong>：远端文件</li>
</ul>
<h3 id="从服务器下载目录"><a href="#从服务器下载目录" class="headerlink" title="从服务器下载目录"></a>从服务器下载目录</h3><blockquote>
<p><strong><em>scp</em></strong> -r username@servername:remote_dir local_dir  </p>
</blockquote>
<p>同样，与下载普通文件的差异只在于_<strong>-r</strong>_参数</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本节简单介绍了MAC下使用SSH（SCP）进行最常用的上传、下载的方法。SCP的具体参数以及更多用法可以在shell下使用 man scp命令查看。希望对您有所帮助</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>MAC OS</tag>
        <tag>SSH</tag>
        <tag>文件传输</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络和深度学习(1)</title>
    <url>/p/b787e173.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>机器学习，神经网络，已经不算前言的名词、未来的趋势。未来大部分的工作都可能会被机器所取代，这不是危言耸听。秉承着不能被机器淘汰的思想，必须了解到机器到底在学习什么，怎么能学习。本系列文算是个人对机器学习的一个笔记，加上自己的一些总结和变化。记录的过程即是加深学习的过程，希望可以今年内将这个系列学习完，也希望对访问博客的朋友们有所帮助。本文大部分内容引用、整理或翻译自<a href="http://michaelnielsen.org/" target="_blank" rel="noopener">Michael Nielsen</a>的《<a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> 》，已征得原作者许可，转载此文请先与我联系。作者原声明如下：</p><a id="more"></a>
<blockquote>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_GB" target="_blank" rel="noopener">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>. This means you’re free to copy, share, and build on this book, but not to sell it. If you’re interested in<br>commercial use, please <a href="mailto:mn@michaelnielsen.org" target="_blank" rel="noopener">contact me</a>.</p>
</blockquote>
<p><img src="http://pic.l2h.site/Machine-Learning-Book.jpg" alt></p>
<p>本文主要内容包含：</p>
<ul>
<li>神经网络： 一个从生物学得到启发的漂亮的编程方法，让电脑可以从可观察的数据中进行学习</li>
<li>深度学习：运用神经网络机型学习的极为有效的技术体系</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>神经网络和深度学习在处理图像识别、音频识别以及自然语言处理问题时能提供最佳的解决方案。 例如：人类可以很轻易地识别如下手写数字序列（基本上算是很直觉地识别出）。但是对计算机来讲，却是很复杂的事情，且无法运用人类的识别方式。</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/digits.png" alt></p>
<p>Fig 1. 手写字体</p>
<p>一般来说计算机识别步骤为：</p>
<ul>
<li>准备一系列已知的手写数据范例（如下图），称为训练数据</li>
<li>创造一个识别系统，从这些手写数据范例中归纳出识别的模式。</li>
</ul>
<p><img src="http://neuralnetworksanddeeplearning.com/images/mnist_100_digits.png" alt></p>
<p>Fig 2. 手写字体范例</p>
<h3 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h3><p>感知器是神经网络的基本结构，而神经网络正是参照了人类神经系统的特性构造起来的，其基本单元为_感知器_。要了解感知器，先看一张人类神经元的结构图。</p>
<p><img src="http://pic.l2h.site/Nueral-Cell-1024x768.jpeg" alt></p>
<p>Fig 3. 神经元</p>
<p>神经元的解释如下（来自<a href="https://baike.baidu.com/item/%E7%A5%9E%E7%BB%8F%E5%85%83/674777?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）：</p>
<blockquote>
<p>神经细胞是神经系统最基本的结构和功能单位。分为细胞体和突起两部分。细胞体由细胞核、细胞膜、细胞质组成，具有联络和整合输入信息并传出信息的作用。突起有树突和轴突两种。树突短而分枝多，直接由细胞体扩张突出，形成树枝状，其作用是<strong>接受其他神经元轴突传来的冲动并传给细胞体</strong>。轴突长而分枝少，为粗细均匀的细长突起，常起于轴丘，<strong>其作用是接受外来刺激，再由细胞体传出</strong>。</p>
</blockquote>
<p>可见，其主要作用就是接受其他神经元的刺激，并传导到其他神经元。可以理解为神经元为多输入输出的一个基本单元。神经网络中的感知器工作原理也类同，如下图：它接受其他感知器的输出作为输入，乘上一定的权值加总后得到一个值。用函数$$f$$对该加总值进行处理，得到输出$$O$$。这个输出值是一个二元值，0或1，类比表示神经元是否产生输出刺激。公式如下：</p>
<p>$$ \begin{eqnarray} \mbox{output} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \sum_j w_j x_j \leq \mbox{ threshold} \\ 1 &amp; \mbox{if } \sum_j w_j x_j &gt; \mbox{ threshold} \end{array} \right. \tag{1}\end{eqnarray} $$</p>
<p>令 $$ b = \mbox{-threshold} $$，即有：</p>
<p>$$ \begin{eqnarray} \mbox{output} &amp; = &amp; \left\{ \begin{array}{ll} 0 &amp; \mbox{if } \sum_j w_j x_j +b\leq \mbox{0} \\ 1 &amp; \mbox{if } \sum_j w_j x_j+b &gt; \mbox{ 0} \end{array} \right. \tag{2}\end{eqnarray} $$</p>
<p>如何理解上述公式？通常人类要做一件事情的时候，一定会有很多条件的输入。每个条件都有一定的优先级，综合考虑每个条件之后，做出最后的判断。例如：老王想要决定晚上出不出去健身，影响他判断的条件可能有晚上会不会加班、今天天冷不冷、昨天有没有建过身等。</p>
<p>在机器学习中，这些输入条件即可用$$x_1$$到$$x_i$$表示，而每个条件对做出最后决策的影响成都即 $$w_1$$到$$w_i$$ 。这些数据的加总和通常不会是1或者0这样的结果，因此无法直接用来判断输出的结果。通常，上述公式感知器会将该加总和与阈值threshold进行比较。如果大于阈值则输出1，反之则输出0。</p>
<p><img src="http://pic.l2h.site/neural-network-1-1.jpeg" alt></p>
<p>Fig 4. Perceptron(感知器)</p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>神经网络即由上述感知器作为神经元的网络（如Fig 5）。其基本组成为：</p>
<ul>
<li>感知器：即下图每一个小圆，神经网络的“神经元”</li>
<li>输入层：由N个感知器组成的层次（N为输入条件的个数）</li>
<li>输出层：有M个感知器组成的层次，（N为机器学习问题输出值的个数。对手写数字识别来讲，即有10种可能输出，即输出层由10个感知器组成）</li>
<li>多个隐层（Hidden Layer）： 非输入层也非输出层的中间层。可以为0个或者多个。</li>
<li>层与层连线上的参数 ，即感知器的权值 $$ w_{ij} $$ 和Threshold $$ b $$</li>
</ul>
<p>输入层和输出层中感知器的数量、隐层及其所包含感知器的数量，取决于要解决的机器学习问题。往往这些数量以及 $$ w_{ij} $$ 等变量初始值的选择，也决定着机器学习的效率以及效果，之后会再探讨。</p>
<p><img src="http://pic.l2h.site/neural-network-1-2.jpg" alt></p>
<p>Fig 5. Neural Network(神经网络)</p>
<p>机器学习的过程，就是通过训练数据，反推出神经网络层与层之间<strong>所有</strong>的权值<br>$$ w_{ij} $$ 与阈值 $$ b $$ ，直到所有检验数据达到需要的精准度。</p>
<h3 id="Sigmoid神经元"><a href="#Sigmoid神经元" class="headerlink" title="Sigmoid神经元"></a>Sigmoid神经元</h3><p><strong>感知器</strong>一节提到的函数，只是简单地从输入端加权值减去阈值的结果来判断输出。<br>例，当_水温能达到28_度，今天就会出去游泳;又或，当_小黑心情不好时_，就睡觉。 这样的作法很直觉，也比较符合我们的思考习惯。这种函数，非0即1，不够平滑，函数输出值随着输入的跳变较大。如下图， 当$$ \sum_j w_j x_j +b\ $$超过0之后，输出就会直接跳变为1。这样造成的结果是，输入中的某一个权值轻微变化，造成输出结果发生剧变。</p>
<p><img src="http://pic.l2h.site/perceptron-func-0.png" alt></p>
<p>Fig 6. 函数(2)的图形</p>
<p>而机器学习的过程，希望的是输入值的变化对输出值的变化不要产生过大的变动。即上述函数的变化较为平滑。而Sigmoid函数正式这样的函数，它的公式如下：</p>
<p>$$f\equiv\frac{1}{1+e^{-{(W \bullet X-b)}}} \tag{3} $$</p>
<p>而该函数对应的几何图如下：</p>
<p><img src="http://pic.l2h.site/perceptron-func-1.png" alt></p>
<p>Fig 7. Sigmoid函数的图形</p>
<p>从图上可以看出，因为输出值为平滑的0到1曲线，不会出现因为 $$ \sum_j w_j x_j +b\ $$ 的变化出现明显的跳变（输入的较小改变，得到的也是最终输出结果较小的变化），是较为理想的感知器函数。其数学公式如下：</p>
<p>$$ \begin{eqnarray} \Delta \mbox{output} \approx \sum_j \frac{\partial \, \mbox{output}}{\partial w_j} \Delta w_j + \frac{\partial \, \mbox{output}}{\partial b} \Delta b, \tag{5} \end{eqnarray} $$</p>
<p>即，使用Sigmoid函数的导数是一个线性的函数，随着输入参数的变化，output的值是线性增长的。</p>
<blockquote>
<p>有同学要问了，神经网络要解决的是一个是非题，但Sigmoid函数并非如此怎么办？</p>
<p>可以以0.5作为分界线，当Sigmoid的结果为0.5以上时，即认为最终的决策结果为“是”，反之为“否”</p>
</blockquote>
<h2 id="识别手写数字实战"><a href="#识别手写数字实战" class="headerlink" title="识别手写数字实战"></a>识别手写数字实战</h2><p>带着前面神经网络的基础知识，再回来看开篇提到的课题：识别手写数字。再看下边这张图：</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/digits.png" alt></p>
<p>首先将问题分解：</p>
<ol>
<li>将上述图片分割为6个独立的数字</li>
<li>对6个独立的数字分别进行识别</li>
</ol>
<p><img src="http://neuralnetworksanddeeplearning.com/images/digits_separate.png" alt></p>
<p>图片分解</p>
<p>问题一像是如何识别图片边界的问题，对计算机来讲也比较复杂。不过本文暂时先考虑如何编程来解决问题2。</p>
<p>为了解决这个问题，定义一个三层神经网络：输入层包含784个神经元；中间隐层包含15个神经元；而输出层则为10个神经元分别代表数字0~9。</p>
<ul>
<li>输入层$$784=28*28$$，表示每个被分割出来的数字有28乘28个像素点组成。每个像素点值表示颜色深度：0值表示该像素位置为白色，1则表示黑色，0到1的中间数字表示介于黑白之间像素点的灰黑色深度。</li>
<li>隐层神经元个数的选择对学习效率是有影响的（事实上，如何选择这些初始值也是非常值得研究的课题）。本文从15作为初始选择，后边实例将会观察不同隐层神经元个数对学习结果的影响。</li>
<li>输出层则比较直觉，10个输出代表我们要识别的数字的10中可能。我们当然可以采用其他个数的神经元组合。例如：神经元代表每个二进制位的值，这样只需要4个神经元就能表示0<del>16的值。但事实上，这样的选择效果往往不会非常的理想。试想，1</del>10这10个数字的图片形状各不相同，如何用八个形状（4个bit*每个bit 2个值）来归纳这十个数字？</li>
</ul>
<p><img src="http://neuralnetworksanddeeplearning.com/images/tikz12.png" alt></p>
<p>当然，本文采用的选择仅仅为一个启发而并非强制性的。或许有更好的参数，能进行更好更快的识别。</p>
<h3 id="梯度下降法学习"><a href="#梯度下降法学习" class="headerlink" title="梯度下降法学习"></a>梯度下降法学习</h3><p>前一节我们简单建立了用于学习的神经网络模型，接着需要有用于学习的数据集。<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST</a>收集了成千上万人的手写数字扫描数据，包含60000个训练数据以及10000个测试数据，均已被大小归一化乘28*28像素大小且居中对其。数据文件包括：</p>
<ul>
<li>train-images-idx3-ubyte: 训练集图片 </li>
<li>train-labels-idx1-ubyte: 训练集标签 </li>
<li>t10k-images-idx3-ubyte:  测试集图片 </li>
<li>t10k-labels-idx1-ubyte:  测试集标签</li>
</ul>
<p>图片文件格式如下：</p>
<p><strong>偏移</strong></p>
<p><strong>类型</strong></p>
<p><strong>数值</strong></p>
<p><strong>描述</strong></p>
<p>0000</p>
<p>32位整形</p>
<p>0x00000803(2051</p>
<p>MAGIC Number（魔数）</p>
<p>0004</p>
<p>32位整形</p>
<p>60000 或 10000</p>
<p>图片个数</p>
<p>0008</p>
<p>32位整形</p>
<p>28</p>
<p>像素行数</p>
<p>0012    </p>
<p>32位整形</p>
<p>28</p>
<p>像素列数</p>
<p>0016 </p>
<p>无符号字节</p>
<p>？</p>
<p>像素点</p>
<p>0017   </p>
<p>无符号字节</p>
<p>？</p>
<p>像素点</p>
<p>…….. </p>
<p>无符号字节</p>
<p>？</p>
<p>像素点</p>
<p>xxxx  </p>
<p>无符号字节</p>
<p>？</p>
<p>像素点</p>
<p>标签文件格式如下：</p>
<p><strong>偏移</strong></p>
<p><strong>类型</strong></p>
<p><strong>数值</strong></p>
<p>描述</p>
<p>0000</p>
<p>32位整形</p>
<p>0x00000801(2049</p>
<p>MAGIC Number（魔数）</p>
<p>0004</p>
<p>32位整形</p>
<p>60000</p>
<p>图片个数</p>
<p>0008</p>
<p>无符号字节</p>
<p>？</p>
<p>标签值（0-9）</p>
<p>0009</p>
<p>无符号字节</p>
<p>？</p>
<p>标签值（0-9）</p>
<p>…….. </p>
<p>无符号字节</p>
<p>？</p>
<p>标签值（0-9）</p>
<p>xxxx  </p>
<p>无符号字节</p>
<p>？</p>
<p>标签值（0-9）</p>
<p>本文使用$$x$$代表输入数据，它是一个28*28维向量。使用$$y=y(x)$$代表输出，其中$$y$$为10维向量。例，若输入图形$$x$$的输出结果为6，则用$$y(x)=(0,0,0,0,0,1,0,0,0,0)^T$$表示。</p>
<p>我们的目标就是找到所有权值及阈值，使得输出结果与所有的训练数据接近。我们可以定义如下误差函数：</p>
<p>$$\begin{eqnarray} C(w,b) \equiv \frac{1}{2n} \sum_x \| y(x) - a\|^2 \nonumber\end{eqnarray}$$</p>
<p>$$w$$表示网络中的所有权重，$$b$$代表所有的阈值，$$n$$表示训练数据总量，$$a$$则是$$x$$作为训练数据时的输出结果向量。那么该误差函数$$C(w,b)$$表示的就是目标函数输出与实际训练数据结果的均方误差，<em>mean squared error</em> or just(<em>MSE</em>)。当目标函数与输出结果接近时，$$C(w,b) \approx 0$$。因此我们的目标便是对所有训练数据，使得目标函数结果与训练数据的输出接近（当然最好是相等，XD）。接下来就该梯度下降算法出场了。</p>
<p>介绍梯度下降算法前，先思考一个问题：为什么我们的误差函数是均方误差，而不使用训练数据正确的个数？会这样考虑的原因是：用数量作为误差函数，并非平滑函数。即，对权值或者阈值微小修改并不会对正确数量产生大的变化。这样的话很难对权重或者阈值修正来得到机器学习效果的提升。而如果我们采用较为平滑的误差函数，则能通过对权重或者阈值的变化得到提升。</p>
<p>这里又有疑问了：虽然是要用较平滑的函数作为误差函数，为什么一定要是均方误差函数？当然不必，之后文章会再研究是否有其他选择。但是对了解神经网络基础来讲，这个均方误差函数便已足够。</p>
<p>如前所述，我们训练的目标，是求出可以使得误差函数最小的所有的权值和阈值，而我们将会使用梯度下降算法。为了对这一算法进行阐述，我们先简化一下我们的问题：另我们的输入只有两个像素点，对应两个权值$$v_1和v_2$$，接着我们可以对应扩展到多个权值或阈值的场景。</p>
<p>如前所述，我们训练的目标，是求出可以使得误差函数最小的所有的权值和阈值，而我们将会使用梯度下降算法。为了对这一算法进行阐述，我们先简化一下我们的问题：另我们的输入只有两个像素点，对应两个权值$$v_1和v_2$$，接着我们可以对应扩展到多个权值或阈值的场景。</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/valley.png" alt></p>
<p>全局最小</p>
<p>对上图来讲，我们可以一眼大概看出C的全局最小的值，得到对应的$$v_1和v_2$$。但是事实上，C往往是一个复杂的函数包含了许多参数，也不可能一眼就看出其最小值。而解决此类问题（求C最小值）的一种分析方法就是微积分: 我们可以通过求导来找到使C达到最小的点。当C函数参数较少的时候，或许可以幸运地的找到。但是当参数更多时，这种方法便成了噩梦。不幸的是，往往我们的神经网络中有多得多的参数–最大的神经网络可能会有成千上万个权重和阈值要求出，是不可能用微积分得到最小值的。</p>
<p>不过不要担心，幸运的是我们可以用其他算法来做这件事并得到很好的效果。首先我们把误差函数的看作一个山谷（就如上图一样），想象有一个球从斜坡滚向山谷。根据日常经验，这个球最终会滚向谷底。那么或许我们可以用这种方法来找到函数的最小值？可以随机选择一个起始点，并模拟球向山谷滚动的运动。我们可以通过对C求导（或者有时是二次导数）来做这样的模拟，并得到“山谷的形状”，最终得到球该如何向下滚动。</p>
<p>请放心，我们这里不是讨论像牛顿定律这种物理。为了更准确地描述这个问题，假设这个球向$$v_1$$和 $$v_2$$ 放心分别移$$ \Delta v_1 $$ 和 $$ \Delta v_2$$ 。通过微积分我们可以得到：</p>
<p>$$\begin{eqnarray} \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 + \frac{\partial C}{\partial v_2} \Delta v_2. \tag{6}\end{eqnarray}$$</p>
<p>我们需要找到一种方式选择 $$\Delta v_1 和\Delta v_2 这样\Delta C $$是负值，即我们的球可以向谷底移动。我们首先定义向量 $$ \Delta v \equiv (\Delta v_1, \Delta v_2)^T $$ 来表示每个维度上的变化，其中T为矩阵转置。而C对每个变量偏导数组成向量，如下：</p>
<p>$$\begin{eqnarray} \nabla C \equiv \left( \frac{\partial C}{\partial v_1}, \frac{\partial C}{\partial v_2} \right)^T. \tag{7}\end{eqnarray} $$</p>
<p>其中 $$ \nabla $$ 符号表示梯度向量。公式(6)和(7)合并：</p>
<p>$$ \begin{eqnarray} \Delta C \approx \nabla C \cdot \Delta v. \tag{8}\end{eqnarray} $$</p>
<p>通过以上公式，我们可以得到一种必定可以另 $$ \Delta C $$ 为负值的方法。选择</p>
<p>$$ \begin{eqnarray} \Delta v = -\eta \nabla C, \tag{9}\end{eqnarray} $$</p>
<p>其中 $$ -\eta$$为一个比较小的正值，而根据公式(9)即知道 $$ \Delta C $$ 一定为负值或0。看起来我就可以用公式(9)来更新我们的参数，来保证我们的小球一定是向谷底移动的。即每次对参数做 $$ \Delta v = -\eta \nabla C $$ 大小的修正，最后得到全局最小（即我们的球也滚到了底部）。这样解释了算法的名称“梯度下降”。</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/valley_with_ball.png" alt></p>
<p>简要说明梯度下降的思想后，我们如何将它用在神经网络中？注意到$$ v_1 和v_2$$ 是我们为了描述问题简化的，它们代表权值 $$ w_x 或者阈值 b$$ ，那么对公式(9)提到的 $$ v_1 和v_2$$ 更新方法，也同样适用在$$ w_x 或 b$$ ，即得到公式：</p>
<p>$$ \begin{eqnarray} w_k &amp; \rightarrow &amp; w_k’ = w_k-\eta \frac{\partial C}{\partial w_k} \tag{10}\\ b_l &amp; \rightarrow &amp; b_l’ = b_l-\eta \frac{\partial C}{\partial b_l}. \tag{11}\end{eqnarray} $$</p>
<p>对前文误差函数求偏导得到， $$ \nabla C = \frac{1}{n} \sum_x \nabla C_x $$，注意这里是对所有的训练数据做求偏导动作，当训练数据量很大时，学习时间会变得非常长。这时一种解决方案是，每次学习只取训练数据集的一部分m个，只要保证最后所有训练数据都有被取到且平均即可，那么公式为，<br>$$ \nabla C = \frac{1}{m} \sum_x \nabla C_x $$ 。最后我们得到参数的更新公式：</p>
<p>$$ \begin{eqnarray} w_k &amp; \rightarrow &amp; w_k’ = w_k-\frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial w_k} \tag{12}\\ b_l &amp; \rightarrow &amp; b_l’ = b_l-\frac{\eta}{m} \sum_j \frac{\partial C_{X_j}}{\partial b_l}, \tag{13}\end{eqnarray} $$</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>介绍了这么多理论，还是直接看看代码吧。本文参考的<a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">原文</a>使用<a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>作为机器学习库。代码放在<a href="https://github.com/lambertdev/nn-and-dl" target="_blank" rel="noopener">Github</a>。</p>
<p>代码如下：</p>
<p>#### Libraries<br># 标准随机库<br>import random</p>
<p># numpy库<br>import numpy as np</p>
<p>class Network(object):</p>
<pre><code>def __init__(self, sizes):
    &quot;&quot;“
    sizes定义是每层神经网络的神经元（感知器）个数。例如若sizes=[2,3,1]，那么它代表输入层2个感知器，隐层3个感知器，最后一层1个感知器。
    &quot;&quot;&quot;
    self.num_layers = len(sizes)
    self.sizes = sizes
    #初始化每层的权值w和b（bias即负的阈值）
    self.biases = [np.random.randn(y, 1) for y in sizes[1:]]
    self.weights = [np.random.randn(y, x)
                    for x, y in zip(sizes[:-1], sizes[1:])]

def feedforward(self, a):
    &quot;&quot;&quot;返回感知器的输出z&quot;&quot;&quot;
    for b, w in zip(self.biases, self.weights):
        a = sigmoid(np.dot(w, a)+b)
    return a

def SGD(self, training_data, epochs, mini_batch_size, eta,
        test_data=None):
    &quot;&quot;&quot;使用前文提到的‘每次学习只取训练数据集的一部分m个，只要保证最后所有训练数据都有被取到且平均即可’算法进行训练&quot;&quot;&quot;
    if test_data: n_test = len(test_data)
    n = len(training_data)
    #训练轮数
    for j in xrange(epochs):
        #随机打乱训练数据
        random.shuffle(training_data)
        #根据训练最小包的个数分出多个训练包
        mini_batches = [
            training_data[k:k+mini_batch_size]
            for k in xrange(0, n, mini_batch_size)]
        #对每个训练数据包进行训练，权值w和b进行更新
        for mini_batch in mini_batches:
            self.update_mini_batch(mini_batch, eta)
        #用测试数据对训练结果进行计算准确率
        if test_data:
            print &quot;Epoch {0}: {1} / {2}&quot;.format(
                j, self.evaluate(test_data), n_test)
        else:
            print &quot;Epoch {0} complete&quot;.format(j)

def update_mini_batch(self, mini_batch, eta):
    &quot;&quot;&quot;使用后传播方法对训练数据包进行训练（更新w和b）&quot;&quot;&quot;
    #初始化所有的b和w
    nabla_b = [np.zeros(b.shape) for b in self.biases]
    nabla_w = [np.zeros(w.shape) for w in self.weights]
    #根据包中所有的训练数据计算w和b要变化的幅度nabla_b和nabla_w
    for x, y in mini_batch:
        delta_nabla_b, delta_nabla_w = self.backprop(x, y)
        nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)]
        nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)]
    #根据计算的更新幅度更新w和b
    self.weights = [w-(eta/len(mini_batch))*nw
                    for w, nw in zip(self.weights, nabla_w)]
    self.biases = [b-(eta/len(mini_batch))*nb
                   for b, nb in zip(self.biases, nabla_b)]

def backprop(self, x, y):
    nabla_b = [np.zeros(b.shape) for b in self.biases]
    nabla_w = [np.zeros(w.shape) for w in self.weights]
    # feedforward
    activation = x
    activations = [x] # list to store all the activations, layer by layer
    zs = [] 
    # 根据w和b计算训练数据输入得到每个神经元输出
    for b, w in zip(self.biases, self.weights):
        z = np.dot(w, activation)+b
        zs.append(z)
        activation = sigmoid(z)
        activations.append(activation)
    # 计算输出层对w和b的偏导
    delta = self.cost_derivative(activations[-1], y) * \
        sigmoid_prime(zs[-1])
    nabla_b[-1] = delta
    nabla_w[-1] = np.dot(delta, activations[-2].transpose())
    # 从倒数第二层到输入层计算每层w和b的更新值，这里的为BP神经网络算法的实现方法，后续会再介绍其原理。
    for l in xrange(2, self.num_layers):
        z = zs[-l]
        sp = sigmoid_prime(z）
        delta = np.dot(self.weights[-l+1].transpose(), delta) * sp
        nabla_b[-l] = delta
        nabla_w[-l] = np.dot(delta, activations[-l-1].transpose())
    return (nabla_b, nabla_w)

def evaluate(self, test_data):
    #此处比较容易理解，使用测试数据和我们计算得到的w和b代入的公式得到结果对比计算当前学习的准确率
    test_results = [(np.argmax(self.feedforward(x)), y)
                    for (x, y) in test_data]
    return sum(int(x == y) for (x, y) in test_results)

def cost_derivative(self, output_activations, y):
    return (output_activations-y)</code></pre><p>#sigmoid函数<br>def sigmoid(z):<br>    “””The sigmoid function.”””<br>    return 1.0/(1.0+np.exp(-z))<br>#sigmoid函数的倒数<br>def sigmoid_prime(z):<br>    “””Derivative of the sigmoid function.”””<br>    return sigmoid(z)*(1-sigmoid(z))</p>
<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>《<a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a>》</li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络和深度学习(2) -- 后向传播算法原理</title>
    <url>/p/76969095.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank" rel="noopener">神经网络和深度学习(1)</a>中，我们从代码中看到机器学习使用了Back Propagation，但是并未介绍到其工作原理。本文则着重介绍Back Propagation算法(以下简称<strong>BP算法</strong>)的工作原理。本文大部分内容引用、整理或翻译自<a href="http://michaelnielsen.org/" target="_blank" rel="noopener">Michael Nielsen</a>的《<a href="http://neuralnetworksanddeeplearning.com/index.html" target="_blank" rel="noopener">Neural Networks and Deep Learning</a> 》，已征得原作者许可，转载此文请先与我联系。作者原声明如下：</p><a id="more"></a>
<blockquote>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_GB" target="_blank" rel="noopener">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>. This means you’re free to copy, share, and build on this book, but not to sell it. If you’re interested in<br>commercial use, please <a href="mailto:mn@michaelnielsen.org" target="_blank" rel="noopener">contact me</a>.</p>
</blockquote>
<p>BP算法最早于1970年代提出，但是直到1986年<a href="http://en.wikipedia.org/wiki/David_Rumelhart" target="_blank" rel="noopener">David Rumelhart</a>、<a href="http://www.cs.toronto.edu/~hinton/" target="_blank" rel="noopener">Geoffrey Hinton</a>和 <a href="http://en.wikipedia.org/wiki/Ronald_J._Williams" target="_blank" rel="noopener">Ronald Williams</a>的著名论文才开始获得重视。论文中描述了多个神经网络，而BP神经网络比更早的方法学习得快的多，这为神经网络解决之前无法解决的问题提供了可能。而到了今天，BP算法则成为了神经网络中的“劳模”。</p>
<p>跟其他章节相比，本文数学分析较多。若您对数学分析不是特别感冒，可以跳过本文，把数学原理当成一个黑盒子来看。这样，只要了解本文中的结论就可以，后续的章节学习也并不会受到影响。需要说明的是，BP算法的核心是误差函数(Cost函数）对w的偏导数$$∂C/∂w$$。这个表达式说明了在w和b变化下，Cost的变化速度及其中的细节。因此，BP算法的原理也是非常值得学习的。</p>
<p><img src="http://pic.l2h.site/Machine-Learning-Book.jpg" alt></p>
<h2 id="热身：一个快速的基于矩阵的计算神经网络输出方法"><a href="#热身：一个快速的基于矩阵的计算神经网络输出方法" class="headerlink" title="热身：一个快速的基于矩阵的计算神经网络输出方法"></a>热身：一个快速的基于矩阵的计算神经网络输出方法</h2><p>我们使用$$w_{jk}^l$$ 来表示l-1层的第k个神经元到l层的第j个神经元的连接权重。例，下图表示了神经网络第二层的第四个神经元到第三层的第二个神经元的连接:</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/tikz16.png" alt></p>
<p>该定义初看比较麻烦，需要一些时间来理解，掌握之后则发现它比较自然。有人可能比较奇怪j和k的含义：j当做输入层下标，而k为输出的下标不是更直觉更合理吗？之后再做解释。</p>
<p>我们对神经网络的bias（也就是负的阈值）和activation（即输出）也可以采用同样的标识。如下图，$$b_j^l$$ 表示第l层第j个感知器的bias，而$$a_j^l$$ 表示第l层第j个感知器的activation。</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/tikz17.png" alt></p>
<p>由上述表示法，可以得到$$b_j^l$$ 第l层的第j个神经元的输出，可由第l-1层的输出表示如下：</p>
<p>$$\begin{eqnarray} a^{l}<em>j = \sigma\left( \sum_k w^{l}</em>{jk} a^{l-1}_k + b^l_j \right), \tag{1}\end{eqnarray} $$</p>
<p>可以把上述公式写成向量形式：</p>
<p>$$\begin{eqnarray} a^{l} = \sigma(w^l a^{l-1}+b^l). \tag{2}\end{eqnarray} $$</p>
<p>从该公式不难看出，第l层的神经元输出，由前一层的所有神经元输出作为矩阵乘以对应的权重矩阵加上bias之后，代入σ函数即可。该公式非常简洁，在实际使用中也非常有用（有许多库提供了快速计算向量的积、求和等方法）。</p>
<p>在计算$$a^l$$过程中，有先计算中间变量$$z^l\equiv\sigma(w^l a^{l-1}+b^l)$$。该变量在后续章节中非常有用，我们给其命名为<em>带权输入（weight input）_。需要注意$$z^l$$也是向量，由如下向量元素组成：$$z^l_j = \sum_k w^l</em>{jk} a^{l-1}_k+b^l_j$$，其中$$z^l_j$$是第l层第j个元素的带权输入。</p>
<h2 id="误差函数（Cost-Function）"><a href="#误差函数（Cost-Function）" class="headerlink" title="误差函数（Cost Function）"></a>误差函数（Cost Function）</h2><p>本章我们仍然使用<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/" target="_blank" rel="noopener">前一章</a>的误差函数：</p>
<p>$$\begin{eqnarray} C(w,b) \equiv \frac{1}{2n} \sum_x \| y(x) - a\|^2 \nonumber\end{eqnarray}$$</p>
<p>另$$C_x = \frac{1}{2} \|y-a^L \|^2$$，上述误差函数可重写为：$$C = \frac{1}{n} \sum_x C_x$$。同时，误差函数也可以写成对输出$$a^L$$的函数（其也显然是），如下图：</p>
<p><img src="http://neuralnetworksanddeeplearning.com/images/tikz18.png" alt></p>
<h2 id="哈达马积（The-Hadamard-product）"><a href="#哈达马积（The-Hadamard-product）" class="headerlink" title="哈达马积（The Hadamard product）"></a>哈达马积（The Hadamard product）</h2><p>与一般矩阵求积不同，哈达马积（表示为$${s}\odot{t }$$）为求向量见对应元素位置的乘积，例：</p>
<p>$$\begin{eqnarray} \left[\begin{array}{c} 1 \\ 2 \end{array}\right] \odot \left[\begin{array}{c} 3 \\ 4\end{array} \right] = \left[ \begin{array}{c} 1 * 3 \\ 2 * 4 \end{array} \right] = \left[ \begin{array}{c} 3 \\ 8 \end{array} \right]. \end{eqnarray} $$</p>
<p>哈达马积也被称为_Schur product_。</p>
<h2 id="BP算法的四个基本公式"><a href="#BP算法的四个基本公式" class="headerlink" title="BP算法的四个基本公式"></a>BP算法的四个基本公式</h2><p>BP算法的核心主要是理解网络中的权重和bias是怎么对误差函数进行影响的。说到底，是为了计算网络中的偏导数$$\partial C / \partial w^l_{jk}和 \partial C / \partial b^l_j$$。为了计算这些偏导数，我们首先介绍一个中间数，$$delta^l_j$$，它表示第l层第j个神经元的_error（误差）_。</p>
<p>BP算法首先计算$$delta^l_j$$，然后将它与$$\partial C / \partial w^l_{jk} 和 \partial C / \partial b^l_j$$相关联。</p>
<p>为了理解_error_是如何定义的，我们先想象神经网络中有一个小怪兽，位于l层的第j个神经元。当神经元的输入层有输入时，小怪兽对神经元的操作进行破坏–对神经元的带权输入产生$$\Delta z^l_j$$的变化。这样神经元的输出由原来的$$\sigma(z^l_j)$$变为了$$\sigma(z^l_j+\Delta z^l_j)$$。这个变化向网络中的后边层传播，最后导致误差函数的结果产生$$\frac{\partial C}{\partial z^l_j} \Delta z^l_j$$大小的变化。</p>
<p>倘若小怪兽是做好事的小怪兽，希望找到$$\Delta z^l_j $$以帮助我们优化误差函数的结果：假设$$\frac{\partial C}{\partial z^l_j} $$ 很大，小怪兽会仔细挑选$$\Delta z^l_j$$，让它和$$\frac{\partial C}{\partial z^l_j} $$的正负值相反，以此很大程度地降低误差。相反，如果$$\frac{\partial C}{\partial z^l_j}$$接近为0，小怪兽是没办法通过影响带权输入$$z^l_j$$的值来优化误差函数。也就是说，该神经元已经接近最优了。因此，给我们的直觉，$$\frac{\partial C}{\partial z^l_j}$$就是表示神经元误差的一个度量方式。</p>
<p>因此，我们定义误差$$\begin{eqnarray} \delta^l_j \equiv \frac{\partial C}{\partial z^l_j}. \tag{29}\end{eqnarray} $$。</p>
<p>根据本文惯例，我们使用$$\delta^l$$表示第l层的误差向量。BP算法将会用一些公式来计算每一层的$$\delta^l$$，并将这些误差与$$\partial C / \partial w^l_{jk} 和 \partial C / \partial b^l_j$$相关联。</p>
<p>言归正传，我们来看看BP公式的算法：</p>
<h3 id="BP1"><a href="#BP1" class="headerlink" title="BP1"></a>BP1</h3><p>$$\begin{eqnarray} \delta^L_j = \frac{\partial C}{\partial a^L_j} \sigma’(z^L_j). \tag{BP1}\end{eqnarray} $$</p>
<p>公式BP1为微积分里一个基本的导数公式，比较容易理解。写成哈达马积形式如下：</p>
<p>$$\begin{eqnarray} \delta^L = \nabla_a C \odot \sigma’(z^L). \end{eqnarray}$$</p>
<p>其中$$\nabla_a C$$ 为误差函数对所有$$a$$ 的偏导数组成的向量。其中，$$\nabla_a C=(a^L-y)$$.</p>
<h3 id="BP2"><a href="#BP2" class="headerlink" title="BP2"></a>BP2</h3><p>$$\begin{eqnarray} \delta^l = ((w^{l+1})^T \delta^{l+1}) \odot \sigma’(z^l), \tag{BP2}\end{eqnarray} $$</p>
<p>证明如下：</p>
<p>$$\begin{eqnarray} \delta^l_j &amp; = &amp; \frac{\partial C}{\partial z^l_j} \\ &amp; = &amp; \sum_k \frac{\partial C}{\partial z^{l+1}_k} \frac{\partial z^{l+1}_k}{\partial z^l_j} \\ &amp; = &amp; \sum_k \frac{\partial z^{l+1}_k}{\partial z^l_j} \delta^{l+1}_k, \end{eqnarray}$$</p>
<p>其中：</p>
<p>$$\begin{eqnarray} z^{l+1}<em>k = \sum_j w^{l+1}</em>{kj} a^l_j +b^{l+1}<em>k = \sum_j w^{l+1}</em>{kj} \sigma(z^l_j) +b^{l+1}_k. \end{eqnarray} $$</p>
<p>求导得到：</p>
<p>$$\begin{eqnarray} \frac{\partial z^{l+1}<em>k}{\partial z^l_j} = w^{l+1}</em>{kj} \sigma’(z^l_j). \end{eqnarray}$$</p>
<p>合并以上公式得到BP2：</p>
<p>$$\begin{eqnarray} \delta^l_j = \sum_k w^{l+1}_{kj} \delta^{l+1}_k \sigma’(z^l_j). \end{eqnarray} $$</p>
<h3 id="BP3和BP4"><a href="#BP3和BP4" class="headerlink" title="BP3和BP4"></a>BP3和BP4</h3><p>$$\begin{eqnarray} \frac{\partial C}{\partial b^l_j} = \delta^l_j. \tag{BP3}\\ \frac{\partial C}{\partial w^l_{jk}} = a^{l-1}_k \delta^l_j. \tag{BP4}\end{eqnarray} $$</p>
<p>证明BP4如下：</p>
<p>$$\begin{eqnarray}\frac{\partial C}{\partial w^l_{jk}} = \frac{\partial C}{\partial z^l_j} \frac{\partial z^l_j}{\partial w^l_{jk}}. \end{eqnarray}$$</p>
<p>其中：</p>
<p>$$\frac{\partial C}{\partial z^l_j}=\delta^l_j\\ z^l_j = \sum_k w^l_{jk}a^{l-1}<em>k\\\frac{\partial z^l_j}{\partial w^l</em>{jk}}=a^{l-1}_k$$</p>
<p>而BP3的证明类同</p>
<p>有了BP1到BP4四个公式，我们就能根据输入数据一步步来更新各层的w和b（注意：这里是输出层先计算，然后输入层再计算。这也是BP算法中back的意义）。算法对应代码可在<a href="https://www.l2h.site/2019/02/02/machine-learning-neural-network-1/#i-7" target="_blank" rel="noopener">上一章代码实例</a>处查阅。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里主要介绍BP算法的数学原理。下一章节会介绍算法中各个初始化参数以及误差函数（cost function）的选择对结果的影响。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习术语归纳</title>
    <url>/p/ee1773a6.html</url>
    <content><![CDATA[<p>初学机器学习，往往容易淹没在浩瀚的属于中，本文归纳总结一下机器学习相关的术语，帮您更好理解神经网络</p><p>本文大部分翻译自<a href="http://www.wildml.com/deep-learning-glossary/" target="_blank" rel="noopener">wildml.com</a></p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="Activation-Function（激活函数）"><a href="#Activation-Function（激活函数）" class="headerlink" title="Activation Function（激活函数）"></a>Activation Function（激活函数）</h4><p>使用非线性函数对训练模型中的输出（当然不限于最终输出）进行非线性化处理，这样神经网络可以学习到复杂的决策边界。常用的激活函数包括  <a href="https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank" rel="noopener">sigmoid</a>, <a href="http://mathworld.wolfram.com/HyperbolicTangent.html" target="_blank" rel="noopener">tanh</a>, <a href="http://www.wildml.com/deep-learning-glossary/#relu" target="_blank" rel="noopener">ReLU (Rectified Linear Unit)</a>以及众多的变种.</p><a id="more"></a>


<h4 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h4><p>一直基于梯度下降的学习算法，可以自适应调整参数的学习速率。作为<br> <a href="http://www.wildml.com/deep-learning-glossary/#adagrad" target="_blank" rel="noopener">Adagrad</a> 的变种，对超参数敏感，容易造成学习速率过快下降。可以作为标准<br> <a href="http://www.wildml.com/deep-learning-glossary/#sgd" target="_blank" rel="noopener">SGD</a>替代。相关文献：</p>
<ul>
<li><p><a href="http://arxiv.org/abs/1212.5701" target="_blank" rel="noopener">ADADELTA: An Adaptive Learning Rate Method</a></p>
</li>
<li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p>
</li>
<li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p>
</li>
</ul>
<h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><p>Adagrad是一种自适应调整学习速率的算法，它会追踪梯度平方的变化，并对学习速率做自适应调整。对稀疏数据处理非常有效（会对不常更新的参数加快学习速率）。</p>
<ul>
<li><p><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a>  </p>
</li>
<li><p><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a>  </p>
</li>
<li><p><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></p>
</li>
</ul>
<h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><p>类似于 <a href="http://www.wildml.com/deep-learning-glossary/#rmsprop" target="_blank" rel="noopener">rmsprop</a> 的学习速率更新算法，更新主要采取即时的第一和第二时刻平均值。另外算法也包括了bias纠正单元，相关文献：</p>
<ul>
<li><a href="http://arxiv.org/abs/1412.6980" target="_blank" rel="noopener">Adam: A Method for Stochastic Optimization</a></li>
<li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li>
</ul>
<h4 id="Affine-Layer"><a href="#Affine-Layer" class="headerlink" title="Affine Layer"></a>Affine Layer</h4><p>神经网络的一种全连接层。Affine的含义是：每个上层的神经元链接当前层的神经元，即这是标准的神经网络层。Affine层通常会与 <a href="http://www.wildml.com/deep-learning-glossary/#cnn" target="_blank" rel="noopener">Convolutional Neural Networks</a> 或者 <a href="http://www.wildml.com/deep-learning-glossary/#rnn" target="_blank" rel="noopener">Recurrent Neural Networks</a>  一起使用，用于最终产生一个决策。函数形式通常是$$y=f(Wx+b)$$。W,X,b分别是权值，输入和偏移向量。f通常为非线性函数</p>
<h4 id="Attention-Mechanism"><a href="#Attention-Mechanism" class="headerlink" title="Attention Mechanism"></a>Attention Mechanism</h4><p>Attention Mechanisms（注意力机制）灵感的源于人类视觉注意力特点 ：可以关注图片上的特定某个区域。注意力机制可以与自然语言处理或者图片识别结构一起工作，帮助神经网络学习到进行决策时该“注意”到哪些部分。相关文献：</p>
<ul>
<li><a href="http://www.wildml.com/2016/01/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener">Attention and Memory in Deep Learning and NLP</a></li>
</ul>
<h4 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h4><p>Alexnet是大优势赢得2012年ILSVRC竞赛使用的CNN架构，它使大家重新对使用_<strong>CNN网络</strong>_识别图片的产生兴趣。它由5层卷积层组成，部分卷积层后跟随池化层，最后的全连接层是1000路的softmax分类。Alexnet的介绍见<a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="noopener">ImageNet Classification with Deep Convolutional Neural Networks</a>.</p>
<h4 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h4><p>Autoencoder是一种神经网络模型，目标为通过网络中的一些“瓶颈”来预测网络的输入。通过引入瓶颈，强制网络学习到输入的低维度映射，从而有效地压缩输入维度。Autoencoders与PCA即一些其他降维技术有关，因为其本质上的非线性化特点，可以处理更复杂的映射。现有大量的autoencoder架构，包括<a href="http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf" target="_blank" rel="noopener">Denoising Autoencoders</a>,、<a href="http://arxiv.org/abs/1312.6114" target="_blank" rel="noopener">Variational Autoencoders</a>,或者<a href="http://arxiv.org/abs/1511.01432" target="_blank" rel="noopener">Sequence Autoencoders</a></p>
<h4 id="Average-Pooling"><a href="#Average-Pooling" class="headerlink" title="Average-Pooling"></a>Average-Pooling</h4><p>Average-Pooling是<strong><em>卷积神经网络</em></strong>识别图片采用的一种池化技术。工作原理为使用小于图片的窗口在图片特征上进行滑动，取得滑动位置上数值的平均值。从而降低数据特征的维度，同时有效保持数据的特征。与之类似的有最大值池化等方法。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="Backpropagation（逆传播，后向传播）"><a href="#Backpropagation（逆传播，后向传播）" class="headerlink" title="Backpropagation（逆传播，后向传播）"></a>Backpropagation（逆传播，后向传播）</h4><p>Backpropagation是有效计算神经网络梯度的方法。它通过微分运算，有效地将误差从输出位置传递到输入位置。它与上世纪70年代开始被使用。文献：</p>
<ul>
<li><a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="noopener">Calculus on Computational Graphs: Backpropagation</a></li>
</ul>
<h4 id="Backpropagation-Through-Time-BPTT"><a href="#Backpropagation-Through-Time-BPTT" class="headerlink" title="Backpropagation Through Time (BPTT)"></a>Backpropagation Through Time (BPTT)</h4><p>Backpropagation Through Time (<a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">paper</a>)是<strong><em>循环神经网络</em></strong>使用的逆传播算法。RNN的网络结构与传统的网络结构不同（每个阶段的神经单元共享参数），因此采用的逆传播也稍后差异。相关介绍见</p>
<ul>
<li><a href="http://axon.cs.byu.edu/~martinez/classes/678/Papers/Werbos_BPTT.pdf" target="_blank" rel="noopener">Backpropagation Through Time: What It Does and How to Do It</a></li>
</ul>
<h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><p>Batch Normalization是对神经网络层输入数据进行小批量分组使用的技术。使用小批量数据分组而非完整数据包可以加速训练速度。其在<strong><em>卷积神经网络</em></strong>或者_<strong>前向神经网络</strong>_使用中被证明非常有效，不过其目前在<strong>循环神经网络</strong>的使用中，效果有限</p>
<ul>
<li><a href="http://arxiv.org/abs/1502.03167" target="_blank" rel="noopener">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li>
<li><a href="http://arxiv.org/abs/1510.01378" target="_blank" rel="noopener">Batch Normalized Recurrent Neural Networks</a></li>
</ul>
<h4 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h4><p>双向循环神经网络是包含两个不同走向循环神经网络的网络。正向RNN从前向后读取输入序列，逆向RNN反之。两个RNN互相交叠，输出由这两个RNN的隐藏层的状态决定。双向RNN主要被用于自然语言处理问题（例，处理一个单词需要考虑单词前后的单词）。相关文献</p>
<ul>
<li><a href="http://www.di.ufpe.br/~fnj/RNA/bibliografia/BRNN.pdf" target="_blank" rel="noopener">Bidirectional Recurrent Neural Networks</a></li>
</ul>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h4><p><a href="http://caffe.berkeleyvision.org/" target="_blank" rel="noopener">Caffe</a> 是 Berkeley Vision和Learning Center开发的深度学习框架，在处理视觉处理问题和CNN模型方面非常有用。</p>
<h4 id="Categorical-Cross-Entropy-Loss"><a href="#Categorical-Cross-Entropy-Loss" class="headerlink" title="Categorical Cross-Entropy Loss"></a>Categorical Cross-Entropy Loss</h4><p>分类交叉熵损失也被称作负对数似然，它是处理分类问题或者评估概率分布相似性的方法，特别是用于评估真值标签。其公式为$$L = -sum(y * log(y_prediction))$$，其中y是真标签的概率分布（独热向量），$$y_prediction$$是已预测标签的概率分布（一般使用softmax函数）</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>深度学习模型的输入数据可以有多个通道。例如，图片有RGB三个通道。因此图片可以被一个3维张量表示，分别是通道、高度和宽度。自然语言处理数据也有多个通道的概念。例如，数据有不同类别的_<strong>嵌入</strong>_表示。</p>
<h4 id="Convolutional-Neural-Network-CNN-ConvNet"><a href="#Convolutional-Neural-Network-CNN-ConvNet" class="headerlink" title="Convolutional Neural Network (CNN, ConvNet)"></a>Convolutional Neural Network (CNN, ConvNet)</h4><p>卷积神经网络使用卷积层从输入数据中提取有效特征。通常卷积神经网络由卷积、池化和全连接层组成。因为其在视觉处理任务的出色表现，卷积神经网络近年来一直非常流行。相关文章：</p>
<ul>
<li><a href="http://cs231n.github.io/" target="_blank" rel="noopener">Stanford CS231n class – Convolutional Neural Networks for Visual Recognition</a></li>
<li><a href="http://www.wildml.com/2015/11/understanding-convolutional-neural-networks-for-nlp/" target="_blank" rel="noopener">Understanding Convolutional Neural Networks for NLP</a></li>
</ul>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="Deep-Belief-Network-DBN"><a href="#Deep-Belief-Network-DBN" class="headerlink" title="Deep Belief Network (DBN)"></a>Deep Belief Network (DBN)</h4><p>深度信念网络，通过无监督的概率图模型来学习数据特征。DBN由多个隐层组成，前后隐层的神经元间相互连接。每层神经网络由受限玻尔兹曼机组成，分别进行训练层。</p>
<ul>
<li><a href="https://www.cs.toronto.edu/~hinton/absps/fastnc.pdf" target="_blank" rel="noopener">A fast learning algorithm for deep belief nets</a></li>
</ul>
<h4 id="Deep-Dream"><a href="#Deep-Dream" class="headerlink" title="Deep Dream"></a>Deep Dream</h4><p>Google发明的一项技术，对深度卷积神经网络学习到的数据进行提取，并用于生成新图片、修改图片甚至给图片加入梦幻般的效果。相关资料：</p>
<ul>
<li><a href="https://github.com/google/deepdream" target="_blank" rel="noopener">Deep Dream on Github</a></li>
<li><a href="http://googleresearch.blogspot.ch/2015/06/inceptionism-going-deeper-into-neural.html" target="_blank" rel="noopener">Inceptionism: Going Deeper into Neural Networks</a></li>
</ul>
<h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>随机失活是神经网络中用于避免过拟合的一种方法。最早被用于CNN网络，目前被广泛使用到其他神经网络中。相关资料：</p>
<ul>
<li><a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf" target="_blank" rel="noopener">Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li>
<li><a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="noopener">Recurrent Neural Network Regularization</a></li>
</ul>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="Embedding（嵌入）"><a href="#Embedding（嵌入）" class="headerlink" title="Embedding（嵌入）"></a>Embedding（嵌入）</h4><p>嵌入指的是将单词或者句子映射成向量形式。比较流行的嵌入是单词嵌入（例如，<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a> 或 <a href="http://www.wildml.com/deep-learning-glossary/#glove" target="_blank" rel="noopener">GloVe</a>）。我们也可以嵌入句子、段落或者图片。比如说，通过映射图片和他们的文字描述到嵌入空间来减少他们之间的距离，来将图片和对应的标签进行关联。嵌入可以单独进行（如采用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>），也可以作为某个机器学习任务的一部分，例如情感分析。通常，神经网络的输入均是已经训练和优化过的数据。</p>
<h4 id="Exploding-Gradient-Problem（梯度爆炸问题）"><a href="#Exploding-Gradient-Problem（梯度爆炸问题）" class="headerlink" title="Exploding Gradient Problem（梯度爆炸问题）"></a>Exploding Gradient Problem（梯度爆炸问题）</h4><p>梯度爆炸问题与梯度消失问题正好相反。在深度神经网络中，逆传播过程可能会造成梯度爆炸从而产生数字溢出。一种解决梯度爆炸的方式是<a href="http://www.wildml.com/deep-learning-glossary/#gradient-clipping" target="_blank" rel="noopener">梯度修剪</a></p>
<ul>
<li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li>
</ul>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><h4 id="Fine-Tuning"><a href="#Fine-Tuning" class="headerlink" title="Fine-Tuning"></a>Fine-Tuning</h4><p>优化调节指的是从另外的任务得到优化过的初始化学习参数。例如，使用<a href="http://www.wildml.com/deep-learning-glossary/#word2vec" target="_blank" rel="noopener">word2vec</a>对自然语言处理任务的单词做预处理</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h4 id="Gradient-Clipping"><a href="#Gradient-Clipping" class="headerlink" title="Gradient Clipping"></a>Gradient Clipping</h4><p>梯度修剪主要用于避免深度神经网络（特别是循环神经网络）的梯度爆炸问题。进行梯度修剪的方式有多种，一种常用的方式是对梯度进行L2正则化（new_gradients = gradients * threshold / l2_norm(gradients)），参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1211.5063" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li>
</ul>
<h4 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h4><p>Glove是一种用于单词嵌入的无监督学习算法。Glove向量和wordvec用途相同，但是表示有差异，这是由于用于嵌入方式不同</p>
<ul>
<li><a href="http://nlp.stanford.edu/pubs/glove.pdf" target="_blank" rel="noopener">GloVe: Global Vectors for Word Representation</a></li>
</ul>
<h4 id="GoogleLeNet"><a href="#GoogleLeNet" class="headerlink" title="GoogleLeNet"></a>GoogleLeNet</h4><p>赢得2014年ILSVRC挑战的卷积神经网络框架。它使用记忆模块减少参数，同时提升对计算资源的有效利用率。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li>
</ul>
<h4 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h4><p>GRU( Gated Recurrent Unit ,门循环单元)是LSTM单元的简化形式，有更少的参数。类似于LSTM神经元，它使用门策略来避免梯度消失问题，使得RNN有效地学习长范围的关联。GRU内部有重置和更新门来决定旧的记忆是否需要保留还是要用当前时间的新值进行更新。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1406.1078v3" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li>
<li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li>
</ul>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><h4 id="Highway-Layer"><a href="#Highway-Layer" class="headerlink" title="Highway Layer"></a>Highway Layer</h4><p>Highway Layer (<a href="http://arxiv.org/abs/1505.00387" target="_blank" rel="noopener">论文参考</a>)是使用门策略来控制神经网络层信息流的机制。叠加使用多个Highway层可以训练非常深层次的神经网络。Highway通过门函数选择输入的那个部分通过以及那个部分需要通过变化函数处理。Highway层的基本公式为$$T * h(x) + (1 - T) * x$$，其中T是学习门函数，值位于0和1之间，h(x)是任意输入变化函数，x为输入数据。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><h4 id="ICML"><a href="#ICML" class="headerlink" title="ICML"></a>ICML</h4><p> <a href="http://icml.cc/" target="_blank" rel="noopener">International Conference for Machine Learning</a>, 机器学习领域顶级会议</p>
<h4 id="ILSVRC"><a href="#ILSVRC" class="headerlink" title="ILSVRC"></a>ILSVRC</h4><p><a href="http://www.image-net.org/challenges/LSVRC/" target="_blank" rel="noopener">ImageNet Large Scale Visual Recognition Challenge</a> 是图像识别分类领域最热门的竞赛。</p>
<h4 id="Inception-Module"><a href="#Inception-Module" class="headerlink" title="Inception Module"></a>Inception Module</h4><p>记忆单元用于卷积神经网络，提升网络的计算性能。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going Deeper with Convolutions</a></li>
</ul>
<h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><h4 id="KerasK"><a href="#KerasK" class="headerlink" title="KerasK"></a>Keras<a href="http://keras.io/" target="_blank" rel="noopener">K</a></h4><p><a href="http://keras.io/" target="_blank" rel="noopener">Keras</a>是包含对深度学习进行深度封装的Python库。可以在<a href="http://www.wildml.com/deep-learning-glossary/#tensorflow" target="_blank" rel="noopener">TensorFlow</a>, <a href="http://www.wildml.com/deep-learning-glossary/#theano" target="_blank" rel="noopener">Theano</a>, 或 <a href="https://github.com/Microsoft/CNTK" target="_blank" rel="noopener">CNTK</a>上层使用</p>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p>长期短记忆网络主要用记忆门来避免RNN网络的梯度消失问题。利用LSTM单元计算RNN隐层，可以有效的传递梯度以及学习长范围关联。参考：</p>
<ul>
<li><a href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf" target="_blank" rel="noopener">Long Short-Term Memory</a></li>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li>
<li><a href="http://www.wildml.com/2015/10/recurrent-neural-network-tutorial-part-4-implementing-a-grulstm-rnn-with-python-and-theano/" target="_blank" rel="noopener">Recurrent Neural Network Tutorial, Part 4 – Implementing a GRU/LSTM RNN with Python and Theano</a></li>
</ul>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><h4 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max-Pooling"></a>Max-Pooling</h4><p>最大池化是卷积神经网络的一种池化操作，池化时选择特征片段里的最大值，是卷积神经网络的常用池化操作。</p>
<h3 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h3><h4 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h4><p> MNIST 数据集 是最常使用的图像识别数据集了。基本上也是许多机器学习课程的范例数据集，更多介绍直接参考<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">官网</a>即可。</p>
<h4 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h4><p>Momentum是梯度下降算法的扩展，加速和优化了参数更新过程。实际使用中，加入momentum到梯度下降中，可以使深度网络得到更好的收敛 。参考：</p>
<ul>
<li><a href="http://www.nature.com/nature/journal/v323/n6088/abs/323533a0.html" target="_blank" rel="noopener">Learning representations by back-propagating errors</a></li>
</ul>
<h4 id="Multilayer-Perceptron-MLP"><a href="#Multilayer-Perceptron-MLP" class="headerlink" title="Multilayer Perceptron (MLP)"></a>Multilayer Perceptron (MLP)</h4><p>多层感知是一种多全连接层的前馈神经网络，使用<strong>激活函数</strong>处理数据做非线性化。MLP是多层神经网络或深度神经网络的最基本形式。</p>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><h4 id="Negative-Log-Likelihood-NLL"><a href="#Negative-Log-Likelihood-NLL" class="headerlink" title="Negative Log Likelihood (NLL)"></a>Negative Log Likelihood (NLL)</h4><p>见 <a href="http://www.wildml.com/deep-learning-glossary/#ce-loss" target="_blank" rel="noopener">Categorical Cross Entropy Loss</a>.</p>
<h4 id="Neural-Machine-Translation-NMT"><a href="#Neural-Machine-Translation-NMT" class="headerlink" title="Neural Machine Translation (NMT)"></a>Neural Machine Translation (NMT)</h4><p>神经机器翻译指的是使用神经网络来翻译语言。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to sequence learning with neural networks</a></li>
<li><a href="http://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li>
</ul>
<h4 id="Neural-Turing-Machine-NTM"><a href="#Neural-Turing-Machine-NTM" class="headerlink" title="Neural Turing Machine (NTM)"></a>Neural Turing Machine (NTM)</h4><p>神经图灵机可以从范例中推导简单的算法。例如，NTM可以从输入输出范例中学习分类算法。在程序运行时神经图灵机通常可以学习到一些处理状态的记忆方法</p>
<ul>
<li><a href="http://arxiv.org/abs/1410.5401" target="_blank" rel="noopener">Neural Turing Machines</a></li>
</ul>
<h4 id="Nonlinearity（去线性化）"><a href="#Nonlinearity（去线性化）" class="headerlink" title="Nonlinearity（去线性化）"></a>Nonlinearity（去线性化）</h4><p>见<strong><em>激活函数</em></strong>.</p>
<h4 id="Noise-contrastive-estimation-NCE"><a href="#Noise-contrastive-estimation-NCE" class="headerlink" title="Noise-contrastive estimation (NCE)"></a>Noise-contrastive estimation (NCE)</h4><p>噪声对比评估是一种在大量词汇表输出常见用来训练分类器的损失抽样方法。通过计算所有可能分类的Softmax是代价昂贵的。而使用NCE，可以有效减少二分类问题的代价，而只需要通过从“真”分布和人工产生的噪声分布区来训练分类器。例如：</p>
<ul>
<li><a href="http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf" target="_blank" rel="noopener">Noise-contrastive estimation: A new estimation principle for unnormalized statistical models</a></li>
<li><a href="http://papers.nips.cc/paper/5165-learning-word-embeddings-efficiently-with-noise-contrastive-estimation.pdf" target="_blank" rel="noopener">Learning word embeddings efficiently with noise-contrastive estimation</a></li>
</ul>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><h4 id="Pooling"><a href="#Pooling" class="headerlink" title="Pooling"></a>Pooling</h4><p>见<strong><em>最大池化</em></strong>和<strong><em>平均池化</em></strong>.</p>
<h4 id="Restricted-Boltzmann-Machine-RBN"><a href="#Restricted-Boltzmann-Machine-RBN" class="headerlink" title="Restricted Boltzmann Machine (RBN)"></a>Restricted Boltzmann Machine (RBN)</h4><p>受限玻尔兹曼机是深度信念网络使用的一种概率图模型。参考：</p>
<ul>
<li><a href="http://www-psych.stanford.edu/~jlm/papers/PDP/Volume%201/Chap6_PDP86.pdf" target="_blank" rel="noopener">Chapter 6: Information Processing in Dynamical Systems: Foundations of Harmony Theory</a></li>
<li><a href="http://image.diku.dk/igel/paper/AItRBM-proof.pdf" target="_blank" rel="noopener">An Introduction to Restricted Boltzmann Machines</a></li>
</ul>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><h4 id="Recurrent-Neural-Network-RNN"><a href="#Recurrent-Neural-Network-RNN" class="headerlink" title="Recurrent Neural Network (RNN)"></a>Recurrent Neural Network (RNN)</h4><p>RNN代表循环神经网络，参考<a href="https://www.l2h.site/2019/07/13/%e5%be%aa%e7%8e%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9crnn%e7%ae%80%e5%8d%95%e7%90%86%e8%a7%a3/" target="_blank" rel="noopener">本站文章</a>，或者：</p>
<ul>
<li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks</a></li>
<li><a href="http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/" target="_blank" rel="noopener">Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs</a></li>
</ul>
<h4 id="Recursive-Neural-Network"><a href="#Recursive-Neural-Network" class="headerlink" title="Recursive Neural Network"></a>Recursive Neural Network</h4><p>递归神经网络是循环神经网络的一种树状形式。详情参见：</p>
<ul>
<li><a href="http://ai.stanford.edu/~ang/papers/icml11-ParsingWithRecursiveNeuralNetworks.pdf" target="_blank" rel="noopener">Parsing Natural Scenes and Natural Language with Recursive Neural Networks</a></li>
</ul>
<h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>线性整流函数（Rectified Linear Unit）是一种激活函数，深度学习中做去线性化处理。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1502.01852" target="_blank" rel="noopener">Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification</a></li>
<li><a href="http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf" target="_blank" rel="noopener">Rectifier Nonlinearities Improve Neural Network Acoustic Models</a></li>
<li><a href="http://www.cs.toronto.edu/~fritz/absps/reluICML.pdf" target="_blank" rel="noopener">Rectified Linear Units Improve Restricted Boltzmann Machines</a></li>
</ul>
<h4 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h4><p>深度残差网络（Deep Residual Network），赢得了ILSVRC 2015挑战赛，参考。</p>
<ul>
<li><a href="http://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">Deep Residual Learning for Image Recognition</a></li>
</ul>
<h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>RMSProp是一种基于梯度的优化算法。具体算法介绍见 ：</p>
<ul>
<li><a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="noopener">Neural Networks for Machine Learning Lecture 6a</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li>
<li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li>
</ul>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><h4 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h4><p>序列到序列模型读取血量作为输入，产生另外一个序列作为输出。与RNN不同的地方是，在产生输出之前，输入序列被一次性完整的输入。一般使用两个RNN实现，经典应用为机器翻译、编解码等，参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></li>
</ul>
<h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><p>随机梯度下降是一种有效的梯度优化算法(<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent" target="_blank" rel="noopener">Wikipedia</a>)，其扩展算法包括 <strong>Momentum</strong>, <strong>Adagrad</strong>, <strong>rmsprop</strong>, <strong>Adadelta</strong> 以及 <strong>Adam</strong>.参考：</p>
<ul>
<li><a href="http://www.magicbroom.info/Papers/DuchiHaSi10.pdf" target="_blank" rel="noopener">Adaptive Subgradient Methods for Online Learning and Stochastic Optimization</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="noopener">Stanford CS231n: Optimization Algorithms</a></li>
<li><a href="http://sebastianruder.com/optimizing-gradient-descent/" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms</a></li>
</ul>
<h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p><a href="https://baike.baidu.com/item/Softmax%E5%87%BD%E6%95%B0/22772270?fr=aladdin" target="_blank" rel="noopener">Softmax函数</a>，它能将一个含任意实数的K维向量 “压缩”到另一个K维实向量 中，使得每一个元素的范围都在 （0,1）之间，并且所有元素的和为1。主要作为处理分类问题的输出</p>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><h4 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a> 是Google提供的开源深度学习框架，可以对数据流图做计算，也封装了现行主要的神经网络运算。支持C++/Python.</p>
<h4 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h4><p><a href="http://deeplearning.net/software/theano/" target="_blank" rel="noopener">Theano</a> 是一个封装深度神经网络算法的Python库</p>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><h4 id="Vanishing-Gradient-Problem"><a href="#Vanishing-Gradient-Problem" class="headerlink" title="Vanishing Gradient Problem"></a>Vanishing Gradient Problem</h4><p>梯度消失问题在深度神经网络学习中越来越常见，特别是循环神经网络，使用较小的梯度（位于0和1直接）。因为梯度在逆传播过程中会相乘，所以会在层与层传递间逐渐“消失”，导致长范围的关联消失。解决方法主要有使用<strong>ReLU</strong>激活，或者使用改进网络<strong><em>LSTM</em></strong>等。参考：</p>
<ul>
<li><a href="http://www.jmlr.org/proceedings/papers/v28/pascanu13.pdf" target="_blank" rel="noopener">On the difficulty of training recurrent neural networks</a></li>
</ul>
<h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><p>VGG是赢得2014 ImageNet定位和分类跟踪问题第一二名的卷积神经网络。它由16到19个权重层和1*1或3*3的小卷积过滤器组成。参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">Very Deep Convolutional Networks for Large-Scale Image Recognition</a></li>
</ul>
<h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><h4 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h4><p>word2vec用于单词嵌入的算法，参考：</p>
<ul>
<li><a href="http://arxiv.org/abs/1301.3781" target="_blank" rel="noopener">Efficient Estimation of Word Representations in Vector Space</a></li>
<li><a href="http://arxiv.org/abs/1310.4546" target="_blank" rel="noopener">Distributed Representations of Words and Phrases and their Compositionality</a></li>
<li><a href="http://arxiv.org/abs/1411.2738" target="_blank" rel="noopener">word2vec Parameter Learning Explained</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Wordpress使用Markdown编辑器</title>
    <url>/p/a42161ac.html</url>
    <content><![CDATA[<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>    Markdown是一种轻量级的文本格式化语言，通过简单的标记语法，它可以使普通文本内容具有丰富的格式。最初设计主要被用于程序设计的Readme编写，或者用于一些在线技术讨论论坛的信息发送。它很方便被用来和HTML格式语言进行转换。 很多在线博客都支持Markdown语言。例如，简书、Typecho等。 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。</p><a id="more"></a>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>    本节介绍一些Markdown的基本语法。</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>    Markdown的标题语法非常简单，可以利用’#’符号来完成。例如, ‘#一级标题’ 代表一级标题、‘##二级标题’， 以此类推。</p>
<h3 id="文字格式"><a href="#文字格式" class="headerlink" title="文字格式"></a>文字格式</h3><p>    “** 粗体字**”是粗体，“* 斜体字*”是斜体，“*** 斜体加粗字***”是斜体加粗，“删除线”是删除线。例如：</p>
<blockquote>
<p><strong>粗体字</strong> <em>斜体字</em> <em><strong>斜体加粗字</strong></em> 删除线</p>
</blockquote>
<h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p>    “&gt;引用内容”代表引用块。例如：</p>
<blockquote>
<p>这是一个引用</p>
<blockquote>
<p>二级引用</p>
<blockquote>
<p>三级引用，以此类推。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>     初使用最容易碰到的问题，就是回车是没有办法换行的。做法是一段长文字里在要换行的地方加两个空格。例如： 这就是一个换行。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>    使用列表也非常简单，数字加点即可。例如：</p>
<blockquote>
<p>1.列表内容 2.列表内容 3.列表内容</p>
</blockquote>
<ol>
<li><ol>
<li>列表</li>
</ol>
</li>
<li><ol>
<li>列表2</li>
</ol>
</li>
<li><p>列表3</p>
</li>
</ol>
<p>     也可以使用非数字格式的列表。可以用”+ “, “* “, “- ” 来做。例如：</p>
<blockquote>
<p>“+ 列表” “- 列表” “* 列表”</p>
</blockquote>
<ul>
<li><ul>
<li>我是列表</li>
</ul>
</li>
<li><ul>
<li>我是列表</li>
</ul>
</li>
<li><p>我是列表</p>
</li>
</ul>
<p>     列表还可以嵌套，上一级列表和下一级直接敲三个空格即可</p>
<ul>
<li><ul>
<li>我是列表<ul>
<li>我是嵌套的</li>
</ul>
</li>
</ul>
</li>
<li><p>嗯嗯</p>
<ul>
<li>可以嵌套<ul>
<li>还可以继续嵌套</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>     写博客怎么少得了图片呢？格式如下：</p>
<blockquote>
<p>![图片alt](图片地址 ‘’图片title’’)</p>
</blockquote>
<p>     图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加。例如：</p>
<p><img src="http://pic.l2h.site/l2hsitemarkdown-article.jpg" alt="图片ALT，当没有图片时候显示" title="图片标题"></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><blockquote>
<p>[链接名] (超链接地址 “超链接title”)，例如：</p>
</blockquote>
<p><a href="http://www.l2h.site/" title="http://www.l2h.site/" target="_blank" rel="noopener">L&amp;H Site</a></p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>     作为码农，比较常用的是代码编辑器。能不能用代码编辑器写Markdown呢？答案是当然可以。例如，这篇文章是L&amp;H用Visual Studio Code + Markdown Theme Kit插件写成。如图：</p>
<p><img src="http://pic.l2h.site/l2hsiteMarkdown-title-2.png" alt="Markdown编辑器"></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Mithell《机器学习》学习笔记 - Chapter 1&amp;2</title>
    <url>/p/d43a3a14.html</url>
    <content><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><ul>
<li>语音识别</li>
<li>自动车辆驾驶</li>
<li>西洋双陆棋</li>
</ul>
</li>
<li><p>….</p>
</li>
</ul><h3 id="相关学科"><a href="#相关学科" class="headerlink" title="相关学科"></a>相关学科</h3><ul>
<li><ul>
<li>人工智能</li>
<li>贝叶斯方法</li>
<li>计算复杂性理论</li>
<li>信息论</li>
<li>控制论</li>
</ul>
</li>
<li><p>统计学</p>
</li>
</ul><h3 id="问题的标准描述"><a href="#问题的标准描述" class="headerlink" title="问题的标准描述"></a>问题的标准描述</h3><blockquote>
<p><strong>任务T</strong>: 描述机器学习要做任务</p>
<p><strong>性能标准P</strong>: 描述机器学习结果的性能</p>
<p><strong>训练经验E</strong>: 用于学习的数据集</p>
<p><strong>目标函数$$V$$</strong>: 根据输入得到最优方案（例如，一段语音的最佳匹配、棋局的最佳落子）</p>
<p><strong>目标函数的最优近似$${\tilde V}$$</strong>: 根据输入得到近似目标函数的最优方案</p>
</blockquote><a id="more"></a>


<p>    训练经验—-&gt;<strong>学习器</strong>—-&gt;目标函数$$V$$ （从当前任务允许的所有合法输入集合中，选出能得到最优性能标准P的输出的唯一输入）。</p>
<h3 id="目标函数的描述"><a href="#目标函数的描述" class="headerlink" title="目标函数的描述"></a>目标函数的描述</h3><p>    通常来说，由于任务T的复杂性，无法完全得到目标函数，通常机器学习的目标是得到目标函数的某个近似(Approximation) $${\tilde V}$$ 。     $${\tilde V}$$ 函数需要可表示，这样才能根据任务的实际状况，评估出输出结果的性能。一般来讲，目标函数输入有多个变量维度。其最简单的一种表示方法为给每个维度的变量赋予一定的权值（weights）$$w_0-&gt;w_n$$，乘以对应维度变量再求和的一个线性函数。例如：</p>
<blockquote>
<p>$${\tilde V} = w_0+x_1w_1+x_2w_2+…+x_nw_n$$</p>
</blockquote>
<h3 id="目标函数近似函数的训练"><a href="#目标函数近似函数的训练" class="headerlink" title="目标函数近似函数的训练"></a>目标函数近似函数的训练</h3><p>    训练的目的，便是确定目标函数的近似函数。以上述函数为例，便是确定目标函数里的权值的确切数值。</p>
<h4 id="训练样例"><a href="#训练样例" class="headerlink" title="训练样例"></a>训练样例</h4><p>    为了学习到$${\tilde V}$$，需要一系列的训练样例，它们可以表示为：</p>
<blockquote>
<p>$$&lt;&lt;x_1=3,x_2=1,…,x_n=10&gt;, 100&gt;$$</p>
</blockquote>
<p>    其中100为$$&lt;x_1=3,x_2=1,…,x_n=10&gt;$$的性能打分。</p>
<h4 id="权值调整"><a href="#权值调整" class="headerlink" title="权值调整"></a>权值调整</h4><p>    训练过程就是对权值进行调整，逐渐逼近目标函数的过程。而调整权值的过程，就是寻找可以对训练集中的所有样例，函数得到的值和训练值之差的平方总和E最小的过程。即：</p>
<blockquote>
<p>$$E\equiv\sum_{\mathclap{&lt;b, V_{train}(b)&gt; \in Training Data}} (V_{train}(b)-\tilde{V}(b))^2$$</p>
</blockquote>
<p>    权值更新则是根据当前训练值与当前近似函数的计算值的差，进行权值更新。公式如下：</p>
<blockquote>
<p>$$w_{new}⇠w_i+\eta(V_{train}(b)-\tilde{V}(b))x_i$$</p>
</blockquote>
<p>    其中$$\eta$$为小的常数代表调整幅度。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>    用书中的一张图表示训练过程：</p>
<p><img src="http://pic.l2h.site/l2hsiteMachine-Learning-Outline.png" alt="机器学习"></p>
<h2 id="概念学习-（Concept-Learning）"><a href="#概念学习-（Concept-Learning）" class="headerlink" title="概念学习 （Concept Learning）"></a>概念学习 （Concept Learning）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>Concept Learning: Inferring a boolean-valued function from training examples of its input and output.</p>
</blockquote>
<p>    “概念学习”指的是从有输入输出的训练数据中推导出返回布尔值的函数。 例如：识别物体是否是汽车、鸟类或植物。</p>
<h3 id="概念学习任务"><a href="#概念学习任务" class="headerlink" title="概念学习任务"></a>概念学习任务</h3><p>[caption id=”” align=”aligncenter” width=”629”]<img src="http://pic.l2h.site/l2hsiteMachine-Learning-Outline-2.png" alt="概念学习实例"> 机器学习[/caption]</p>
<p>    书中根据天气情况判断Aldo是否会做户外运动为实例。输入参数为一元组：&lt;天空状况，空气温度，空气湿度，风力，水温，天气预报&gt;。输出为布尔值：表示Aldo是否做户外运动。具体训练目标定义如下：</p>
<p>给出训练数据，即Aldo以往做户外运动的天气状况。从假设函数集合$$H$$中推导出目标函数h的近似函数，满足$$h(x)=c(x)$$，其中：</p>
<ul>
<li><ul>
<li>h()和c()函数均为返回布尔值的函数，表示Aldo是否会做户外运动。</li>
</ul>
</li>
<li><p>c()函数为目标函数，事先并不知道，只有以往的训练数据。</p>
</li>
</ul>
<h4 id="Inductive-Learning-Hypothesis-（归纳学习假设）"><a href="#Inductive-Learning-Hypothesis-（归纳学习假设）" class="headerlink" title="Inductive Learning Hypothesis （归纳学习假设）"></a>Inductive Learning Hypothesis （归纳学习假设）</h4><blockquote>
<p>若某近似函数在足够大的训练数据集上与目标函数输出结果匹配，我们有理由相信剩余未被观察到的数据上该近似函数也可得到正确输出。</p>
</blockquote>
<h4 id="CONCEPT-LEARNING-AS-SEARCH（概念学习即搜索）"><a href="#CONCEPT-LEARNING-AS-SEARCH（概念学习即搜索）" class="headerlink" title="CONCEPT LEARNING AS SEARCH（概念学习即搜索）"></a>CONCEPT LEARNING AS SEARCH（概念学习即搜索）</h4><p>    概念学习可以认为从一个大的假设空间逐步搜索到最符合训练数据集的假设。</p>
<blockquote>
<p>General-to-Specific Ordering of Hypotheses(假设的一般到特殊序)：以输入参数一元组中的“水温为例”，它可能有Warm、Cool、任意值($$?$$)或者皆不可($$\Theta$$)。其中对假设的搜索顺序应该是从一般到特殊$$?\to(Warm|Cool)\to\Theta$$.</p>
</blockquote>
<h4 id="FIND-S-寻找最大特殊假设"><a href="#FIND-S-寻找最大特殊假设" class="headerlink" title="FIND-S:寻找最大特殊假设"></a>FIND-S:寻找最大特殊假设</h4><p>    按照一般到特殊顺序计算出匹配训练数据集的最一般假设。</p>
<h4 id="概念空间和候选消除算法"><a href="#概念空间和候选消除算法" class="headerlink" title="概念空间和候选消除算法"></a>概念空间和候选消除算法</h4><p>    候选消除算法，解决Find-S的部分问题：因为Find-S得到的可能只是诸多满足训练数据集合的一系列假设的集合。候选消除算法则从这些假设中消除不匹配的假设。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>新SARS</title>
    <url>/p/f4ebc93a.html</url>
    <content><![CDATA[<p>人类自以为是世界的主宰，实则不然。2020新年伊始，新冠状病毒从武汉开始蔓延。</p><p>强大的传染力，加上春节的人口流动速率，病毒感染的人口可能远非官方所报道那么多。</p><p>想起2013年的SARS，我高三，生活在小县城也能深切感受到这传染病的威力。<br>每天早读几个温度计班里传递量体温，诊所里板蓝根早早卖断货。<br>晚上自习新闻时间打开电视随时关心病情进展，看到又是几个全身防护的医务人员感染甚至病逝的消息。</p><a id="more"></a>


<p>目前能做的，就是相信国家，好好待在家里，不出去添乱。希望大家一切都好。</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
      <tags>
        <tag>SARS</tag>
        <tag>冠状病毒</tag>
      </tags>
  </entry>
  <entry>
    <title>观看话剧《乌龙山伯爵》</title>
    <url>/p/99326c4a.html</url>
    <content><![CDATA[<p>老早在大麦网预订了开心麻花的话剧《乌龙山伯爵》，下班后急匆匆赶过去。 演出开始前，带着空空的肚子，意外发现了剧场旁边新城市广场背后热闹的夜市，有种台湾夜市的风格。地点： [bmap id=”323”]<br>抽烟小哥的姿势有没有很帅<br><img src="http://pic.l2h.site/l2hsiteIMG_20180112_185624.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 吃了折耳根暴多的狼牙土豆（图左），非常独特的脑花（图右）。完全吃不出脑花的味道（像豆腐）<img src="http://pic.l2h.site/l2hsiteIMG_20180112_185900_HHT.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 很有特点的剧场，位于居民单元楼内，居然不好找。门口黄牛很多，快开场了都还在问有没有多余的票卖给他们。 <img src="http://pic.l2h.site/l2hsite212414020.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 我们坐在舞台12排，观赏位置刚刚好，不会太近也不会太远（其实是之前订票时前排就没票了）。另，幕布很有特点。 <img src="http://pic.l2h.site/l2hsiteIMG_20180112_191451.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"><img src="http://pic.l2h.site/l2hsiteIMG_20180112_195245.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> <img src="http://pic.l2h.site/l2hsiteIMG_20180112_195648.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 剧中最出彩的人物，“同志”K嫂（原谅手机渣像素）<img src="http://pic.l2h.site/l2hsiteIMG_20180112_203928.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 主角谢蟹和玛丽莲：该剧最早期是沈腾和马丽出演，剧中演员说话的方式和声音与这两位家喻户晓的开心麻花演员很像。<img src="http://pic.l2h.site/l2hsiteIMG_20180112_214240.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"><img src="http://pic.l2h.site/l2hsiteIMG_20180112_214403_HHT.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 谢幕，所有的剧中演员<img src="http://pic.l2h.site/l2hsiteIMG_20180112_220313.jpg" alt="观看话剧《乌龙山伯爵》" title="观看话剧《乌龙山伯爵》"> 故事剧情大家可以上网搜索，就不带过来剧透啦。至少个人感受上，全程无尿点，全是笑点。推荐！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>成都</tag>
        <tag>乌龙山伯爵</tag>
        <tag>开心麻花</tag>
      </tags>
  </entry>
  <entry>
    <title>Python按层级解析网页中的ul和li</title>
    <url>/p/752bbc23.html</url>
    <content><![CDATA[<p>最近有需要按层级解析如下格式的内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li&gt;A&lt;/li&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">       &lt;li&gt;A.1&lt;/li&gt;</span><br><span class="line">       &lt;li&gt;A.2&lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">   &lt;li&gt;B&lt;/li&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">       &lt;li&gt;B.1&lt;/li&gt;</span><br><span class="line">       &lt;li&gt;B.2&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">   &lt;li&gt;C&lt;/li&gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">       &lt;li&gt;C.1&lt;/li&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li&gt;C.1.2&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">       &lt;li&gt;C.2&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>做了下搜索，有人建议是使用BeautifulSoup库，但是并没有显示出层级关系。这里写了简单示例，采用嵌套函数解决上述问题。直接看代码：</p>
<p>#导入Beautiful库，如果没有安装就使用pip install bs4安装吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">myxml = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">   &lt;li&gt;A&lt;/li&gt;</span></span><br><span class="line"><span class="string">   &lt;ul&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;A.1&lt;/li&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;A.2&lt;/li&gt;</span></span><br><span class="line"><span class="string">   &lt;/ul&gt;</span></span><br><span class="line"><span class="string">   &lt;li&gt;B&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;B.1&lt;/li&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;B.2&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">   &lt;li&gt;C&lt;/li&gt;</span></span><br><span class="line"><span class="string">       &lt;ul&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;C.1&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">              &lt;li&gt;C.1.2&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">       &lt;li&gt;C.2&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>#ul为Soup要解析的UL，level为列表层级</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSoup</span><span class="params">(ul, level)</span>:</span></span><br><span class="line">    print(<span class="string">"level:"</span>+str(level))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ul.contents:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'\\n'</span> != i:</span><br><span class="line">            <span class="comment">#如果找不到li表示，这个层级已经没有下一层级了，如果有的话，嵌套该函数继续查找</span></span><br><span class="line">            <span class="keyword">if</span> <span class="literal">None</span>!=i.find(<span class="string">'li'</span>):</span><br><span class="line">                findSoup(i, level+<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(str(i.get_text()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印soup变量看看，调用BeautifulSoup后会给加上***html***和***body***标签</span></span><br><span class="line">soup = BeautifulSoup(myxml,<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment">#soup.ul，也可以用soup.find('ul')</span></span><br><span class="line">findSoup(soup.ul, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>以上执行结果如下：</p>
<p>level:0<br>A<br>level:1<br>A.1<br>A.2<br>B<br>level:1<br>B.1<br>B.2<br>C<br>level:1<br>C.1<br>level:2<br>C.1.2<br>C.2</p>
<p>可以看出列表的层级已经分析出来了。以上仅为提供一个思路，如果要做进一步分析，可自行修改。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Wordpress-使用七牛云存储测试域名过期问题解决</title>
    <url>/p/d18fcd54.html</url>
    <content><![CDATA[<p><img src="http://pic.l2h.site/l2hsitec9fcc3cec3fdfc03222bc595dd3f8794a4c2264f.jpg" alt="Wordpress-使用七牛云存储测试域名过期问题解决" title="Wordpress-使用七牛云存储测试域名过期问题解决">博客目前空间很小，一直使用的是<a href="https://portal.qiniu.com/signup?code=3leqs5tm1essy" target="_blank" rel="noopener">七牛云</a>做免费图床 今天登录控制台，发现七牛云公告，测试域名会有过期时间。好在七牛提供了绑定自己所需域名的方法，操作步骤如下：</p><p> 七牛融合 CDN 测试域名（以 clouddn.com/qiniucdn.com/qiniudn.com/qnssl.com/qbox.me 结尾），每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动回收，仅供测试使用，详情查看 <a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="noopener">七牛测试域名使用规范</a> 。点击域名可查看剩余回收时间。</p><a id="more"></a>

<ol>
<li>七牛云后台添加域名：</li>
</ol>
<ul>
<li>绑定域名–&gt;“加速域名”栏位填你自己独立的二级域名（例，<a href="http://pic.l2h.site），注意不要和你网站域名管理列表的解析记录有重复" target="_blank" rel="noopener">http://pic.l2h.site），注意不要和你网站域名管理列表的解析记录有重复</a></li>
<li>其他栏位保留默认</li>
<li>此时七牛会返回一个cname记录pic.l2h.site.qiniudns.com请你添加</li>
</ul>
<ol start="2">
<li>域名服务商处增加cname</li>
</ol>
<ul>
<li>增加pic.l2h.site CNAME解析到pic.l2h.site.qiniudns.com</li>
<li>等待一段时间后，域名解析记录生效，自动更新完成</li>
</ul>
<ol start="3">
<li>博客后台图床插件（我使用的是<a href="http://www.75271.com/" target="_blank" rel="noopener">七牛云图床</a>插件）处，修改七牛绑定域名为<a href="http://pic.l2h.site" target="_blank" rel="noopener">http://pic.l2h.site</a> 4. 根据自己需求，调整之前博客内容中已使用七牛测试域名为新的七牛绑定域名（可以使用php脚本操作） 以上完成后，也不用担心七牛测试域名过期问题了</li>
</ol>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>七牛</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始爬草榴小黄文 (1) - 爬取</title>
    <url>/p/f2b8905c.html</url>
    <content><![CDATA[<p>最近想学习下Python。考虑到一点一点看教程学习过于枯燥，没有时间也没有学习动力。爬虫和Python最常用的功能就是爬虫和数据分析。不如就先从这两样着手做个简单的小项目，爬取一些网站数据，并做一些简单的分析。选定了爬取草榴成人文学的标题列表（不好内容）来作为学术目的。</p><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><h3 id="安装Scrapy"><a href="#安装Scrapy" class="headerlink" title="安装Scrapy"></a>安装Scrapy</h3><p><a href="https://scrapy.org/" target="_blank" rel="noopener">Scrapy</a>是一个现行常用的爬虫框架，扩展性强，拥有强大的爬取和分析能力，安装起来也蛮简单。</p><a id="more"></a>

<blockquote>
<p>** pip install scrapy **  </p>
</blockquote>
<p>当然安装使用起来也有很多的坑会踩，比如说没有安装Twisted、lxml等，这在Python下都不是问题，一个_pip install_搞定。</p>
<p>另外CentOS服务器会碰到运行时找不到__sqlite3模块的错误。靠如下方法搞定：</p>
<ol>
<li>_sudo yum install sqlite-deve_l</li>
<li>重新编译python3.6：<em>./configure –enable-loadable-sqlite-extensions –with-ssl;make;sudo make install</em></li>
</ol>
<p>P.S. 简单的功能，其实爬虫完全可以利用现行的HTTP Request类来写也不复杂。个人只是图省事儿用了Scrapy</p>
<h3 id="安装Pymongo"><a href="#安装Pymongo" class="headerlink" title="安装Pymongo"></a>安装Pymongo</h3><p>原本以为数据量很大，就打算直接使用数据库来存储爬取到的数据，而Python常用的数据库为Mongo，使用需要安装Pymongo（后来发现其实只有2000多条数据，直接存文本就可以的）。</p>
<blockquote>
<p>pip install Pymongo</p>
</blockquote>
<p>这里说一下，数据库我直接使用的是<a href="https://cloud.mongodb.com" target="_blank" rel="noopener">Pymongo官方</a>提供的实验数据库，有500M空间，可以远程使用.</p>
<p>Python使用Pymongo的文档，可以参考<a href="http://api.mongodb.com/python/current/" target="_blank" rel="noopener">pymongo 文档</a></p>
<h2 id="使用Scrapy爬取"><a href="#使用Scrapy爬取" class="headerlink" title="使用Scrapy爬取"></a>使用Scrapy爬取</h2><p>先执行s_crapy startproject 爬虫项目名_来创建项目，得到如下目录结构</p>
<p>t66y<br>    ├── proxy.py<br>    ├── scrapy.cfg<br>    └── t66y<br>        ├── <strong>init</strong>.py<br>        ├── items.py<br>        ├── middlewares.py<br>        ├── pipelines.py<br>        ├── settings.py<br>        └── spiders<br>            └── <strong>init</strong>.py</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们在spiders下建立t66y.py，直接上代码了（为避免教坏小朋友，删掉网址）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> t66y.items <span class="keyword">import</span> T66YItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">t66yLitSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"t66yLit"</span> </span><br><span class="line">    allowed_domains = [<span class="string">'草榴域名'</span>]</span><br><span class="line">    <span class="comment">#start_urls为开始抓取的网址</span></span><br><span class="line">    start_urls = [<span class="string">'http://草榴域名/thread0806.php?fid=20&amp;search=&amp;page=&#123;&#125;'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">22</span>)]</span><br><span class="line">    <span class="comment">#对抓取到的网页进行Xpath解析，得到数据。注意每一个T66YItem对象对应一条pymongo中的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = T66YItem()</span><br><span class="line">        lits = response.xpath(<span class="string">'//tr[@class="tr3 t_one tac"]'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> lit <span class="keyword">in</span> lits:</span><br><span class="line">            item[<span class="string">'lit_type'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]/text()[1]'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_title'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]//h3/a/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_title'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_title'</span>] = item[<span class="string">'lit_title'</span>][<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_url'</span>] = lit.xpath(<span class="string">'.//*[@class="tal"]//h3/a/@href'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_writer'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a/text()'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_submit'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a//following-sibling::*[1]/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_submit'</span>]) == <span class="number">1</span>:</span><br><span class="line">                lit_submit = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[2]/a//following-sibling::*[1]'</span>)</span><br><span class="line">                item[<span class="string">'lit_submit'</span>] = lit_submit.xpath(<span class="string">'string(.)'</span>).extract()[<span class="number">0</span>].strip()</span><br><span class="line">            item[<span class="string">'lit_comments'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[3]/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_comments'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_comments'</span>] = item[<span class="string">'lit_comments'</span>][<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'lit_last_comments'</span>] = lit.xpath(<span class="string">'.//td[1]//following-sibling::*[4]/a/text()'</span>).extract()</span><br><span class="line">            <span class="keyword">if</span> len(item[<span class="string">'lit_last_comments'</span>]) == <span class="number">1</span>:</span><br><span class="line">                item[<span class="string">'lit_last_comments'</span>] = item[<span class="string">'lit_last_comments'</span>][<span class="number">0</span>]</span><br><span class="line">            self.log(<span class="string">"[%s],[%s],[%s],[%s],[%s],[%s],[%s]"</span> % (item[<span class="string">'lit_type'</span>],item[<span class="string">'lit_title'</span>],item[<span class="string">'lit_url'</span>],item[<span class="string">'lit_writer'</span>],item[<span class="string">'lit_submit'</span>],item[<span class="string">'lit_comments'</span>],item[<span class="string">'lit_last_comments'</span>]))</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<p>T66YItem定义在items.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># https://doc.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T66YItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    lit_type = scrapy.Field()</span><br><span class="line">    lit_title = scrapy.Field()</span><br><span class="line">    lit_url = scrapy.Field()</span><br><span class="line">    lit_writer = scrapy.Field()</span><br><span class="line">    lit_submit = scrapy.Field()</span><br><span class="line">    lit_comments = scrapy.Field()</span><br><span class="line">    lit_last_comments = scrapy.Field()</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>pipeline.py负责抓取后的mongodb存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define your item pipelines here</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></span><br><span class="line"><span class="comment"># See: https://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> scrapy.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T66YPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        host = settings[<span class="string">'MONGODB_HOST'</span>]</span><br><span class="line">        user = settings[<span class="string">'MONGODB_USER'</span>]</span><br><span class="line">        passwd = settings[<span class="string">'MONGODB_PASSWD'</span>]</span><br><span class="line">        dbname = settings[<span class="string">'MONGODB_DBNAME'</span>]</span><br><span class="line">        sheetname = settings[<span class="string">'MONGODB_SHEET'</span>]</span><br><span class="line">        client = pymongo.MongoClient(<span class="string">"mongodb+srv://&#123;0&#125;:&#123;1&#125;@&#123;2&#125;/test?retryWrites=true&amp;w=majority"</span>.format(user,passwd,host))</span><br><span class="line">        </span><br><span class="line">        mydb = client[dbname] </span><br><span class="line">        self.post = mydb[sheetname]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        data = dict(item)</span><br><span class="line">        self.post.insert(data)<span class="comment">#这行就是存储mongo数据了</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<p>若要抓取时同步保存，需要对setting.py进行配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BOT_NAME = <span class="string">'t66y'</span></span><br><span class="line"></span><br><span class="line">SPIDER_MODULES = [<span class="string">'t66y.spiders'</span>]</span><br><span class="line">NEWSPIDER_MODULE = <span class="string">'t66y.spiders'</span></span><br><span class="line"><span class="comment">#看到这些配置和t66y.py里的关联了吗。对应配置名就是setting['xxxx']</span></span><br><span class="line">MONGODB_USER = <span class="string">'***'</span></span><br><span class="line">MONGODB_PASSWD = <span class="string">'***'</span></span><br><span class="line">MONGODB_DBNAME = <span class="string">'***'</span></span><br><span class="line">MONGODB_SHEET = <span class="string">'***'</span></span><br><span class="line">MONGODB_HOST = <span class="string">'***.mongodb.net'</span></span><br><span class="line"></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"><span class="comment">#需要定义一个延迟时间，否则会被服务器当成DDOS攻击</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">5</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">   <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">   <span class="string">'Accept-Language'</span>: <span class="string">'en'</span>,</span><br><span class="line">   <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#pipeline的名字要和pipeline.py里定义的类名相同</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'t66y.pipelines.T66YPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到创建工程的时候还有一个middleware.py文件生成，从名字看它应该是一种中间件对吧。其实一般大家用它来更换代理IP（有些网站会查询爬虫的ip，过于频繁的读取会被当成不合规行为，并进行拦截），更换代理IP的代码一般放在此处。当然当碰到网站返回错误要做一些处理的时候，也通常会在这里实现相应代码。好在CL并没有麻烦到需要更换代理IP。</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>直接看在mongoDB存储的内容。可以看到爬取过程中插入操作增多了，右边是爬取到的数据，文章名称过于暴露就不再显示。</p>
<ul>
<li><p><img src="http://pic.l2h.site/1-1024x358.png" alt></p>
</li>
<li><p><img src="http://pic.l2h.site/2-1024x498.png" alt></p>
</li>
</ul>
<p>下一章我们介绍：</p>
<p>Jupyter+Pandas+Pyplot进行简单的数据分析。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>草榴</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>巴蜀文化特色 - 川剧</title>
    <url>/p/4e217d78.html</url>
    <content><![CDATA[<p>川剧，是中国传统戏曲剧种之一，2006年5月20日经国务院批准列入第一批国家级非物质文化遗产名录。 川剧中有很多经典的绝活，如藏刀、皮金滚灯，以及大家熟知的变脸和吐火，现在还融入了传统四川民间绝技杖头木偶（看到过木偶变脸和吐火吗？） 现代人已经很少看戏剧了，包括博主2人也是近日才第一次到剧场观看川剧演出。到场后发现现场基本上都是日本、韩国、台湾的旅行团，也有少数大陆同胞的身影。 整场70分钟，这门传统艺术在现代化设备的辅助展示下，给大伙呈现了一个完整生动的故事。其中穿插了川剧经典的唱法、绝活，加上有名家大师的演绎，总体上感觉绝对超值！强烈推荐！</p><a id="more"></a>
<h2 id="皮金点灯"><a href="#皮金点灯" class="headerlink" title="皮金点灯"></a><strong>皮金点灯</strong></h2><p><img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2273-300x225.jpg" alt>)<img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2276-300x225.jpg" alt></p>
<h2 id="木偶转手绢"><a href="#木偶转手绢" class="headerlink" title="木偶转手绢"></a><strong>木偶转手绢</strong></h2><p><img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2280-300x225.jpg" alt></p>
<h2 id="变脸"><a href="#变脸" class="headerlink" title="变脸"></a><strong>变脸</strong></h2><p><img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2281-300x225.jpg" alt></p>
<h2 id="手影"><a href="#手影" class="headerlink" title="手影"></a><strong>手影</strong></h2><p><img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2267-300x225.jpg" alt>)<img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2265-300x225.jpg" alt></p>
<h2 id="三英战吕布"><a href="#三英战吕布" class="headerlink" title="三英战吕布"></a><strong>三英战吕布</strong></h2><p><img src="http://www.l2h.site/wp-content/uploads/2017/02/IMG_2260-300x225.jpg" alt>  博主是通过大麦网（<a href="https://piao.damai.cn/45430.html）购买的“芙蓉国粹”门票，购买后给大麦网打电话，请大麦网帮忙预约当天或者晚几天的门票，一般需要开场前6个小时才能预约到。" target="_blank" rel="noopener">https://piao.damai.cn/45430.html）购买的“芙蓉国粹”门票，购买后给大麦网打电话，请大麦网帮忙预约当天或者晚几天的门票，一般需要开场前6个小时才能预约到。</a></p>
<blockquote>
<p>基本信息</p>
<p>演出时间</p>
<p>2017.06.30前有效</p>
<p>演出场馆</p>
<p>锦江剧场</p>
<p>演出时长</p>
<p>以现场为准</p>
<p>入场时间</p>
<p>以现场为准</p>
<p>限购</p>
<p>每单限20张。</p>
<p>儿童入场提示</p>
<p>1.1米以下儿童免票入场。</p>
<p>项目介绍</p>
<p>演出时间：每天晚上20：00—21:10 锦江剧场地址：成都市华兴正街54号 订座电话：1010-3721（请务必至少提前6小时预约）</p>
</blockquote>
<p>最后放一段现场所录木偶变脸视频 :-P ： <a href="http://v.youku.com/v_show/id_XMjUxMDE5MTYzNg==.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMjUxMDE5MTYzNg==.html</a></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>变脸</tag>
        <tag>吐火</tag>
        <tag>川剧</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow在线资源汇总</title>
    <url>/p/8236eb14.html</url>
    <content><![CDATA[<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>Tensorflow API在线文档</p>
<p><a href="https://www.l2h.site/docs/tf-api/" target="_blank" rel="noopener">https://www.l2h.site/docs/tf-api/﻿</a></p>
<p>TensorFlow官方文档中文版-v1.2</p>
<p><a href="https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14JdnNyoKTXvJdtWm6TDyvQ</a><br>提取码: qykw</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Que sera sera</title>
    <url>/p/31ce480d.html</url>
    <content><![CDATA[<p>送给现在的自己： Whatever will be, will be.</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>TensorFlow ImportError：DLL加载失败，错误代码为-1073741795 问题解决</title>
    <url>/p/9d38fe83.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>赛扬J3160 CPU，使用pip install tensorflow安装好tensorflow，运行如下代码，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>得到错误如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ImportError: Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\\Users\\Administrator.USER-20190627CO\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\tensorflow\\python\\pywrap_tensorflow.py&quot;, line 58, in &lt;module&gt;</span><br><span class="line">    from tensorflow.python.pywrap_tensorflow_internal import *</span><br><span class="line">  File &quot;C:\\Users\\Administrator.USER-20190627CO\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\tensorflow\\python\\pywrap_tensorflow_internal.py&quot;, line 28, in &lt;module&gt;</span><br><span class="line">    _pywrap_tensorflow_internal = swig_import_helper()</span><br><span class="line">  File &quot;C:\\Users\\Administrator.USER-20190627CO\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\tensorflow\\python\\pywrap_tensorflow_internal.py&quot;, line 24, in swig_import_helper</span><br><span class="line">    _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description)</span><br><span class="line">  File &quot;C:\\Users\\Administrator.USER-20190627CO\\AppData\\Local\\Programs\\Python\\Python37\\lib\\imp.py&quot;, line 242, in load_module</span><br><span class="line">    return load_dynamic(name, filename, file)</span><br><span class="line">  File &quot;C:\\Users\\Administrator.USER-20190627CO\\AppData\\Local\\Programs\\Python\\Python37\\lib\\imp.py&quot;, line 342, in load_dynamic</span><br><span class="line">    return _load(spec)</span><br><span class="line">ImportError: DLL load failed with error code -1073741795</span><br></pre></td></tr></table></figure>

<p>找到<a href="https://github.com/tensorflow/tensorflow/issues/17386" target="_blank" rel="noopener">github上</a>有人碰到类似错误，原因是CPU缺少 AVX 指令集支持（看来是赛扬处理器稍低端了）。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解法也很简单，依次执行如下步骤:</p>
<ul>
<li>pip uninstall tensorflow</li>
<li>到<a href="https://github.com/fo40225/tensorflow-windows-wheel" target="_blank" rel="noopener">github</a>下不支持AVX指令集的tensorflow轮子。一般选最新版的tensorflow；注意您的python版本，若是3.7，就选1.x.0/py37/CPU/sse2下的wheel</li>
<li>下好到本地后执行“pip install 刚刚下好wheel的本地路径”</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>31了</title>
    <url>/p/dc2eb2d4.html</url>
    <content><![CDATA[<p>生活不易，且行且珍惜 又过一个年头，希望所有的愿望都能达成，要坚信！</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H随感</category>
      </categories>
  </entry>
  <entry>
    <title>成都&quot;天府通&quot;公交卡使用姿势</title>
    <url>/p/ecf51a63.html</url>
    <content><![CDATA[<p>今天小站为大家解锁下成都”天府通”公交卡使用姿势。 【卡片长相】</p><p>天府通公交卡为普通磁卡大小，正面印有天府通徽标和字样。目前发行的卡中有各色卡通或纪念图案（下图为标准图案）。可到天府通官方淘宝店查看(<a href="https://shop.m.taobao.com/shop/shop_index.htm?spm=0.0.0.0&shop_id=174922064" target="_blank" rel="noopener">Link</a>)</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1488682387418&di=b1b13add1bd595b357dfd0c659fb35c9&imgtype=0&src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160913%2Fc8e5831cf13c412fbb94d1ab5b779e89_th.jpeg" alt> 【购买方式】</p><ol>
<li>地铁站 天府通售卡点</li>
<li>地铁站 自助售卡充值机(可买到异形卡，纪念卡，家不远的磨子桥站就有)</li>
<li>各大红旗超市</li>
<li>街边小卖部</li>
<li>小店提供一张标准卡免费借用</li>
</ol><a id="more"></a>



<p>【充值方式】</p>
<ol>
<li>地铁站 天府通售卡点</li>
<li>地铁站 自助售卡充值机</li>
<li>各大红旗超市</li>
<li>网上充值？</li>
</ol>
<p>【使用范围】 每张“天府通”公交卡有两个账户： <strong>电子钱包账户： 使用范围（地铁、公交） 使用时间（长期有效）充值及优惠（10元倍数充值。乘公交地铁均为9折）</strong> <strong>次数账户： 使用范围（市内300路以下公交） 使用时间（当月有效）充值及优惠（10元倍数充值。乘车一次五折，2小时内公交转乘免费）</strong></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
      <tags>
        <tag>成都</tag>
        <tag>公交</tag>
        <tag>天府通</tag>
      </tags>
  </entry>
  <entry>
    <title>L&amp;H的西藏之行(2016.6--林芝+拉萨)</title>
    <url>/p/1ca35244.html</url>
    <content><![CDATA[<p>注：这是一篇旅行回忆，旅行时间2016端午前后 <img src="https://dimg02.c-ctrip.com/images/100t0o000000eohvfC218_R_600_10000.jpg" alt> 一直想去西藏，但一直惧怕于高原反应，终于在2016年端午成行。</p><h2 id="行"><a href="#行" class="headerlink" title="行"></a><strong>行</strong></h2><p>半自由行：自己定的机票，几乎大半的行程都是跟团，具体花费如下： <img src="https://dimg02.c-ctrip.com/images/100h0o000000eptk3D926.png" alt> <img src="https://dimg02.c-ctrip.com/images/100p0o000000en06p022D.png" alt></p><h2 id="住"><a href="#住" class="headerlink" title="住"></a><strong>住</strong></h2><p>大部分时间住在太阳岛上，团队游的旅店。另外两天住在ABNB定的民宿 <img src="https://dimg02.c-ctrip.com/images/10080o000000eoozq110B.png" alt></p><h2 id="食"><a href="#食" class="headerlink" title="食"></a><strong>食</strong></h2><p>尝了一顿当地地道的藏餐：藏面+不知道叫什么名的油饼+甜茶 藏面：圆圆粗粗的，口感跟粗拉面有点像，但是不够劲道 油饼：应该是用青稞做的，泡藏面吃，味道一般 甜茶：甜，味道像奶茶。5块钱满满一暖水瓶，老夫+老婆喝不完啊！还外带了一保温杯（可惜没有枸杞）</p><a id="more"></a>



<h2 id="衣"><a href="#衣" class="headerlink" title="衣"></a><strong>衣</strong></h2><p>昼夜温差大，干燥，晒，有小风。 请带好防晒和保暖装备</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a><strong>感受</strong></h2><p>1. 透，亮，美 （下飞机后第一感觉） 2. 高原反应（前两天会有） 3. 信仰（整个藏区都是拿着转经筒或酥油壶，几步一叩拜的人民） 4. 不虚此行+流连忘返 5. 我还会回来的（毕竟只去了昌都地区的一小部分和林芝地区。现在林拉高速公路开了，应该可以自驾了吧？）</p>
<h2 id="照片"><a href="#照片" class="headerlink" title="照片"></a><strong>照片</strong></h2><h3 id="不同角度的布达拉宫"><a href="#不同角度的布达拉宫" class="headerlink" title="不同角度的布达拉宫"></a>不同角度的布达拉宫</h3><p><img src="https://dimg02.c-ctrip.com/images/100w0o000000euhpt2CB3_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100e0o000000er87e58B6_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/10040o000000en7m096DC_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100w0o000000euhq42785_R_600_10000.jpg" alt></p>
<h3 id="八廓街–大昭寺门前"><a href="#八廓街–大昭寺门前" class="headerlink" title="八廓街–大昭寺门前"></a>八廓街–大昭寺门前</h3><p><img src="https://dimg02.c-ctrip.com/images/100c0o000000er46sE9B8_R_600_10000.jpg" alt></p>
<h3 id="米拉山口（拉萨–林芝-路程中）"><a href="#米拉山口（拉萨–林芝-路程中）" class="headerlink" title="米拉山口（拉萨–林芝 路程中）"></a>米拉山口（拉萨–林芝 路程中）</h3><p><img src="https://dimg02.c-ctrip.com/images/100f0o000000enwlf1861_R_600_10000.jpg" alt></p>
<h3 id="林芝"><a href="#林芝" class="headerlink" title="林芝"></a>林芝</h3><p><img src="https://dimg02.c-ctrip.com/images/100b0o000000eqv70C133_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100j0o000000enzhg86C9_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100i0o000000en8h4ED12_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100e0o000000er87s4B43_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/10090o000000equ0s4015_R_600_10000.jpg" alt></p>
<h3 id="圣湖纳木错"><a href="#圣湖纳木错" class="headerlink" title="圣湖纳木错"></a>圣湖纳木错</h3><p><img src="https://dimg02.c-ctrip.com/images/100b0o000000eqv6x270D_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100q0o000000epntdC9FA_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100d0o000000emyxfA039_R_600_10000.jpg" alt> <img src="https://dimg02.c-ctrip.com/images/100b0o000000eqv7480B7_R_600_10000.jpg" alt></p>
<h3 id="桑丁寺"><a href="#桑丁寺" class="headerlink" title="桑丁寺"></a>桑丁寺</h3><p>拉萨到羊卓雍错路上，西藏现存的香巴噶举派少数寺院之一，西藏唯一女活佛桑顶·多吉帕姆的处所 <img src="https://dimg02.c-ctrip.com/images/100i0o000000en8hbC343_R_600_10000.jpg" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>拉萨</tag>
        <tag>林芝</tag>
        <tag>纳木错</tag>
        <tag>羊卓雍错</tag>
        <tag>西藏</tag>
      </tags>
  </entry>
  <entry>
    <title>L的博客时光机</title>
    <url>/p/e8523316.html</url>
    <content><![CDATA[<p>突然想起自己以往懵懂的日子，也多次建了个人博客。 随着空间的消失，域名的回收，小站的内容也一去不复返了。 今天突然想起有<a href="https://web.archive.org/" target="_blank" rel="noopener">webarchive</a>这个网站，抱着试试看的心态，居然回收了一些内容回来：</p><ol>
<li>本科期间的建站– COGT.cn</li>
<li>读研期间的建站– imlambert.tk/lambert-scape.appspot.com</li>
</ol><a id="more"></a>

<p>科学上网，google上找到了之前自己写的一些小程序，打算把这些内容加回来作为纪念。 人还真是越老越怀旧。 ![L的博客时光机](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-07 上午1.28.14.png “L的博客时光机”)![L的博客时光机](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-07 上午1.28.56.png “L的博客时光机”)![L的博客时光机](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-07 上午1.31.16.png “L的博客时光机”)![L的博客时光机](<a href="http://pic.l2h.site/l2hsite屏幕快照" target="_blank" rel="noopener">http://pic.l2h.site/l2hsite屏幕快照</a> 2018-10-07 上午1.31.32.png “L的博客时光机”)</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
      <tags>
        <tag>网站历史</tag>
      </tags>
  </entry>
  <entry>
    <title>Tumblr:全面禁成人内容</title>
    <url>/p/feba95de.html</url>
    <content><![CDATA[<blockquote>
<p>「随着 Tumblr 的发展，我们更清楚自己对这个世界的影响，我们有责任去考量这份影响力在不同年龄、文化、观念人群中会造成什么样的反应。」官方在声明中这么写道，「我们花了很多精力去权衡利弊，最终认为去除成人内容会让我们有机会创造一个更多人能自在表达自我的环境」</p>
<p>「显示真实人类生殖器或女性露出乳头的图像、视频或 GIF 动图」以及「非常逼真以至于可能被误认为是现实人类的内容」都属于 Tumblr 定义的「成人内容」</p>
</blockquote><a id="more"></a>
<p>相信很多老司机看到以上公告都哇凉哇凉啦：执行从12月17日开始。看起来是用<a href="https://www.l2h.site/category/machine-learning/" target="_blank" rel="noopener">机器学习</a>自动筛选的，因此考验机器人的时刻到啦。</p>
<p>相信很多老司机都会执行如下操作XD？</p>
<p><img src="http://pic.l2h.site/IMG_20181205_220300-663x1024.jpg" alt="Tumblr 禁止成人内容"></p>
<p>Tumblr禁止成人内容</p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>两只萌物</title>
    <url>/p/9a45d70.html</url>
    <content><![CDATA[<p>今天请假去办事，办完事一时兴起到青石桥转了一圈。和老婆提了两只小萌物回家，就叫”赖宝”和”孬宝”吧？</p>
<p>好吧，叫“一五”和“一十”吧</p>
<p><img src="http://pic.l2h.site/l2hsiteIMG_20181010_173111.jpg" alt="两只萌物" title="两只萌物"><br><img src="http://pic.l2h.site/l2hsiteIMG_20181010_172910.jpg" alt="两只萌物" title="两只萌物"><br><img src="http://pic.l2h.site/l2hsiteIMG_20181010_172901.jpg" alt="两只萌物" title="两只萌物"></p>
<p>两个月后的灰兔子，长得真快：</p>
<hr>
<p><img src="http://pic.l2h.site/IMG_20181202_205944-1024x764.jpg" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>Welcome to L&amp;H&#39;s Site</title>
    <url>/p/ab8b0a4c.html</url>
    <content><![CDATA[<blockquote>
<p><code>[bmap id=&quot;303&quot;]</code></p>
<p>欢迎光临Lambert和XH的家。请留言提供您的意见或者建议，期待给您提供更好的服务。 Welcome to Lamb &amp; XH’s Site. Please leave a comment here. We look forward to provide better service in near future.</p>
</blockquote><a id="more"></a>
<p>欢迎<strong>预订</strong>(<strong>Reserve</strong> my room) <strong>@</strong><a href="http://cd.xiaozhu.com/fangzi/5940252416.html" target="_blank" rel="noopener">小猪短租</a> <strong>@</strong>AbNb @<a href="https://m.tujia.com/chengdu_gongyu/wuhouqu_176798.htm" target="_blank" rel="noopener">途家</a> </p>
<ul>
<li>客厅(Living Room)</li>
</ul>
<p><img src="http://pic.l2h.site/11-300x200.png" alt> <img src="https://www.l2h.site/wp-content/uploads/2017/01/IMG_2096-300x200.jpg" alt></p>
<ul>
<li>卧室(Bedroom)</li>
</ul>
<p><img src="http://pic.l2h.site/6-300x200.png" alt></p>
<ul>
<li>浴室(Bath room)</li>
</ul>
<p><img src="http://pic.l2h.site/IMG_2090-200x300.jpg" alt></p>
<ul>
<li>厨房(Kitchen)</li>
</ul>
<p><img src="http://pic.l2h.site/7-300x200.png" alt></p>
]]></content>
      <categories>
        <category>L&amp;amp;H Site</category>
      </categories>
  </entry>
  <entry>
    <title>门口的阴凉-望江楼公园</title>
    <url>/p/85c30ed5.html</url>
    <content><![CDATA[<ul>
<li>在望江校区读了三年书，L&amp;H Site也坐落于锦江畔，却一直没有到过望江楼公园。</li>
</ul>
<p>今天暖日当头，和H一起到公园小逛，直直感受到望江楼公园的魅力。纯净的空气在十面“霾”伏的“尘”都也实属难得。放上一些随手所拍的照片： <strong>公园位置</strong> <code>[bmap id=&quot;331&quot;]</code> <strong>公园东大门</strong> <img src="http://pic.l2h.site/l2hsiteIMG_20180114_172148.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>公园河边</strong> <img src="http://pic.l2h.site/l2hsiteIMG_20180114_180232.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>公园内各种竹子</strong><img src="http://pic.l2h.site/l2hsiteIMG_20180114_172532.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"><img src="http://pic.l2h.site/l2hsiteIMG_20180114_172808_mh1515936176498.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"><img src="http://pic.l2h.site/l2hsiteIMG_20180114_172241_mh1515936237315.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>到处可见的辣妹</strong>（腊梅，^_^） <img src="http://pic.l2h.site/l2hsiteIMG_20180114_173548_mh1515935942963.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>平静清澈的水面</strong><img src="http://pic.l2h.site/l2hsiteIMG_20180114_175936.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"><img src="http://pic.l2h.site/l2hsiteIMG_20180114_180001.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>园内风景</strong><img src="http://pic.l2h.site/l2hsiteIMG_20180114_175804.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"><img src="http://pic.l2h.site/l2hsiteIMG_20180114_175727.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"> <strong>公园游乐场 （居然还有碰碰车，怀念）</strong> <img src="http://pic.l2h.site/l2hsiteIMG_20180114_175003.jpg" alt="门口的阴凉-望江楼公园" title="门口的阴凉-望江楼公园"></p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
        <category>L&amp;amp;H游记</category>
      </categories>
      <tags>
        <tag>成都</tag>
        <tag>九眼桥</tag>
        <tag>公园</tag>
        <tag>望江楼</tag>
      </tags>
  </entry>
  <entry>
    <title>优信二手车广告什么鬼，代古拉K什么人</title>
    <url>/p/744362e1.html</url>
    <content><![CDATA[<p>那个斯外戈真欠扁。据说两个人还都是抖音网红，广告真心辣眼睛，一个春节都被辣惨了！低俗广告，恶心！</p>
<p><img src="http://pic.l2h.site/IMG_20190210_234432.jpg" alt></p>
<p>这是什么鬼</p>
]]></content>
      <categories>
        <category>L&amp;amp;H生活</category>
      </categories>
  </entry>
  <entry>
    <title>Word Embedding（词嵌入）模型介绍</title>
    <url>/p/6a6334.html</url>
    <content><![CDATA[<p>词嵌入可以算是无监督机器学习最成功的应用之一。它不要求对数据标注，就可以从未标注预料里产生标注。单词嵌入可以从输入的字符产生量更小的向量标签，可以使得被使用到后续的其他学习任务中。</p><h2 id="词嵌入的概念"><a href="#词嵌入的概念" class="headerlink" title="词嵌入的概念"></a>词嵌入的概念</h2><p>简言之，词嵌入是指将文本转化为数字表示的方法。为什么需要词嵌入呢？</p><p>众所周知，许多机器学习算法，甚至几乎所有的深度学习算法，是无法直接处理字符串或者纯文本形式的输入。相反，他们需要数字作为各种任务的输入（例如分类、回归等）。不过，通常任务（例，网站评论中的情感分析）中大量的数据字段都是文本格式的，因此在需要学习前必须从这些文本输入中提取出数字表示的信息。因此，我们可以给词嵌入一个正式的定义：</p><a id="more"></a>


<blockquote>
<p>词嵌入方法，是将字典中的单词转化为向量的方法。</p>
</blockquote>
<p>例如，我们对如下句子做词嵌入：</p>
<blockquote>
<p>Word Embeddings are Word converted into numbers</p>
</blockquote>
<p>“词”指的是类似句子中的“Embedding”、“numbers”等</p>
<p>“字典”指的是句子中所有不重复单词的列表。所以，上述句子的词典是[‘Word’,’Embeddings’,’are’,’Converted’,’into’,’numbers’]</p>
<h2 id="词嵌入的不同方法"><a href="#词嵌入的不同方法" class="headerlink" title="词嵌入的不同方法"></a>词嵌入的不同方法</h2><p>我们当然可以使用本博客&lt;<a href="https://www.l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/" target="_blank" rel="noopener">机器学习为什么使用独热(ONE-HOT ENCODING)编码</a>&gt;介绍的独热编码进行词嵌入，这是一种较为简单的处理方式。除此之外，还有许多不同的词嵌入方法。这些词嵌入方法可以大概分为如下两类：</p>
<ul>
<li>基于频率的嵌入（简称“词频嵌入”）</li>
<li>基于预测的嵌入</li>
</ul>
<p>我们本节会深入介绍这两类方法。</p>
<h3 id="词频嵌入"><a href="#词频嵌入" class="headerlink" title="词频嵌入"></a>词频嵌入</h3><p>现行流行的词频嵌入方法包括如下几类的嵌入向量：</p>
<ul>
<li>Count Vector</li>
<li>TF_IDF Vector</li>
<li>Co-Occurence Vector</li>
</ul>
<h4 id="Count-Vector"><a href="#Count-Vector" class="headerlink" title="Count Vector"></a>Count Vector</h4><p>考虑包括如下D个文档$${d_1,d_2,…..,d_D}$$的语料库及从C中提取的N个唯一单词。这N个唯一单词组成我们的字典，对应Count Vector矩阵M的大小为$$D*N$$。矩阵M的每一行为$$d_i$$文档中的单词频率。</p>
<p>举个简单的例子：</p>
<ul>
<li>$$d_1$$: He is a lazy boy. She is also lazy</li>
<li>$$d_2$$: Neeraj is a lazy person</li>
</ul>
<p>这两个文档形成字典：[‘He’,’She’,’lazy’,’boy’,’Neeraj’,’person’]，这里D=2，N=6，则该2*6矩阵M可作如下表示：</p>
<p>He</p>
<p>She</p>
<p>lazy</p>
<p>boy</p>
<p>Neeraj</p>
<p>person</p>
<p>$$d_1$$</p>
<p>1</p>
<p>1</p>
<p>2</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>$$d_2$$</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>这里，每一行代表的是文档集合中的一个文档，每一列代表的是单词。这样，矩阵中的一列就代表对应单词的词向量。例如，“lazy”的词向量为[2,1]。</p>
<p>很简单不是吗。不过这里有很多不同的形成矩阵M的变种方法。主要有两大类：</p>
<ul>
<li>字典的形成方式。以上为一个理想的例子，但一个现实问题往往有成千上万个文本作为语料。所以向量往往是成千上万列。而一种替代的表示方法是取其中10000个单词作为字典。</li>
<li>每个单词数量的表示方式。我们可以用单词出现的数量或者是单词是否出现来表示（一般是采用前者）。</li>
</ul>
<p>下图帮忙理解矩阵M的形式：</p>
<p><img src="http://pic.l2h.site/count-vector.png" alt></p>
<h4 id="TF-IDF-Vector"><a href="#TF-IDF-Vector" class="headerlink" title="TF-IDF Vector"></a>TF-IDF Vector</h4><p>TF-IDF是另外一种基于词频的方法，但是计算词频时不仅仅考虑单个文档而是整个预料。这其中的原理是什么呢？</p>
<p>常用词‘is’、‘the’、‘a’等词在英文文档中通常出现的频率超过文档的主要词汇。例如，描述梅西的文档中会比其他文档更常出现‘Messi’一词。但是诸如‘the’一词在所有文档（当然是英文文档）都以很高频率出现。</p>
<p>理想状态下，我们更希望降低这些在所有文档中都会出现的词，相反提升其他文档相关性更高单词的频率。TF-IDF的工作原理，便是给这些常现词一些惩罚，赋予更低的权重。我们以如下两个文档范例看TF-IDF的工作方式：</p>
<p><img src="http://pic.l2h.site/Tf-IDF.png" alt></p>
<p>与TF-IDF相关的定义有如下：</p>
<p>$$f()=TF =\frac{t单词出现在文档的次数}{文档中单词的总数量}$$</p>
<p>因此 TF(This, Document1) = 1/8, TF(This, Document2) = 1/5</p>
<p>TF代表了单词对文档的“贡献”。即，与文档相关的单词应该出现频率更高。例，关于梅西的文档里，“梅西”单词出现的频率一定很高。</p>
<p>$$IDF=log(N/n)$$</p>
<p>其中N代表文档的数量，n代表t单词有出现的文档的数量。因此IDF(This)=log(2/2)=0</p>
<p>因此如何解释IDF背后的原理？一般情况下，如果一个单词在所有的单词中都出现，那么很有可能这个单词与某一个特定的文档关联不大。如果单词只在一部分文档中出现，那么该单词与其所出现的文档关联的可能性就较大。我们可以计算上例中“Messi”一词的IDF为：</p>
<p>$$IDF(Messi)=log(2/1)=0.301$$</p>
<p>现在，让我们来对比“This”和“Messi”对Document1的关联性。</p>
<blockquote>
<p>TF-IDF(This, Document1) = (1/8)*(0)=0</p>
<p>TF-IDF(This, Document2)=(1/5)*(0)=0</p>
<p>TF-IDF(Messi, Document1) = (4/8)*0.301 = 0.15  </p>
</blockquote>
<p>因此我们可以看到，对Document1，TF-IDF方法对“This”赋予较小的权重，远小于单词“Messi”。因此在整个语料库里，“Messi”对Document1是非常重要的单词。</p>
<h4 id="固定上下文窗口的Co-Occurence矩阵"><a href="#固定上下文窗口的Co-Occurence矩阵" class="headerlink" title="固定上下文窗口的Co-Occurence矩阵"></a>固定上下文窗口的Co-Occurence矩阵</h4><p>该方法主要思想为：类似的单词有一起出现的倾向，也有相同的上下文。例，苹果是一种水果，芒果也是一种水果。苹果和芒果倾向于有相同的上下文。即，水果。</p>
<p>我们先理解一下Co-Occurence和上下文窗口的含义，再具体介绍该方法。</p>
<p>Co-Occurence：给定语料，一对单词W1和W2的Co-Occurence指的是他们在一个上下文窗口一起出现的次数。</p>
<p>Context Window: 上下文窗口由一个数字和方向指定。让我们看如下例子：</p>
<p>Quick</p>
<p>Brown</p>
<p>Fox</p>
<p>Jump</p>
<p>Over</p>
<p>The</p>
<p>Lazy</p>
<p>Dog</p>
<p>紫色框字体是“Fox”的大小为2的上下文窗口，当计算co-occurence时，只有这些单词会算在内。同理，对单词“Over”的上下文窗口为：</p>
<p>Quick</p>
<p>Brown</p>
<p>Fox</p>
<p>Jump</p>
<p>Over</p>
<p>The</p>
<p>Lazy</p>
<p>Dog</p>
<p>因此，让我们使用一个范例语料来描述Co-Occurence矩阵。语料为： He is not lazy. He is intelligent. He is smart。则语料矩阵为：</p>
<p><strong>He</strong></p>
<p><strong>is</strong></p>
<p><strong>not</strong></p>
<p><strong>lazy</strong></p>
<p><strong>intelligent</strong></p>
<p><strong>smart</strong></p>
<p><strong>He</strong></p>
<p>0</p>
<p>4</p>
<p>2</p>
<p>1</p>
<p>2</p>
<p>1</p>
<p><strong>is</strong></p>
<p>4</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>2</p>
<p>1</p>
<p><strong>not</strong></p>
<p>2</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p><strong>lazy</strong></p>
<p>1</p>
<p>2</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p><strong>intelligent</strong></p>
<p>2</p>
<p>2</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p><strong>smart</strong></p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>上图中红色的单元表示”He”和”is”在2长度的上下文窗口的值为4，而“lazy”和“intelligent”的上下文窗口值为0。</p>
<p>但是真实的语料库往往有很多单词，如果构建像上表一样的N*N矩阵，对计算机处理起来复杂度过高。因此这个矩阵往往是N*M大小的矩阵，其中M为N的子集。即选择字典中的最重要的一些单词作为矩阵的其一维度。选择的方法有SVD，PCA分析等方法。</p>
<p>Co-Occurence矩阵的优势：</p>
<ul>
<li>保留了单词间的语义关系。例如“男人”和“女人”的距离近过“男人”和“苹果”</li>
<li>使用SVD作为其核心，比现有其他方法来输出更为精确的单词向量。</li>
<li>只需要做一次计算，之后可直接使用。</li>
</ul>
<p>Co-Occurence矩阵的缺点：</p>
<ul>
<li>使用大量的内存来存储Co-Occurence矩阵。当然，有一些现有的方法可以减轻该问题。</li>
</ul>
<h3 id="基于预测的嵌入"><a href="#基于预测的嵌入" class="headerlink" title="基于预测的嵌入"></a>基于预测的嵌入</h3><p>上述基于词频的计算单词嵌入方法的应用范围有限。直到word2vec这种基于预测的嵌入方法被提出并广泛应用到现有的各种场景中。而Wordvec并不是一个单独的算法，而是两种算法模型：CBOW（Continuous bag of words）和Skip-gram的组合。这两种方法均是浅神经网络，可以接受单词作为输入，同样使用单词作为输出，并映射为向量。下面分别进行介绍。</p>
<h4 id="CBOW-Continuous-Bag-of-words"><a href="#CBOW-Continuous-Bag-of-words" class="headerlink" title="CBOW(Continuous Bag of words)"></a>CBOW(Continuous Bag of words)</h4><p>CBOW模型工作的原理是根据输入的上下文来预测输出单词的概率。上下文可能为一个单词，或者是一组单词。为了描述方便，我们以一个单词作为输入来预测一个单词输出。</p>
<p>假设我们的语料为 C = “Hey, this is sample corpus using only one context word.”同时定义上下文窗口为1。输入语料可以以如下<a href="https://www.l2h.site/2019/07/09/%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e7%8b%ac%e7%83%adone-hot-encoding%e7%bc%96%e7%a0%81/" target="_blank" rel="noopener">独热编码</a>方式呈现：</p>
<p><img src="http://pic.l2h.site/cbow1-1024x289.png" alt></p>
<p>上述矩阵被送到一个三层神经网络来训练：包含输入层，隐层和输出层。其中输出层是一个softmax层，用来呈现输出层为某个单词的可能性。</p>
<p>下图呈现了CBOW的网络模型：</p>
<p><img src="http://pic.l2h.site/Screenshot-from-2017-06-04-22-40-29.png" alt></p>
<p>上面架构的矩阵表示如下图：</p>
<p><img src="http://pic.l2h.site/Screenshot-from-2017-06-04-22-19-202-1024x154.png" alt></p>
<p>计算方法如下：</p>
<ul>
<li>输入层和输出均为[1*V]的独热向量，V表示上述语料的字典大小</li>
<li>输入层和隐层，以及隐层和输出层分别有节点间权重矩阵大小为[V*N]，以及[N*V]。N为隐层神经元的数量，这里N=4</li>
<li>层与层之间没有激活函数</li>
<li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）</li>
<li>隐藏输出乘以隐层-输出层权重得到输出</li>
<li>根据输出使用逆传播算法来调整权重</li>
<li>隐藏-输出层权重被用作最后的词向量</li>
</ul>
<p>以上为一个输入的例子，假如是多个输入呢？</p>
<p><img src="http://pic.l2h.site/1-1.png" alt></p>
<p>上述为多个输入的神经网络架构，而下图为其矩阵表示：</p>
<p><img src="http://pic.l2h.site/2-3-1024x150.png" alt></p>
<p>输入三个上下文单词预测一个目标单词。输入可以用三个独热向量表示。上述输入层有3个[1*V]向量作为输入，以及一个[1*V]向量作为输出。</p>
<p>以上计算方法与单输入的CBOW模型类似。只不过最终的输出为多个权重矩阵的算术平均值</p>
<p>上述算法与一般神经网络类似，主要差异在于：</p>
<ul>
<li>不同于计算算术平方误差作为损失，CBOW是计算最小化选中单词的负对数似然</li>
<li>CBOW每层神经元未使用激活函数做非线性化激活</li>
</ul>
<h4 id="Skip-–-Gram模型"><a href="#Skip-–-Gram模型" class="headerlink" title="Skip – Gram模型"></a>Skip – Gram模型</h4><p>Skip-gram模型与CBOW架构类似。不过其核心思想与CBOW正好相反，是给定单词预测期上下文。架构如图：</p>
<p><img src="http://pic.l2h.site/3-1.png" alt></p>
<p>其矩阵形式架构如图：</p>
<p><img src="http://pic.l2h.site/4-1024x223.png" alt></p>
<p>输入层大小为[1*V]，输入-隐层权重矩阵大小[V*N]，输出-权重矩阵[N*V]，输出层大小[1*V]</p>
<p>计算方法如下：</p>
<ul>
<li>上图红色输入为独热编码</li>
<li>中间桔黄色矩阵为隐层-输出层权重矩阵。</li>
<li>用“隐层激活(Hidden Activation)”表示输入数据乘以输入层-隐层间权重（矩阵乘法）， 桔黄色矩阵乘以 “隐层激活(Hidden Activation)” 得到蓝色矩阵</li>
<li>图右蓝色矩阵的每行使用Softmax进行计算得到图右绿色矩阵。</li>
<li>图右灰色矩阵为输入单词上下文的2两个单词的独热编码。使用绿色矩阵逐行减去灰色矩阵，得到误差向量</li>
<li>对所有的输入计算误差向量后求和得到损失，并进行逆传播优化。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了基于词频和基于预测的两种嵌入方式，并对其中的常用模型进行了介绍。其中基于预测的嵌入方式是现行较为常用且有效的方式。其模型CBOW和Skip-Gram分别为使用上下文预测单词和使用单词预测上下文的两种不同模型，均为广泛使用。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Embedding</tag>
        <tag>嵌入</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress:解决Autoptimize+Enlighter插件冲突</title>
    <url>/p/e99a7598.html</url>
    <content><![CDATA[<p>最近博客增加了不少图片，头部也增加了不少自定义代码，导致页面打开速度变慢。便在后台给博客增加了Autoptimize插件压缩一下CSS和JS脚本，以减小页面大小。安装后，整体运行速度的确有提高。但是打开类似文章《<a href="https://www.l2h.site/2018/10/24/linux-low-power-1/" target="_blank" rel="noopener">LINUX电源管理介绍-1</a>》后，发现里边的Enlighter代码高亮全不见了。如下图：</p><p><img src="http://pic.l2h.site/autoptimize-enlighter-conflict-1.png" alt="Wordpress:解决Autoptimize+Enlighter插件冲突"></p><p><a href="http://www.bing.com" target="_blank" rel="noopener">Bing搜索</a>，Autoptimize支持特定脚本或者CSS不压缩。可通过以下方式解决：</p><a id="more"></a>


<ol>
<li><p>打开后台，Autoptimize设定</p>
</li>
<li><p>选择右上方高级设定</p>
</li>
</ol>
<p><img src="http://pic.l2h.site/autoptimize-enlighter-conflict-2.png" alt="Wordpress:解决Autoptimize+Enlighter插件冲突"></p>
<ol start="3">
<li>找到“JavaScript 选项–&gt;从 Autoptimize 排除脚本”（注：后台英文的就查找exclude关键字），添加如下脚本到排除脚本：</li>
</ol>
<blockquote>
<p>mootools-core-yc.js, EnlighterJS.min.js</p>
</blockquote>
<p><img src="http://pic.l2h.site/autoptimize-enlighter-conflict-3.png" alt="Wordpress:解决Autoptimize+Enlighter插件冲突"></p>
<ol start="4">
<li>保存，并删除页面缓存后，问题解决：</li>
</ol>
<p><img src="http://pic.l2h.site/autoptimize-enlighter-conflict-4.png" alt="Wordpress:解决Autoptimize+Enlighter插件冲突"></p>
<p>Wordpress:解决Autoptimize+Enlighter插件冲突</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>Gutenberg</tag>
        <tag>Autoptimze</tag>
        <tag>Enlighter</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress--免修改scandir添加模板页面</title>
    <url>/p/90e39fac.html</url>
    <content><![CDATA[<p>今天打算给博客增加个友链内页，发现新增页面时没有选择模板的栏位。 <img src="http://pic.l2h.site/l2hsitelink-page-6.PNG" alt="Wordpress--无法修改scandir如何按照模板添加模板页面" title="Wordpress--无法修改scandir如何按照模板添加模板页面"> 搜索了下，说是需要修改php.ini的scandir属性，将其从disable项目里去掉。但博客因为是虚拟主机，后台提供的修改栏位很少，无法更改。 追了下增加页面的源码，发现可以到数据库的post_meta表中增加项目来完成。  好在虚拟主机提供商有数据库在线编辑的功能，具体操作步骤如下：</p><a id="more"></a>
<ul>
<li><ol>
<li>按照网上的介绍从page.php拷贝修改新增模板页，假设名为fr-links.php</li>
<li>博客后台新建页面</li>
<li>登录到数据库管理页(比较常见的是phpmyadmin)</li>
<li>打开wordpress的post表，找到新建页面的id并记下，注意：wordpress会为revision增加表项，所以请选择post_status为publish的表项<img src="http://pic.l2h.site/l2hsitelink-page-2.PNG" alt="Wordpress--无法修改scandir如何按照模板添加模板页面" title="Wordpress--无法修改scandir如何按照模板添加模板页面"> <img src="http://pic.l2h.site/l2hsitelink-page-3.PNG" alt="Wordpress--无法修改scandir如何按照模板添加模板页面" title="Wordpress--无法修改scandir如何按照模板添加模板页面"></li>
<li>打开post_meta表，新增一项（注意meta_id不要重复，且是往后顺延添加），post_id为新增页面的ID（即Post表中的ID）, meta_key填入_wp_page_template，meta_value填入你第一步新增的模板页名字“fr-links.php”<img src="http://pic.l2h.site/l2hsitelink-page-1.PNG" alt="Wordpress--无法修改scandir如何按照模板添加模板页面" title="Wordpress--无法修改scandir如何按照模板添加模板页面"></li>
<li>修改成功，效果如下。注意如果以后要在后台修改新增的页面，还要到数据库中对publish那个表项做个修改。<img src="http://pic.l2h.site/l2hsitelink-page-4.PNG" alt="Wordpress--无法修改scandir如何按照模板添加模板页面" title="Wordpress--无法修改scandir如何按照模板添加模板页面"></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress-写插件增加小工具(Widget)的方法</title>
    <url>/p/ad791da4.html</url>
    <content><![CDATA[<p>写这篇文章的目的，是因为在使用<strong>WP-MulticolLinks</strong>插件时，发现只能增加一个小工具(Widget)到工具栏。如下图，这样没有办法按照类别增加多列友链小工具。 <img src="http://pic.l2h.site/l2hsite1-1.png" alt="Wordpress-写插件增加小工具(Widget)的方法" title="Wordpress-写插件增加小工具(Widget)的方法"> 于是对该插件做了修改，可以支持在后台拖动多个多列友情链接小工具。 <img src="http://pic.l2h.site/l2hsite2.png" alt="Wordpress-写插件增加小工具(Widget)的方法" title="Wordpress-写插件增加小工具(Widget)的方法"> 以下是在插件中增加代码实现多列的方法：</p><ul>
<li><p>注册我们的小工具，在widget界面初始化时可以在后台界面中增加我们的小工具</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下为在widgets界面初始化时，注册我们自己定义的小工具</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">register_ex_widget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    register_widget( <span class="string">'EX_Widget'</span> );</span><br><span class="line">&#125;</span><br><span class="line">add_action( <span class="string">'widgets_init'</span>, <span class="string">'register_ex_widget'</span> );</span><br><span class="line"></span><br><span class="line">*   定义小工具的类，继承自WP_Widget，这个基类是可以创建多个实例的</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定小工具类，继承WP_Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EX_Widget</span> <span class="keyword">extends</span> <span class="title">WP_Widget</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化设定，定义小工具的名字等基本信息</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">EX_Widget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $widget_ops = <span class="keyword">array</span>( <span class="string">'classname'</span> =&gt; <span class="string">'side_ex'</span>, <span class="string">'description'</span> =&gt; <span class="string">'设定多列友情链接'</span>);</span><br><span class="line">        $control_ops = <span class="keyword">array</span>( <span class="string">'width'</span> =&gt; <span class="number">300</span>, <span class="string">'height'</span> =&gt; <span class="number">500</span>, <span class="string">'id_base'</span> =&gt; <span class="string">'side_ex-widget'</span> );</span><br><span class="line">        <span class="keyword">$this</span>-&gt;WP_Widget( <span class="string">'side_ex-widget'</span>, <span class="string">'多列友情链接'</span>, $widget_ops, $control_ops );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小工具在工具栏显示的函数，之后介绍具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">widget</span><span class="params">( $args, $instance )</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Widget时执行该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">( $new_instance, $old_instance )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Widget菜单的显示时执行该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">form</span><span class="params">( $instance )</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>widget函数实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">widget</span><span class="params">( $args, $instance )</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 以上均为转化参数用于后续传递</span></span><br><span class="line">   $this_title = <span class="keyword">empty</span>($instance[<span class="string">'title'</span>]) ? __(<span class="string">'Links'</span>, <span class="string">'wp-multicollinks'</span>) : $instance[<span class="string">'title'</span>];</span><br><span class="line">   $orderbyParam = <span class="string">'name'</span>;</span><br><span class="line">   <span class="keyword">if</span> ($instance[<span class="string">'orderby'</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">     $orderbyParam = <span class="string">'url'</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($instance[<span class="string">'orderby'</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">     $orderbyParam = <span class="string">'rating'</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ($instance[<span class="string">'orderby'</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">     $orderbyParam = <span class="string">'rand'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   $orderParam = <span class="string">'ASC'</span>;</span><br><span class="line">   <span class="keyword">if</span> ($instance[<span class="string">'order'</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">     $orderParam = <span class="string">'DESC'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 组合参数字符串，用于wp_multicollinks函数执行时使用。wp_multicollinks为显示友情链接的函数，原插件就有定义</span></span><br><span class="line">   $argsBinding = 	  <span class="string">'limit='</span>	    . $instance[<span class="string">'number'</span>] </span><br><span class="line">           . <span class="string">'&amp;columns='</span>	. $instance[<span class="string">'columns'</span>] </span><br><span class="line">           . <span class="string">'&amp;category='</span>	. $instance[<span class="string">'category'</span>] </span><br><span class="line">           . <span class="string">'&amp;orderby='</span>	. $orderbyParam </span><br><span class="line">           . <span class="string">'&amp;order='</span>		. $orderParam </span><br><span class="line">           . <span class="string">'&amp;navigator='</span>	. ($instance[<span class="string">'navigator'</span>] ? <span class="string">'true'</span> : <span class="string">'false'</span>);</span><br><span class="line">               extract( $args );<span class="comment">// $args裡可以拿到所在栏位的资讯，如before_widget、after_widget..等</span></span><br><span class="line">   <span class="keyword">echo</span> $before_widget;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">"&lt;h2 class=\\"</span>widget-title\\<span class="string">"&gt;$this_title&lt;/h2&gt;"</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line">   wp_multicollinks($argsBinding);</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">'&lt;/ul&gt;'</span>;       </span><br><span class="line">   <span class="keyword">echo</span> $after_widget;	</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后台小工具显示及更新函数实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 於後台更新Widget時會做的事</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">( $new_instance, $old_instance )</span> </span>&#123;</span><br><span class="line">        $instance = $old_instance;</span><br><span class="line">        <span class="comment">//用填写的值给新创建的Widget实例赋值</span></span><br><span class="line">    $instance[<span class="string">'title'</span>] = strip_tags( $new_instance[<span class="string">'title'</span>] );</span><br><span class="line">    $instance[<span class="string">'number'</span>] = strip_tags( $new_instance[<span class="string">'number'</span>] );</span><br><span class="line">    $instance[<span class="string">'columns'</span>] = strip_tags( $new_instance[<span class="string">'columns'</span>] );</span><br><span class="line">    $instance[<span class="string">'category'</span>] = strip_tags( $new_instance[<span class="string">'category'</span>] );</span><br><span class="line">    $instance[<span class="string">'orderby'</span>] = strip_tags( $new_instance[<span class="string">'orderby'</span>] );</span><br><span class="line">    $instance[<span class="string">'order'</span>] = strip_tags( $new_instance[<span class="string">'order'</span>] );</span><br><span class="line">    $instance[<span class="string">'navigator'</span>] = strip_tags( $new_instance[<span class="string">'navigator'</span>] );</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> $instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Widget在後台模組頁的外觀</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">form</span><span class="params">( $instance )</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以用数组设定显示小工具表格的时的预设值</span></span><br><span class="line">    $defaults = <span class="keyword">array</span>(<span class="string">'title'</span>=&gt;<span class="string">'友情链接'</span>);</span><br><span class="line">                $instance = wp_parse_args( (<span class="keyword">array</span>) $instance, $defaults ); <span class="meta">?&gt;</span></span><br><span class="line">  <span class="comment">// 表项的显示，显示时应该要能加载出之前已经保存的内容	</span></span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label  <span class="keyword">for</span>=<span class="string">"&lt;?php echo $this-&gt;get_field_id( 'title' ); ?&gt;"</span>&gt;</span><br><span class="line">        <span class="meta">&lt;?php</span> _e(<span class="string">'Title: '</span>, <span class="string">'wp-multicollinks'</span>); <span class="meta">?&gt;</span></span><br><span class="line">        &lt;input class="widefat" id="title" name="&lt;?php echo $this-&gt;get_field_name( 'title' ); ?&gt;" type="text" value="&lt;?php echo $instance['title']; ?&gt;" /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label <span class="keyword">for</span>=<span class="string">"&lt;?php echo $this-&gt;get_field_id( 'number' ); ?&gt;"</span>&gt;</span><br><span class="line">          <span class="meta">&lt;?php</span> _e(<span class="string">'Number of links to show: '</span>, <span class="string">'wp-multicollinks'</span>); <span class="meta">?&gt;</span></span><br><span class="line">          </span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;input style=<span class="string">"width: 25px;"</span> id=<span class="string">"number"</span> name=<span class="string">"&lt;?php echo $this-&gt;get_field_name( 'number' );?&gt;"</span> type=<span class="string">"text"</span> value=<span class="string">"&lt;?php echo $instance['number']; ?&gt;"</span> /&gt;</span><br><span class="line">      &lt;br /&gt;</span><br><span class="line">      &lt;small&gt;<span class="meta">&lt;?php</span> _e(<span class="string">'(0 for ∞)'</span>, <span class="string">'wp-multicollinks'</span>); <span class="meta">?&gt;</span>&lt;/small&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">       <span class="comment">//以下省略剩余表项代码</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul><a id="more"></a>

<p>最后，放上插件链接，<a href="http://pic.l2h.site/l2hsitel2h-multicollinks.7z" target="_blank" rel="noopener">点击下载</a> 后解压到wordpress的plugin目录，启用插件即可使用 P.S. 原插件由mg12(<a href="http://www.fighton.cn/)编写" target="_blank" rel="noopener">http://www.fighton.cn/)编写</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress新评论微信通知+邮件回复</title>
    <url>/p/848ebfd3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>建立博客，与路过的大佬们互动必不可少。除了优质内容，互动也是提高博客回头率的小手段。本文主要解决两个问题：</p><ul>
<li>如何第一时间知道大佬们在博客留言呢？</li>
<li>对留言大佬回复，如何通知到对方？</li>
</ul><h2 id="新评论微信通知"><a href="#新评论微信通知" class="headerlink" title="新评论微信通知"></a>新评论微信通知</h2><p>第一个问题主要是时效性问题。其实Wordpress本身就可以通知博主邮箱做留言审核，当然也有一些不错的插件（例如，Jetpack）。不过这还不够快（因为邮箱毕竟不是时时都看的）。因此，经过搜索，L&amp;H Site使用的是“<a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">Server酱</a>”。对，就是本站那个友情链接。</p><a id="more"></a>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>盗用Server酱官网的一张图说明微信推送原理。</p>
<p><img src="http://anime-img.stor.sinaapp.com/5bf55cc81c840.gif" alt></p>
<h3 id="注册Server酱并关注"><a href="#注册Server酱并关注" class="headerlink" title="注册Server酱并关注"></a>注册Server酱并关注</h3><p>如上图，注册Server酱，您首先需要有一个<a href="https://github.com/" target="_blank" rel="noopener">Github</a>账号（不要告诉我您不知道什么是Github哦）。</p>
<p>使用Github登录Server酱，打开<a href="http://sc.ftqq.com/?c=code" target="_blank" rel="noopener">页面</a>，获取到SCKey。</p>
<p><img src="http://pic.l2h.site/ServerChan2-512x1024.jpg" alt></p>
<p>打开<a href="http://sc.ftqq.com/?c=wechat&a=bind" target="_blank" rel="noopener">微信绑定页</a>，使用微信扫描个人专属二维码并关注，然后电脑点击【检查结果并确认绑定】便关联成功</p>
<p><img src="http://pic.l2h.site/ServerChan1-512x1024.png" alt></p>
<p>关联成功后，可以在消息发送页尝试发送一条消息看微信是否收得到，正常收到消息的微信如下图：</p>
<p><img src="http://pic.l2h.site/ServerChan3-512x1024.jpg" alt></p>
<h3 id="编辑主题function-php"><a href="#编辑主题function-php" class="headerlink" title="编辑主题function.php"></a>编辑主题function.php</h3><p>编辑主题function.php，加入如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评论微信推送  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sc_send</span><span class="params">($comment_id)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">$text = <span class="string">'博客上有一条新的评论'</span>;  </span><br><span class="line">$comment = get_comment($comment_id);  </span><br><span class="line">$desp = $comment-&gt;comment_content;  </span><br><span class="line">$key = <span class="string">'SCUxxxxxx'</span>;  <span class="comment">//你的SCKey，从之前Server酱网站得到</span></span><br><span class="line">$postdata = http_build_query(  </span><br><span class="line"><span class="keyword">array</span>(  </span><br><span class="line"><span class="string">'text'</span> =&gt; $text,  </span><br><span class="line"><span class="string">'desp'</span> =&gt; $desp  </span><br><span class="line">)  </span><br><span class="line">);  </span><br><span class="line">   </span><br><span class="line">$opts = <span class="keyword">array</span>(<span class="string">'http'</span> =&gt;  </span><br><span class="line"><span class="keyword">array</span>(  </span><br><span class="line"><span class="string">'method'</span> =&gt; <span class="string">'POST'</span>,  </span><br><span class="line"><span class="string">'header'</span> =&gt; <span class="string">'Content-type: application/x-www-form-urlencoded'</span>,  </span><br><span class="line"><span class="string">'content'</span> =&gt; $postdata  </span><br><span class="line">)  </span><br><span class="line">);  </span><br><span class="line">$context = stream_context_create($opts);  </span><br><span class="line"><span class="keyword">return</span> $result = file_get_contents(<span class="string">'http://sc.ftqq.com/'</span>.$key.<span class="string">'.send'</span>, <span class="keyword">false</span>, $context);  </span><br><span class="line">&#125;  </span><br><span class="line">add_action(<span class="string">'comment_post'</span>, <span class="string">'sc_send'</span>, <span class="number">19</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>完成后保存。之后留言推送，效果如前一幅图。</p>
<h2 id="评论回复邮件通知"><a href="#评论回复邮件通知" class="headerlink" title="评论回复邮件通知"></a>评论回复邮件通知</h2><h3 id="安装SMTP邮件插件"><a href="#安装SMTP邮件插件" class="headerlink" title="安装SMTP邮件插件"></a>安装SMTP邮件插件</h3><p>推荐安装Easy WP SMTP，官方插件页面搜索即可安装，当然也有很多同类型替代，大同小异。</p>
<h3 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h3><p>后台–&gt;设置–&gt;Easy WP SMTP–&gt;SMTP Settings</p>
<p>按照您的电子邮件提供商的设定进行配置，注意您的网站所在主机需要开放所需连接SMTP端口的权限。推荐使用outlook.com邮件，163容易被当作垃圾邮件。</p>
<p>设置完保存即可。您也可以到 后台–&gt;设置–&gt;Easy WP SMTP–&gt; Test Email测试配置是否正确</p>
<p><img src="http://pic.l2h.site/Mail-Notify-2.png" alt></p>
<h3 id="修改主题funtion-php"><a href="#修改主题funtion-php" class="headerlink" title="修改主题funtion.php"></a>修改主题funtion.php</h3><p>若要评论触发邮件通知，则需要修改function.php增加如下代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comment_mail_notify</span><span class="params">($comment_id)</span> </span>&#123;</span><br><span class="line">  $comment = get_comment($comment_id);</span><br><span class="line">  $parent_id = $comment-&gt;comment_parent ? $comment-&gt;comment_parent : <span class="string">''</span>;</span><br><span class="line">  $spam_confirmed = $comment-&gt;comment_approved;</span><br><span class="line">  <span class="keyword">if</span> (($parent_id != <span class="string">''</span>) &amp;&amp; ($spam_confirmed != <span class="string">'spam'</span>)) &#123;</span><br><span class="line">    $wp_email = <span class="string">'no-reply@'</span> . preg_replace(<span class="string">'#^www.#'</span>, <span class="string">''</span>, strtolower($_SERVER[<span class="string">'SERVER_NAME'</span>])); <span class="comment">//e-mail 发出点, no-reply 可改为可用的 e-mail.</span></span><br><span class="line">    $to = trim(get_comment($parent_id)-&gt;comment_author_email);</span><br><span class="line">    $subject = <span class="string">'您在 ['</span> . get_option(<span class="string">"blogname"</span>) . <span class="string">'] 的留言有了回复'</span>;</span><br><span class="line">    $message = <span class="string">'</span></span><br><span class="line"><span class="string">    &lt;div style="background-color:#eef2fa; border:1px solid #d8e3e8; color:#111; padding:0 15px; -moz-border-radius:5px; -webkit-border-radius:5px; -khtml-border-radius:5px;"&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;'</span> . trim(get_comment($parent_id)-&gt;comment_author) . <span class="string">', 您好!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;您曾在《'</span> . get_the_title($comment-&gt;comment_post_ID) . <span class="string">'》的留言:&lt;br /&gt;'</span></span><br><span class="line">       . trim(get_comment($parent_id)-&gt;comment_content) . <span class="string">'&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;'</span> . trim($comment-&gt;comment_author) . <span class="string">' 给您的回复:&lt;br /&gt;'</span></span><br><span class="line">       . trim($comment-&gt;comment_content) . <span class="string">'&lt;br /&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;您可以点击&lt;a href="'</span> . htmlspecialchars(get_comment_link($parent_id, <span class="keyword">array</span>(<span class="string">'type'</span> =&gt; <span class="string">'comment'</span>))) . <span class="string">'"&gt;查看回应完整内容&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;欢迎再度光临&lt;a href="'</span> . get_option(<span class="string">'home'</span>) . <span class="string">'"&gt;'</span> . get_option(<span class="string">'blogname'</span>) . <span class="string">'&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;(此邮件由系统自动发送，请勿回复.)&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;'</span>;</span><br><span class="line">      $from = <span class="string">"From: \\"</span><span class="string">" . get_option('blogname') . "</span>\\<span class="string">" &lt;$wp_email&gt;"</span>;</span><br><span class="line">      $headers = <span class="string">"$from\\nContent-Type: text/html; charset="</span> . get_option(<span class="string">'blog_charset'</span>) . <span class="string">"\\n"</span>;</span><br><span class="line">      wp_mail( $to, $subject, $message, $headers );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">add_action(<span class="string">'comment_post'</span>, <span class="string">'comment_mail_notify'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>配置成功后，试试效果吧。如下图：</p>
<p><img src="http://pic.l2h.site/Mail-Notify.png" alt></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是Wordpress新评论微信通知+邮件回复的设置方法了，是不是很简单呢？快试试吧。</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>评论通知</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress: 简单修改七牛云图床插件支持Gutenburg(古腾堡)</title>
    <url>/p/cd78883c.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客空间有限，一直使用<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛云图床</a>和<a href="http://www.75271.com/2954.html" target="_blank" rel="noopener">开心洋葱的图床插件</a>做图片上传。之前按照《<a href="https://www.l2h.site/2018/11/25/%E5%8D%87%E7%B4%9A%E5%88%B0wordpress-4-9-8/" target="_blank" rel="noopener">升級到WORDPRESS 4.9.8</a>》介绍更新古腾堡编辑器后，发现插件失效。本文介绍简单修改，让Gutenberg后台仍可使用插件做图片上传。</p><blockquote>
<p>注：本文修改简单，并非实现Gutenberg Block，若您想了解如何修改，可以移步<a href="https://wisdomplugin.com/build-gutenberg-block-plugin/" target="_blank" rel="noopener">How to build a </a><strong><a href="https://wisdomplugin.com/build-gutenberg-block-plugin/" target="_blank" rel="noopener">Gutenberg block</a></strong><a href="https://wisdomplugin.com/build-gutenberg-block-plugin/" target="_blank" rel="noopener"> plugin</a> 学习了解。</p>
</blockquote><a id="more"></a>

<h2 id="呈现效果"><a href="#呈现效果" class="headerlink" title="呈现效果"></a>呈现效果</h2><p><img src="http://pic.l2h.site/l2hsiteqiniuyun-gutenberg.png" alt></p>
<h2 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h2><p>1.修改qiniu-cloudtuchuang.php代码如下,注意代码加亮部分:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上传窗口</span></span><br><span class="line">add_action(<span class="string">'do_meta_boxes'</span>, <span class="string">'qiniu_cloudtuchuang_script'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qiniu_cloudtuchuang_script</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wp_enqueue_script( <span class="string">'qiniu-jquery'</span>, plugins_url(<span class="string">'js/qiniujq.min.js'</span>, <span class="keyword">__FILE__</span>));</span><br><span class="line">    <span class="comment">//wp_enqueue_script( 'plupload-all',plugins_url('js/plupload/js/plupload.full.min.js', __FILE__) );</span></span><br><span class="line">	wp_enqueue_script( <span class="string">'plupload-all'</span>);</span><br><span class="line">    wp_enqueue_script( <span class="string">'qiniu'</span>, plugins_url(<span class="string">'js/qiniu.js'</span>, <span class="keyword">__FILE__</span>));</span><br><span class="line">    wp_enqueue_script( <span class="string">'qiniu-main'</span>, plugins_url(<span class="string">'js/main.js'</span>, <span class="keyword">__FILE__</span> ),<span class="keyword">array</span>( <span class="string">'jquery'</span> ));</span><br><span class="line">    wp_enqueue_script( <span class="string">'qiniu-ui'</span>, plugins_url(<span class="string">'js/ui.js'</span>, <span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;    </span><br><span class="line"> </span><br><span class="line">add_action(<span class="string">'do_meta_boxes'</span>, <span class="string">'qiniu_cloudtuchuang_post_box'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qiniu_cloudtuchuang_post_box</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $options = get_option(<span class="string">'qiniu_options'</span>);</span><br><span class="line">    <span class="keyword">if</span>($options[<span class="string">'accesskey'</span>] &amp;&amp; $options[<span class="string">'secretkey'</span>]) add_meta_box(<span class="string">'qiniu_cloudtuchuang_div'</span>, __(<span class="string">'七牛云图床'</span>), <span class="string">'qiniu_cloudtuchuang_post_html'</span>, <span class="string">'post'</span>, <span class="string">'side'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add_action(<span class="string">'do_meta_boxes'</span>, <span class="string">'qiniu_cloudtuchuang_style'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qiniu_cloudtuchuang_style</span><span class="params">()</span></span>&#123;</span><br><span class="line">	wp_enqueue_style(<span class="string">'qiniu_cloudtuchuang_style'</span>, plugins_url(<span class="string">'css/qiniu_cloudtuchuang.css'</span>, <span class="keyword">__FILE__</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qiniu_cloudtuchuang_post_html</span><span class="params">()</span></span>&#123;</span><br><span class="line">	$options = get_option(<span class="string">'qiniu_options'</span>);</span><br><span class="line">    $host = $options[<span class="string">'host'</span>];</span><br><span class="line">    $bucket = $options[<span class="string">'bucket'</span>];</span><br><span class="line">    $prefix = $options[<span class="string">'prefix'</span>];</span><br><span class="line">    $accesskey = $options[<span class="string">'accesskey'</span>];</span><br><span class="line">    $secretkey = $options[<span class="string">'secretkey'</span>];</span><br><span class="line">    $imgurl = $options[<span class="string">'imgurl'</span>];</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;script&gt;"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($prefix)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'var savekey = true; var prefix = \\'</span><span class="string">'.$prefix.'</span>\\<span class="string">';'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">'var savekey = false;var prefix = \\'</span>\\<span class="string">';'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">empty</span>($imgurl)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'var imgurl = true;'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">'var imgurl = false;'</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'var host =\\'</span><span class="string">'.  $host . '</span>\\<span class="string">';'</span>;</span><br><span class="line">	<span class="comment">//$nonce = wp_create_nonce('cloudtuchuang');</span></span><br><span class="line">    <span class="comment">//echo 'var uptokenurl=\\''. plugins_url('token.php', __FILE__) . '?_ajax_nonce='. $nonce .'&amp;secretKey='. $secretkey . '&amp;accessKey=' . $accesskey . '&amp;bucket=' . $bucket . '&amp;prefix=' . $prefix .'\\'&lt;/script&gt;';</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">'var uptokenurl=\\'</span><span class="string">'. plugins_url('</span>token.php<span class="string">', __FILE__) . '</span>?secretKey=<span class="string">'. $secretkey . '</span>&amp;accessKey=<span class="string">' . $accesskey . '</span>&amp;bucket=<span class="string">' . $bucket . '</span>&amp;prefix=<span class="string">' . $prefix .'</span>\\<span class="string">'&lt;/script&gt;'</span>;</span><br><span class="line">    <span class="comment">//echo '&lt;div id="qiniu_cloudtuchuang_post"&gt;&lt;div id="pickfiles" href="#" &gt;&lt;span id="spantxt"&gt;拖拽上传图片&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;';</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;div id="qiniu_cloudtuchuang_post_btn"&gt;&lt;a id="qiniu-insert-media-button" class="button insert-qiniuyun " title="添加图片" data-editor="content" href="javascript:;"&gt;^_^ &lt;span id="spandesc"&gt;添加图片&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;'</span>;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">'File(Image) URL:&lt;input type="text" id="qiniu_image_addr" readonly /&gt;'</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改js/main.js，找到“console.log(img);”，增加如下第二行代码：</li>
</ol>
<p>console.log(img);<br>$(‘#qiniu_image_addr’).val(qiniuurl);</p>
<ol start="3">
<li>执行以上修改后保存退出即完成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上修改相对还是比较简单，Enjoy it！</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>Gutenberg</tag>
        <tag>七牛云</tag>
        <tag>古腾堡</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress显示数学公式：WP-KaTeX插件 + VS Code Markdown Math插件</title>
    <url>/p/1077b2aa.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>    最近希望在了解一些机器学习的相关知识，并在博客里做一些记录。先从著名的Tom Mitchell大神的《机器学习》开始。奈何发现数学公式过多，用<a href="http://www.l2h.site/2018/10/28/markdown-editor/" title="http://www.l2h.site/2018/10/28/markdown-editor/" target="_blank" rel="noopener">WORDPRESS使用MARKDOWN编辑器</a>里介绍的方法做笔记，想添加公式发现力不从心。经过搜索，摸索到后文的方法。</p><h2 id="本地编辑：VS-Code-“Markdown-Math”插件"><a href="#本地编辑：VS-Code-“Markdown-Math”插件" class="headerlink" title="本地编辑：VS Code + “Markdown+Math”插件"></a>本地编辑：VS Code + “Markdown+Math”插件</h2><a id="more"></a>
<h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ol>
<li><ol>
<li>打开Visual Studio Code, Ctrl+Shift+X打开插件搜索框</li>
</ol>
</li>
<li><p>安装并重启VS Code</p>
</li>
</ol>
<p><img src="http://pic.l2h.site/l2hsiteMarkdown-Math-1.png" alt="Markdown+Math" title="Markdown+Math"></p>
<h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>    Markdown+Math让使用者可以输入LaTex格式的数学公式，使用数学公式渲染库KaTeX输出公式的样式。 使用Markdown+Math非常简单，只需要在美元符号中间输入需要的Tex数学公式即可。</p>
<ul>
<li><ul>
<li>若是一行文本内的插入公式，公式前后各一个美元符号，例如：”$a^2+b^2=c^2$”.</li>
</ul>
</li>
<li><p>若是单行仅公式，则使用$$公式$$。例：</p>
</li>
</ul>
<p>$${\tilde V} = w_0+x_1w_1+x_2w_2+…+x_nw_n$$</p>
<p>    更多LaTeX数学公式可以参考<a href="http://pic.l2h.site/l2hsitelatex-short-cn.pdf" title="http://pic.l2h.site/l2hsitelatex-short-cn.pdf" target="_blank" rel="noopener">LaTex简介文档</a>的”数学公式”一节。</p>
<h2 id="发布到Wordpress"><a href="#发布到Wordpress" class="headerlink" title="发布到Wordpress"></a>发布到Wordpress</h2><p>    由于没有对应的CSS档，如果将上文里的公式直接拷贝到Wordpress编辑器，漂亮的数学公式立马失效。 <img src="http://pic.l2h.site/l2hsiteMarkdown-Math-2.png" alt="WP-KaTex" title="WP-KaTex"></p>
<pre><code>这时候需要Wordpress插件出场。</code></pre><ul>
<li><ul>
<li>在Wordpress后台搜索”WP-KaTeX”插件并安装</li>
</ul>
</li>
<li><ul>
<li>启用插件</li>
</ul>
</li>
<li><p>建议在插件设置页面勾选上“Use jsDelivr to load files”，使用CDN加速公式显示公式的脚本加载</p>
</li>
</ul>
<p><img src="http://pic.l2h.site/l2hsiteMarkdown-Math-3.png" alt="WP-KaTex" title="WP-KaTex"></p>
<ul>
<li>数学公式的左右增加“(latex)”和“(/latex)”，()换成[]例如：</li>
</ul>
<blockquote>
<p>$${\tilde V} = w_0+x_1w_1+x_2w_2+…+x_nw_n$$</p>
</blockquote>
<ul>
<li><p>KaTex支持大部分$${\LaTeX}$$数学公式，具体可以参考$$\href{<a href="https://katex.org/}{\\LaTeX}$$" target="_blank" rel="noopener">https://katex.org/}{\\LaTeX}$$</a> 和 <a href="https://katex.org/docs/supported.html" target="_blank" rel="noopener">https://katex.org/docs/supported.html</a></p>
<p> 这边可以用Notepad++的查找/替换功能+正则表达式做语法替换，替换规则参考：</p>
</li>
<li><ul>
<li>查找“\$\$(.+)\$\$”</li>
</ul>
</li>
<li><ul>
<li>替换为(latex)<strong>\1</strong>(\latex) -&gt; 注意:本博客latex相关语法插件已经生效，圆括号()要换成方括号[]</li>
</ul>
</li>
<li><p>参考下图</p>
</li>
</ul>
<p><img src="http://pic.l2h.site/l2hsiteMarkdown-Math-4.png" alt="正则替换"></p>
<p>    查找样式表示查找由两边各两个美元符号包含的任意样式，圆括号表示要标记的字段，接下来会引用。因为美元符号在正则表达式有特殊含义，查找其必须使用斜杠做转义。 替换样式中最关键的就是红色字体\1了，表示刚刚查找样式的第一个圆括号标记。 更多正则表达式语法可以参考<a href="http://www.runoob.com/regexp/regexp-tutorial.html" title="http://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>    Wordpress原生对Markdown支持较差，目前所使用方法为暂解。希望之后Wordpress可以增加Markdown支持吧。</p>
<pre><code>另外，机器学习入门解惑推荐博友OldPAN的&lt;[一篇文章解决机器学习入门疑惑](https://oldpan.me/archives/machine-deeplearning-introduction)&gt;</code></pre>]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress新浪微博图床插件</title>
    <url>/p/8b24c2f6.html</url>
    <content><![CDATA[<p>一直使用七牛云图床，今日安装Typecho，意外发现一个新浪微博图床插件：</p><p>引用作者的介绍：</p><p><a href="https://camo.githubusercontent.com/32293617a30cf6c9af1fb3e0f0575222bfe1fa9b/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f65636162616465356c7931667177757a326b3635386a32306c6530356e743869" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/32293617a30cf6c9af1fb3e0f0575222bfe1fa9b/68747470733a2f2f7773332e73696e61696d672e636e2f6c617267652f65636162616465356c7931667177757a326b3635386a32306c6530356e743869" alt="TleWeiboTuchuang新浪微博图片上传插件"></a></p><h2 id="TleWeiboTuchuang新浪微博图床"><a href="#TleWeiboTuchuang新浪微博图床" class="headerlink" title="TleWeiboTuchuang新浪微博图床"></a><a href="https://github.com/muzishanshi/TleWeiboTuchuang#tleweibotuchuang%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A" target="_blank" rel="noopener"></a>TleWeiboTuchuang新浪微博图床</h2><hr><p>TleWeiboTuchuang新浪微博图床用微博小号代替微博授权的方式，自动利用cookie上传，更加方便，在文章发布页面增加微博上传功能，使用微博作为图床，只需一个微博小号即可实现。（因权限问题可能会失败几次，可多尝试几个微博小号。）</p><a id="more"></a>




<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><a href="https://github.com/muzishanshi/TleWeiboTuchuang#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"></a>使用方法</h3><p>第一步：下载本插件，放在 <code>wp-content/plugins/</code> 目录中（插件文件夹名必须为TleWeiboTuchuang）；<br>第二步：激活插件；<br>第三步：填写微博小号等等配置；<br>第四步：完成。</p>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><a href="https://github.com/muzishanshi/TleWeiboTuchuang#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F" target="_blank" rel="noopener"></a>使用注意</h3><p>此插件版本使用php5.6编写，建议使用php5.6，现已支持WordPress 5.0以上版本。</p>
<p><a href="https://github.com/muzishanshi/TleWeiboTuchuang" target="_blank" rel="noopener">访问链接下载</a></p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>图床</tag>
        <tag>新浪微博</tag>
      </tags>
  </entry>
  <entry>
    <title>WP禁用Jetpack自带Beautiful Math解决MathJax冲突</title>
    <url>/p/35eec164.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前段时间给博客增加了Jetpack插件，今天突然发现<a href="https://www.l2h.site/2019/02/05/machine-learning-neural-network-2/" target="_blank" rel="noopener">文章</a>里数学公式大部分变成了下边样式的图片：</p><p><img src="https://s0.wp.com/latex.php?latex=%5CLaTeX%26s%3DX&bg=F9F9F9&fg=333333&s=0" alt></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>一开始怀疑是博客的Cache插件问题，不过经过逐个关闭插件排查，发现是Jetpack的Beautiful Math模块在作怪。看看<a href="https://jetpack.com/support/beautiful-math-with-latex/" target="_blank" rel="noopener">Jetpack官网</a>的说明：</p><blockquote>
<p>If your LaTex  code is broken, instead of the equation you’ll see an ugly yellow and red error message. Sorry, <strong>we can’t provide support for *<em>LaTex *</em>syntax</strong>, but there are plenty of useful guides elsewhere online. Or a quick post in our <a href="https://en.forums.wordpress.com/" target="_blank" rel="noopener">forums</a> might find you a solution. One thing to keep in mind is that WordPress puts all of your  LaTex code inside a  LaTex <code>math</code> environment. If you try to use LaTex that doesn’t work inside the <code>math</code> environment (such as <code>\begin{align} ... \end{align}</code>), you will get an error</p>
</blockquote><a id="more"></a>



<p>也就是说，我的MathJax-Latex插件并没有生效，反而被Jetpack的Beautiful Math代替了，而其对一些LaTex公式并不支持。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方案也很简单，若不希望更换公式的写法为Beautiful Math，只需要关掉它就好：</p>
<ul>
<li>打开“你的网址/+/wp-admin/admin.php?page=jetpack_modules”</li>
<li>找到“Beautiful Math”或者中文“ 美妙的数学 ”</li>
<li>禁用之</li>
</ul>
<p>再打开您的页面，问题是否解决了呢？XD</p>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>Jetpack</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Yaffs文件系统(1)-- 概述</title>
    <url>/p/47957ed6.html</url>
    <content><![CDATA[<p><a href="https://yaffs.net/" target="_blank" rel="noopener">Yaffs</a>全称 Yet Another Flash File System，是一种嵌入式设备常用文件系统。它对基于Flash的存储设备（NAND 或NOR Flash）特别是NAND Flash有很好的支持，其具有速度快、鲁棒性强等特点。此外，其对各种操作系统的支持也很好。<br>目前Yaffs已经更新到了版本2，而本文从源码角度对Yaffs2文件系统进行分析 。希望对知识进行巩固的同时，也能对大家有所帮助。其中理解若有不到位的地方，也麻烦大家指正。</p><a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先看Yaffs在整个系统中的位置（注：本文无特别说明均以搭载Linux OS为例）：</p>
<ul>
<li><p>YAFFS位于虚拟文件系统之下，为VFS提供调用接口</p>
</li>
<li><p>YAFFS使用Linux MTD 子系统提供的服务对Flash进行操作。</p>
<ul>
<li>为什么直接使用Nand或者Nor Flash 驱动直接操作？这就涉及到Linux内核的设计思想：尽可能的对架构进行抽象，避免上下层直接调用，产生N*N的组合，节省了内核驱动设计者的开发负担，同时降低系统的代码复杂度。</li>
</ul>
<p>+—————————+<br>|   用 户 空 间 态           |<br>+—————————+</p>
</li>
</ul>
<hr>
<p>  +—————————+<br>  |     VFS 虚 拟 文 件 系 统  |<br>  +—————————+ 内<br>  +——+ +——+ +———+<br>  |File  | |File  | | YAFFS   | 核<br>  |Sys-1 | |Sys-2 | |         |<br>  +——+ +——+ +———+ 态<br>  +—————+ +———+<br>  |               | | MTD     |<br>  |               | | Sub SYS |<br>  | …………  | +———+<br>  |               | +———+<br>  |               | | Nand or |<br>  |               | | NOR DrV |<br>  +—————+ +———+</p>
<hr>
<p>  +—————————+<br>  |      硬   件              |<br>  +—————————+</p>
<p>Yaffs2主要有以下功能模块</p>
<ul>
<li>Flash的块/Chunk分配管理</li>
<li>检查点机制</li>
<li>垃圾回收机制</li>
<li>缓存机制</li>
<li>Proc调试功能</li>
</ul>
<h2 id="YAFFS文件系统格式"><a href="#YAFFS文件系统格式" class="headerlink" title="YAFFS文件系统格式"></a>YAFFS文件系统格式</h2><p>如下图，按照由大到小，Flash一般如下组成：</p>
<ul>
<li>Block（块）：Block一般为Flash擦除的基本单位。由多个页及对应OOB区域组成， 跟据Flash控制器和Flash颗粒的不同， 组成Block的page数量也不相同</li>
<li>Page（页）：Flash的页，用来存放真正数据的基本单位。在Yaffs文件系统管理里称作数据Chunk。</li>
<li>OOB（带外数据）：与页对应，紧跟在页的后边，一般存放ECC校验信息，Flash坏块标记等信息。</li>
</ul>
<p>+——————–+<br>| Flash 页           |—–&gt;存放文件内容<br>|                    |<br>|                    |<br>|                    |<br>+————————-&gt;Flash Chunk 1<br>| Flash Spare区域     |—–&gt;存放文件相关信息的Spare区域<br>+——————–+<br>|                    |<br>|                    |<br>|                    |<br>|                    |<br>+————————-&gt;Flash Chunk 2<br>|                    |<br>+——————–+<br>|                    |<br>|  ……………   +—-&gt;Flash Chunks<br>+——————–+<br>|                    |<br>|                    |<br>|                    |<br>|                    |<br>+————————-&gt;Flash Chunk N<br>|                    |<br>+——————–+</p>
<p>一个典型的普通文件在 YAFFS 文件系统格式Flash的存储形式如下图所示：</p>
<ul>
<li>YAFFS将文件头部信息（包括文件类型，文件名，父目录的obj_id等）<br>单独 存放在page的起始位置。</li>
<li>文件的唯一标示id(也叫obj_id)位于OOB区域，紧跟chunk_id标示这个是文件的第几块数据，Chunk_id 0表示该page为文件头信息，不含文件内容</li>
<li>真正的文件内容根据文件大小散落在的size/page_size+1个页内。若文件大小正好不是页大小的整数倍，那么最后一段文件内容后会填充全0xFF放在一个页内，Page对应的OOB区域</li>
<li>因为文件可能会被YAFFS管理（例如，上层应用对文件改写）的关系，同一个文件的内容不一定会摆放在相邻的Flash 页内（刚刚使用mkyaffs创建的文件系统除外）。同时，对同一个文件，可能会存在多个相同obj_id肯chunk_id的文件页，此时有另外的标示seq number来决定选择哪个page</li>
</ul>
<p>+—————————-+<br>|类型 父目录id 文件名          |<br>|….                        |<br>|                            |<br>+—————————-+<br>|id chunk_id(0) size   ecc   |<br>+—————————-+<br>|                            |<br>|                            |<br>|                            |<br>|  ……………………  |<br>|                            |<br>|                            |<br>|                            |<br>|                            |<br>+—————————-+<br>|数 据                       |<br>|                            |<br>|                        数据|<br>+—————————-+<br>|id chunk_id(1) size ecc     |<br>+—————————-+<br>|数据                        |<br>|                            |<br>|                        数据|<br>+—————————-+<br>|id chunk_id(2) size   ecc   |<br>+—————————-+</p>
<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>真正开始源码分析前，我们先看一下YAFFS的源码结构。Yaffs的核心代码如下：</p>
<p>yaffs_allocator.c</p>
<p>yaffs_obj和Tnode的分配器</p>
<p>yaffs_bitmap.c</p>
<p>管理块和Chunk的位图的代码  </p>
<p>yaffs_checkpointrw.c</p>
<p>读写Checkpoint数据的代码  </p>
<p>yaffs_ecc.c</p>
<p>Yaffs ECC相关代码（使用<a href="https://en.wikipedia.org/wiki/Hamming_code" target="_blank" rel="noopener">Hamming ECC</a>）  </p>
<p>yaffs_guts.c</p>
<p>Yaffs 主代码.</p>
<p>yaffs_nameval.c</p>
<p>处理Yaffs扩展标签的diamante (xattr).</p>
<p>yaffs_nand.c</p>
<p>Flash 接口抽象.</p>
<p>yaffs_packedtags1.c<br>yaffs_packedtags2.c</p>
<p>打包Yaffs标签代码</p>
<p>yaffs_summary.c</p>
<p>处理Flash块Summary的代码.</p>
<p>yaffs_tagscompat.c</p>
<p>兼容Yaffs1模式的标签处理代码  </p>
<p>yaffs_tagsmarshall.c</p>
<p>标签组织代码</p>
<p>yaffs_verify.c</p>
<p>用于检查有效性的代码（例如，头部格式检查等）</p>
<p>yaffs_yaffs1.c</p>
<p>Yaffs1 模式特有代码.</p>
<p>yaffs_yaffs2.c</p>
<p>Yaffs2 模式特有代码.</p>
<p>yaffs_attribs.c  </p>
<p>文件属性处理相关代码</p>
<p>yaffs_error.c</p>
<p>存放Yaffs 错误代码</p>
<p>yaffsfs.c</p>
<p>Yaffs文件系统接口wrapper（支援多文件系统时用）</p>
<p>yaffs_hweight.c</p>
<p>用来检查Flash坏块标记的一些功能代码</p>
<p>yaffs_qsort.c</p>
<p>Yaffs使用的一些排序函数</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>YAFFS的初始化很简单，源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(init_yaffs_fs)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_yaffs_fs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_to_install</span> *<span class="title">fsinst</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;yaffs_context_lock);        </span><br><span class="line"></span><br><span class="line">	error = yaffs_procfs_init();                        ---<span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	fsinst = fs_to_install;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fsinst-&gt;fst &amp;&amp; !error) &#123;</span><br><span class="line">		error = register_filesystem(fsinst-&gt;fst);   ---<span class="number">-2</span></span><br><span class="line">		<span class="keyword">if</span> (!error)</span><br><span class="line">			fsinst-&gt;installed = <span class="number">1</span>;</span><br><span class="line">		fsinst++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Any errors? uninstall  */</span>                        ---<span class="number">-3</span></span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		fsinst = fs_to_install;</span><br><span class="line">		<span class="keyword">while</span> (fsinst-&gt;fst) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fsinst-&gt;installed) &#123;</span><br><span class="line">				unregister_filesystem(fsinst-&gt;fst);</span><br><span class="line">				fsinst-&gt;installed = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			fsinst++;</span><br><span class="line">	&#125;&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_to_install</span> <span class="title">fs_to_install</span>[] = &#123;</span></span><br><span class="line">	&#123;&amp;yaffs_fs_type, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;&amp;yaffs2_fs_type, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">yaffs2_fs_type</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.name = <span class="string">"yaffs2"</span>,</span><br><span class="line">	.mount = yaffs2_mount,</span><br><span class="line">	.kill_sb = kill_block_super,</span><br><span class="line">	.fs_flags = FS_REQUIRES_DEV,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第1段初始化系统的procfs</li>
<li>第2段向Kernel注册yaffs文件系统，这里不光注册yaffs2也会注册yaffs1，所以可以看到是一个while循环</li>
<li>第3段：如果注册文件系统发生问题，解注册文件系统，此处不做过多分析</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>被成功注册到内核后，YAFFS利用内存中如下重要的数据结构来对文件系统进行管理：</p>
<ul>
<li>_<strong>yaffs_dev：</strong>_YAFFS Partition或者挂载点的相关信息</li>
<li>_<strong>yaffs_block_info</strong>：_Nand Flash 块的信息，一个yaffs partition会有多个block info</li>
<li>_<strong>yaffs_obj：</strong>_记录文件系统中的文件或者目录相关信息</li>
<li>_<strong>yaffs_tnode：</strong>_记录文件系统的目录结构，以及文件chunk位置相关信息</li>
</ul>
<p>此外，YAFFS会使用少量的内存缓存（Cache）来提升访问性能。</p>
<p>yaffs_dev定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_param</span> <span class="title">param</span>;</span>          <span class="comment">//Yaffs相关参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_driver</span> <span class="title">drv</span>;</span>           <span class="comment">//驱动处理相关函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tags_handler</span> <span class="title">tagger</span>;</span>  <span class="comment">//Yaffs标签处理相关函数</span></span><br><span class="line">        <span class="comment">//操作系统相关参数</span></span><br><span class="line">	<span class="keyword">void</span> *os_context;</span><br><span class="line">	<span class="keyword">void</span> *driver_context;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_list</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ll_init;</span><br><span class="line">	u32 data_bytes_per_chunk;</span><br><span class="line"></span><br><span class="line">	u16 chunk_grp_bits;</span><br><span class="line">	u16 chunk_grp_size;</span><br><span class="line">        <span class="comment">//TNode相关参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tnode</span> *<span class="title">tn_swap_buffer</span>;</span></span><br><span class="line">	u32 tnode_width;</span><br><span class="line">	u32 tnode_mask;</span><br><span class="line">	u32 tnode_size;</span><br><span class="line">        <span class="comment">//Chunk大小相关参数</span></span><br><span class="line">	u32 chunk_shift;	</span><br><span class="line">	u32 chunk_div;		</span><br><span class="line">	u32 chunk_mask;		</span><br><span class="line">        <span class="comment">//与文件系统挂载相关标识符</span></span><br><span class="line">	<span class="keyword">int</span> is_mounted;</span><br><span class="line">	<span class="keyword">int</span> read_only;</span><br><span class="line">	<span class="keyword">int</span> is_checkpointed;</span><br><span class="line">	<span class="keyword">int</span> swap_endian;	</span><br><span class="line">        <span class="comment">//块管理相关参数</span></span><br><span class="line">	u32 internal_start_block;</span><br><span class="line">	u32 internal_end_block;</span><br><span class="line">	<span class="keyword">int</span> block_offset;</span><br><span class="line">	<span class="keyword">int</span> chunk_offset;</span><br><span class="line">        <span class="comment">//检查点相关参数</span></span><br><span class="line">	<span class="keyword">int</span> checkpt_page_seq;</span><br><span class="line">        ..............</span><br><span class="line">	<span class="comment">//块管理相关参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">block_info</span>;</span></span><br><span class="line">	u8 *chunk_bits;		<span class="comment">/* bitmap of chunks in use */</span></span><br><span class="line">	u8 block_info_alt:<span class="number">1</span>;	<span class="comment">/* allocated using alternative alloc */</span></span><br><span class="line">	u8 chunk_bits_alt:<span class="number">1</span>;	<span class="comment">/* allocated using alternative alloc */</span></span><br><span class="line">	<span class="keyword">int</span> chunk_bit_stride;	</span><br><span class="line">	<span class="keyword">int</span> n_erased_blocks;</span><br><span class="line">	<span class="keyword">int</span> alloc_block;	</span><br><span class="line">	u32 alloc_page;</span><br><span class="line">	<span class="keyword">int</span> alloc_block_finder;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tnode或者Object内存分配相关参数 */</span></span><br><span class="line">	<span class="keyword">void</span> *allocator;</span><br><span class="line">	<span class="keyword">int</span> n_obj;</span><br><span class="line">	<span class="keyword">int</span> n_tnodes;</span><br><span class="line">	<span class="keyword">int</span> n_hardlinks;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj_bucket</span> <span class="title">obj_bucket</span>[<span class="title">YAFFS_NOBJECT_BUCKETS</span>];</span></span><br><span class="line">	u32 bucket_finder;</span><br><span class="line">	<span class="keyword">int</span> n_free_chunks; </span><br><span class="line">        <span class="comment">//垃圾回收相关参数</span></span><br><span class="line">	u32 *gc_cleanup_list;</span><br><span class="line">       ................</span><br><span class="line">	<span class="comment">//根目录及lost and found目录</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj</span> *<span class="title">root_dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj</span> *<span class="title">lost_n_found</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> buffered_block;	<span class="comment">/* Which block is buffered here? */</span></span><br><span class="line">	<span class="keyword">int</span> doing_buffered_block_rewrite;</span><br><span class="line">        <span class="comment">//Yaffs缓存相关</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cache_last_use;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 后台删除或者unlink文件相关参数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj</span> *<span class="title">unlinked_dir</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj</span> *<span class="title">del_dir</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_obj</span> *<span class="title">unlinked_deletion</span>;</span></span><br><span class="line">	<span class="keyword">int</span> n_deleted_files;	</span><br><span class="line">	<span class="keyword">int</span> n_unlinked_files;	<span class="comment">/* Count of unlinked files. */</span></span><br><span class="line">	<span class="keyword">int</span> n_bg_deletions;	<span class="comment">/* Count of background deletions. */</span></span><br><span class="line">	<span class="comment">/* 临时缓存相关 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_buffer</span> <span class="title">temp_buffer</span>[<span class="title">YAFFS_N_TEMP_BUFFERS</span>];</span></span><br><span class="line">	<span class="keyword">int</span> max_temp;</span><br><span class="line">	<span class="keyword">int</span> temp_in_use;</span><br><span class="line">	<span class="keyword">int</span> unmanaged_buffer_allocs;</span><br><span class="line">	<span class="keyword">int</span> unmanaged_buffer_deallocs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> seq_number;	</span><br><span class="line">	<span class="keyword">unsigned</span> oldest_dirty_seq;</span><br><span class="line">	<span class="keyword">unsigned</span> oldest_dirty_block;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> refresh_skip;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dirty_dirs</span>;</span>	</span><br><span class="line">	<span class="keyword">int</span> chunks_per_summary;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_summary_tags</span> *<span class="title">sum_tags</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 统计数据*/</span></span><br><span class="line">	u32 n_page_writes;</span><br><span class="line">        .......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>yaffs_param 主要包含文件系统相关参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_param</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> YCHAR *name;      <span class="comment">//文件系统对应的MTD设备名称</span></span><br><span class="line">	<span class="keyword">int</span> inband_tags;	<span class="comment">/* Use unband tags */</span></span><br><span class="line">	u32 total_bytes_per_chunk;<span class="comment">//每个chunk的大小（字节为单位）</span></span><br><span class="line">	u32 chunks_per_block; <span class="comment">//每个Flash块的chunk数量</span></span><br><span class="line">	u32 spare_bytes_per_chunk;<span class="comment">//每个chunk后的spare区域大小（字节为单位）</span></span><br><span class="line">	u32 start_block; <span class="comment">//第一个可以使用的块	</span></span><br><span class="line">        u32 end_block;	<span class="comment">//最后一个可使用的块</span></span><br><span class="line">	u32 n_reserved_blocks; <span class="comment">//保留的块数量，主要为垃圾回收机制使用	</span></span><br><span class="line">	u32 n_caches;<span class="comment">//Yaffs高速缓存的数量。Flash颗粒的写擦除是有次数上限的，为了避免读写端数据时Flash的频繁访问影响flash寿命，且避免访问Flash的性能下降，Yaffs定义了一些磁盘高速缓存在内存中</span></span><br><span class="line">	<span class="keyword">int</span> cache_bypass_aligned; <span class="comment">//若值为1：当读写是从chunk align的位置开始，便不使用cache</span></span><br><span class="line">	<span class="keyword">int</span> use_nand_ecc;	<span class="comment">//使用Nand Driver的ECC方法</span></span><br><span class="line">	<span class="keyword">int</span> tags_9bytes;	<span class="comment">/* Use 9 byte tags */</span></span><br><span class="line">	<span class="keyword">int</span> no_tags_ecc;	<span class="comment">//是否对Tag使用ECC</span></span><br><span class="line">	<span class="keyword">int</span> is_yaffs2;		<span class="comment">//是否是Yaffs2</span></span><br><span class="line">	<span class="keyword">int</span> empty_lost_n_found;	</span><br><span class="line">	<span class="keyword">int</span> refresh_period;	<span class="comment">//检查Block的时间间隔</span></span><br><span class="line">	u8 skip_checkpt_rd;     <span class="comment">//是否跳过checkpoint检查</span></span><br><span class="line">	u8 skip_checkpt_wr;</span><br><span class="line">	<span class="keyword">int</span> enable_xattr;	<span class="comment">/* Enable xattribs */</span></span><br><span class="line">	<span class="keyword">int</span> max_objects;	<span class="comment">//最大的yaffs object数量</span></span><br><span class="line">	<span class="keyword">int</span> hide_lost_n_found;  <span class="comment">//是否隐藏lost and found目录</span></span><br><span class="line">	<span class="keyword">int</span> stored_endian;      <span class="comment">//大小端</span></span><br><span class="line">	<span class="keyword">void</span> (*remove_obj_fn) (struct yaffs_obj *obj); <span class="comment">//移除object的函数回调</span></span><br><span class="line">	<span class="keyword">void</span> (*sb_dirty_fn) (struct yaffs_dev *dev);<span class="comment">//超级块标记脏函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> (*gc_control_fn) (struct yaffs_dev *dev);<span class="comment">//垃圾回收管理的回调函数</span></span><br><span class="line">        <span class="comment">//以下为debug相关标记</span></span><br><span class="line">	<span class="keyword">int</span> use_header_file_size;	</span><br><span class="line">	<span class="keyword">int</span> disable_lazy_load;	</span><br><span class="line">	<span class="keyword">int</span> wide_tnodes_disabled;	</span><br><span class="line">	<span class="keyword">int</span> disable_soft_del;	</span><br><span class="line">	<span class="keyword">int</span> defered_dir_update;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> auto_unicode;</span><br><span class="line">	<span class="keyword">int</span> always_check_erased;</span><br><span class="line">	<span class="keyword">int</span> disable_summary;</span><br><span class="line">	<span class="keyword">int</span> disable_bad_block_marking;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以下为yaffs标签相关处理函数，在yaffs_tags_marshall_install函数初始化。源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tags_handler</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*write_chunk_tags_fn) (struct yaffs_dev *dev,<span class="keyword">int</span> nand_chunk, <span class="keyword">const</span> u8 *data,<span class="keyword">const</span> struct yaffs_ext_tags *tags);</span><br><span class="line">	<span class="keyword">int</span> (*read_chunk_tags_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> nand_chunk, u8 *data,struct yaffs_ext_tags *tags);</span><br><span class="line">	<span class="keyword">int</span> (*query_block_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> block_no,<span class="keyword">enum</span> yaffs_block_state *state, u32 *seq_number);</span><br><span class="line">	<span class="keyword">int</span> (*mark_bad_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> block_no);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yaffs_tags_marshall_install</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;param.is_yaffs2)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;tagger.write_chunk_tags_fn)</span><br><span class="line">		dev-&gt;tagger.write_chunk_tags_fn = yaffs_tags_marshall_write;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;tagger.read_chunk_tags_fn)</span><br><span class="line">		dev-&gt;tagger.read_chunk_tags_fn = yaffs_tags_marshall_read;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;tagger.query_block_fn)</span><br><span class="line">		dev-&gt;tagger.query_block_fn = yaffs_tags_marshall_query_block;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;tagger.mark_bad_fn)</span><br><span class="line">		dev-&gt;tagger.mark_bad_fn = yaffs_tags_marshall_mark_bad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yaffs_driver定义了Yaffs驱动相关，读写擦除，坏块检查等操作MTD设备的接口函数，其初始化位于yaffs_mtd_drv_install函数。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*drv_write_chunk_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> nand_chunk, <span class="keyword">const</span> u8 *data, <span class="keyword">int</span> data_len, <span class="keyword">const</span> u8 *oob, <span class="keyword">int</span> oob_len);</span><br><span class="line">	<span class="keyword">int</span> (*drv_read_chunk_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> nand_chunk, u8 *data, <span class="keyword">int</span> data_len,u8 *oob, <span class="keyword">int</span> oob_len,<span class="keyword">enum</span> yaffs_ecc_result *ecc_result);</span><br><span class="line">	<span class="keyword">int</span> (*drv_erase_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> block_no);</span><br><span class="line">	<span class="keyword">int</span> (*drv_mark_bad_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> block_no);</span><br><span class="line">	<span class="keyword">int</span> (*drv_check_bad_fn) (struct yaffs_dev *dev, <span class="keyword">int</span> block_no);</span><br><span class="line">	<span class="keyword">int</span> (*drv_initialise_fn) (struct yaffs_dev *dev);</span><br><span class="line">	<span class="keyword">int</span> (*drv_deinitialise_fn) (struct yaffs_dev *dev);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yaffs_mtd_drv_install</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_driver</span> *<span class="title">drv</span> = &amp;<span class="title">dev</span>-&gt;<span class="title">drv</span>;</span></span><br><span class="line"></span><br><span class="line">	drv-&gt;drv_write_chunk_fn = yaffs_mtd_write;</span><br><span class="line">	drv-&gt;drv_read_chunk_fn = yaffs_mtd_read;</span><br><span class="line">	drv-&gt;drv_erase_fn = yaffs_mtd_erase;</span><br><span class="line">	drv-&gt;drv_mark_bad_fn = yaffs_mtd_mark_bad;</span><br><span class="line">	drv-&gt;drv_check_bad_fn = yaffs_mtd_check_bad;</span><br><span class="line">	drv-&gt;drv_initialise_fn = yaffs_mtd_initialise;</span><br><span class="line">	drv-&gt;drv_deinitialise_fn = yaffs_mtd_deinitialise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为Yaffs选项，为yaffs系统挂载（Mount）时配置，最后被传给yaffs_dev对应栏位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_options</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> inband_tags;         </span><br><span class="line">	<span class="keyword">int</span> skip_checkpoint_read;</span><br><span class="line">	<span class="keyword">int</span> skip_checkpoint_write;</span><br><span class="line">	<span class="keyword">int</span> no_cache;</span><br><span class="line">	<span class="keyword">int</span> tags_ecc_on;</span><br><span class="line">	<span class="keyword">int</span> tags_ecc_overridden;</span><br><span class="line">	<span class="keyword">int</span> lazy_loading_enabled;</span><br><span class="line">	<span class="keyword">int</span> lazy_loading_overridden;</span><br><span class="line">	<span class="keyword">int</span> empty_lost_and_found;</span><br><span class="line">	<span class="keyword">int</span> empty_lost_and_found_overridden;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>yaffs对应Linux对应上下文：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_linux_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">context_list</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_dev</span> *<span class="title">dev</span>;</span> <span class="comment">//指向Yaffs Dev的回调</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">super</span>;</span> <span class="comment">//指向超级块指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">bg_thread</span>;</span>	<span class="comment">//做GC的后台线程</span></span><br><span class="line">	<span class="keyword">int</span> bg_running; <span class="comment">//后台线程启动标记</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">gross_lock</span>;</span> <span class="comment">//大粒度锁，用来保护文件系统关键字段</span></span><br><span class="line">	u8 *spare_buffer;	<span class="comment">//Spare缓冲区</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">search_contexts</span>;</span> <span class="comment">//目录查找上下文链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">readdir_process</span>;</span> <span class="comment">//标记当前目录读取的task</span></span><br><span class="line">	<span class="keyword">unsigned</span> mount_id; <span class="comment">//yaffs2挂载的id号，对每个yaffs文件系统来讲标号唯一</span></span><br><span class="line">	<span class="keyword">int</span> dirty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h2><p>挂载后，整个文件系统才会为操作系统所用。YAFFS文件系统的挂载过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其实yaffs2挂载就是执行内核的mount_bdev函数，最后当然也会执行到传入的回调函数yaffs_internal_read_super</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">yaffs2_mount</span><span class="params">(struct file_system_type *fs_type, <span class="keyword">int</span> flags,<span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs2_internal_read_super_mtd</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> yaffs_internal_read_super(<span class="number">2</span>, sb, data, silent) ? <span class="number">0</span> : -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct super_block *<span class="title">yaffs_internal_read_super</span><span class="params">(<span class="keyword">int</span> yaffs_version, struct super_block *sb,  <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        <span class="comment">//超级块的一些初使设置</span></span><br><span class="line">	sb-&gt;s_magic = YAFFS_MAGIC;</span><br><span class="line">	sb-&gt;s_op = &amp;yaffs_super_ops;</span><br><span class="line">	sb-&gt;s_flags |= MS_NOATIME;</span><br><span class="line">	read_only = ((sb-&gt;s_flags &amp; MS_RDONLY) != <span class="number">0</span>);</span><br><span class="line">	sb-&gt;s_export_op = &amp;yaffs_export_ops;</span><br><span class="line">        .......</span><br><span class="line">	<span class="keyword">if</span> (yaffs_parse_options(&amp;options, data_str))</span><br><span class="line">		<span class="comment">/* Option parsing failed */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        .......</span><br><span class="line">	sb-&gt;s_blocksize = PAGE_CACHE_SIZE;</span><br><span class="line">	sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;</span><br><span class="line">        .......</span><br><span class="line">	mtd = get_mtd_device(<span class="literal">NULL</span>, MINOR(sb-&gt;s_dev));</span><br><span class="line">        .......</span><br><span class="line">        <span class="comment">//若文件分区是MTD device类型的Nand Flash，开始着手建立整个yaffs_dev</span></span><br><span class="line">	<span class="keyword">if</span> (!read_only &amp;&amp; !(mtd-&gt;flags &amp; MTD_WRITEABLE)) &#123;</span><br><span class="line">		read_only = <span class="number">1</span>;</span><br><span class="line">		sb-&gt;s_flags |= MS_RDONLY;</span><br><span class="line">	&#125;</span><br><span class="line">	dev = kmalloc(<span class="keyword">sizeof</span>(struct yaffs_dev), GFP_KERNEL);</span><br><span class="line">	context = kmalloc(<span class="keyword">sizeof</span>(struct yaffs_linux_context), GFP_KERNEL);</span><br><span class="line">        .......</span><br><span class="line">	<span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct yaffs_dev));</span><br><span class="line">	param = &amp;(dev-&gt;param);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(context, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct yaffs_linux_context));</span><br><span class="line">	dev-&gt;os_context = context;</span><br><span class="line">	INIT_LIST_HEAD(&amp;(context-&gt;context_list));</span><br><span class="line">	context-&gt;dev = dev;</span><br><span class="line">	context-&gt;super = sb;</span><br><span class="line"></span><br><span class="line">	dev-&gt;read_only = read_only;</span><br><span class="line">	sb-&gt;s_fs_info = dev;</span><br><span class="line">	dev-&gt;driver_context = mtd;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设定yaffs_param相关参数</span></span><br><span class="line">        ...............</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;yaffs_context_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (mount_id = <span class="number">0</span>, found = <span class="number">0</span>; !found; mount_id++) &#123;</span><br><span class="line">		found = <span class="number">1</span>;</span><br><span class="line">		list_for_each(l, &amp;yaffs_context_list) &#123;</span><br><span class="line">			context_iterator =list_entry(l, struct yaffs_linux_context,context_list);</span><br><span class="line">			<span class="keyword">if</span> (context_iterator-&gt;mount_id == mount_id)</span><br><span class="line">				found = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	context-&gt;mount_id = mount_id;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;(yaffs_dev_to_lc(dev)-&gt;context_list),</span><br><span class="line">		      &amp;yaffs_context_list);</span><br><span class="line">	mutex_unlock(&amp;yaffs_context_lock);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;(yaffs_dev_to_lc(dev)-&gt;gross_lock));</span><br><span class="line">	yaffs_gross_lock(dev);</span><br><span class="line">        <span class="comment">//建立yaffs_dev参数，以及初始化Tnode</span></span><br><span class="line">	err = yaffs_guts_initialise(dev);</span><br><span class="line">        <span class="comment">//执行yaffs的后台线程</span></span><br><span class="line">	<span class="keyword">if</span> (err == YAFFS_OK) yaffs_bg_start(dev);</span><br><span class="line">	<span class="keyword">if</span> (!context-&gt;bg_thread)</span><br><span class="line">		param-&gt;defered_dir_update = <span class="number">0</span>;</span><br><span class="line">	sb-&gt;s_maxbytes = yaffs_max_file_size(dev);</span><br><span class="line">	yaffs_gross_unlock(dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建文件系统根节点</span></span><br><span class="line">	<span class="keyword">if</span> (err == YAFFS_OK)</span><br><span class="line">		inode = yaffs_get_inode(sb, S_IFDIR | <span class="number">0755</span>, <span class="number">0</span>, yaffs_root(dev));</span><br><span class="line">        .......</span><br><span class="line">	inode-&gt;i_op = &amp;yaffs_dir_inode_operations;</span><br><span class="line">	inode-&gt;i_fop = &amp;yaffs_dir_operations;</span><br><span class="line">	root = d_alloc_root(inode);</span><br><span class="line">        .......</span><br><span class="line">	sb-&gt;s_root = root;</span><br><span class="line">	sb-&gt;s_dirt = !dev-&gt;is_checkpointed;</span><br><span class="line">	<span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了Yaffs的架构、文件结构及初始化流程。之后章节介绍：</p>
<ul>
<li>checkpoint机制</li>
<li>YAFFS参数调优及Debug</li>
<li>…….</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>YAFFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Yaffs文件系统(2)--块及Chunk管理</title>
    <url>/p/2dea932a.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.l2h.site/2019/04/30/yaffs-1/" target="_blank" rel="noopener">Yaffs文件系统(1)-概述</a>对文件系统的基本数据结构和初始化流程进行了介绍，本节着重介绍Yaffs如何对Block和Chunk进行管理的。</p><h2 id="Block分类"><a href="#Block分类" class="headerlink" title="Block分类"></a>Block分类</h2><p>UNKNOWN</p><p>区块状态未知</p><p>NEEDS_SCANNING</p><p>预扫描时确定该Block需要被扫描</p><p>SCANNING</p><p>Block正在扫描</p><p>EMPTY</p><p>Block为空，表示已经被擦除</p><a id="more"></a>








<p>ALLOCATING</p>
<p>Block被Chunk分配器使用中</p>
<p>FULL</p>
<p>Block已经分配，且至少有一个chunk被删除</p>
<p>DIRTY</p>
<p>Block全部chunk被删可被擦除</p>
<p>CHECKPOINT</p>
<p>Block中包含checkpoint数据</p>
<p>COLLECTING</p>
<p>Block正在被做垃圾回收</p>
<p>DEAD</p>
<p>Block为坏块</p>
<p>以上Block状态转化图如下：</p>
<p><img src="http://pic.l2h.site/yaffs-2-1.png" alt></p>
<h2 id="Block和Chunk分配"><a href="#Block和Chunk分配" class="headerlink" title="Block和Chunk分配"></a>Block和Chunk分配</h2><p>Yaffs分配原则如下：</p>
<ul>
<li>Yaffs保存目前正在使用的Block编号，优先从该block上分配Chunk</li>
<li>当Block已经分配完毕（进入FULL状态），则选取另外一个未分配Block（即EMPTY Block）来分配</li>
<li>分配Chunk时，更新该Block对应的分配位图</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_alloc_chunk</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> use_reserver, struct yaffs_block_info **block_ptr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret_val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span>;</span></span><br><span class="line">        <span class="comment">//若当前用于分配的Block为0，则找到一个EMPTY块分配</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;alloc_block &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev-&gt;alloc_block = yaffs_find_alloc_block(dev);</span><br><span class="line">		dev-&gt;alloc_page = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        ..........</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;alloc_block &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//取得当前Block信息</span></span><br><span class="line">		bi = yaffs_get_block_info(dev, dev-&gt;alloc_block);</span><br><span class="line">                <span class="comment">//得到Chunk ID</span></span><br><span class="line">		ret_val = (dev-&gt;alloc_block * dev-&gt;param.chunks_per_block) + dev-&gt;alloc_page;</span><br><span class="line">		bi-&gt;pages_in_use++;</span><br><span class="line">                <span class="comment">//设定当前Block的Chunk位图，更新剩余chunk的id，以及当前Block已分配page数量</span></span><br><span class="line">		yaffs_set_chunk_bit(dev, dev-&gt;alloc_block, dev-&gt;alloc_page);</span><br><span class="line">		dev-&gt;alloc_page++;</span><br><span class="line">		dev-&gt;n_free_chunks--;</span><br><span class="line">                <span class="comment">//若已经分配数量大于Block支持最大的数量，则标记block状态为FULL，同时设置alloc_block为-1，表示重新查找一个EMPTY block进行分配</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;alloc_page &gt;= dev-&gt;param.chunks_per_block)          &#123;</span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">			dev-&gt;alloc_block = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (block_ptr) *block_ptr = bi;</span><br><span class="line">		<span class="keyword">return</span> ret_val;</span><br><span class="line">	&#125;</span><br><span class="line">        .......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_find_alloc_block</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ......<span class="comment">//若剩余可用Block不足，则不分配</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//以下为遍历查找一个可用block</span></span><br><span class="line">	<span class="keyword">for</span> (i = dev-&gt;internal_start_block; i &lt;= dev-&gt;internal_end_block; i++) &#123;</span><br><span class="line">		dev-&gt;alloc_block_finder++;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;alloc_block_finder &lt; (<span class="keyword">int</span>)dev-&gt;internal_start_block || dev-&gt;alloc_block_finder &gt; (<span class="keyword">int</span>)dev-&gt;internal_end_block) &#123;</span><br><span class="line">			dev-&gt;alloc_block_finder = dev-&gt;internal_start_block;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bi = yaffs_get_block_info(dev, dev-&gt;alloc_block_finder);</span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line"><span class="comment">//查找到一个EMPLY Block，则使用之，使用前更新状态为ALLOCATING</span></span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line"><span class="comment">//序列号，用于标记文件chunk的新旧，每分配一个block就+1</span></span><br><span class="line">			dev-&gt;seq_number++;</span><br><span class="line">			bi-&gt;seq_number = dev-&gt;seq_number;</span><br><span class="line">			dev-&gt;n_erased_blocks--;</span><br><span class="line">			<span class="keyword">return</span> dev-&gt;alloc_block_finder;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">..........</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct yaffs_block_info *<span class="title">yaffs_get_block_info</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">..........</span><br><span class="line">       <span class="comment">//返回当前Block的info</span></span><br><span class="line">	<span class="keyword">return</span> &amp;dev-&gt;block_info[blk - dev-&gt;internal_start_block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Block的扫描"><a href="#Block的扫描" class="headerlink" title="Block的扫描"></a>Block的扫描</h2><p>扫描的目的是Mount时建立起Yaffs的文件结构，代码实现在yaffs_guts_initialise（如果您还有印象，即mount过程中yaffs_internal_read_super会调用到的），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_guts_initialise</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//yaffs的Low Level初始化，主要为初始化一些基本参数</span></span><br><span class="line">	<span class="keyword">if</span>(yaffs_guts_ll_init(dev) != YAFFS_OK) <span class="keyword">return</span> YAFFS_FAIL; </span><br><span class="line">......</span><br><span class="line">	dev-&gt;is_mounted = <span class="number">1</span>;</span><br><span class="line">......<span class="comment">//初始化块管理相关一些基本参数</span></span><br><span class="line">	<span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_init_blocks(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//初始化tnode对象树</span></span><br><span class="line">	yaffs_init_tnodes_and_objs(dev);</span><br><span class="line">      <span class="comment">//初始化根目录、lost and found等特殊目录</span></span><br><span class="line">	<span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_create_initial_dir(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//summary init（Yaffs2新引入的机制，利用block的空白chunk区域存储一些有效信息来帮助加速加载）</span></span><br><span class="line">	<span class="keyword">if</span> (!init_failed &amp;&amp; dev-&gt;param.is_yaffs2 &amp;&amp; !dev-&gt;param.disable_summary &amp;&amp; !yaffs_summary_init(dev))</span><br><span class="line">		init_failed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!init_failed) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;param.is_yaffs2) &#123;</span><br><span class="line">      <span class="comment">//尝试从checkpoint中恢复mount</span></span><br><span class="line">			<span class="keyword">if</span> (yaffs2_checkpt_restore(dev)) &#123;</span><br><span class="line">				yaffs_check_obj_details_loaded(dev-&gt;root_dir);</span><br><span class="line">......</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果checkpoint加载失败，则重新初始化block和tnode树（因为checkpoint加载过程中可能已经使用了相关结构做存储，而我们这里要重新建立）</span></span><br><span class="line">				yaffs_deinit_blocks(dev);</span><br><span class="line">				yaffs_deinit_tnodes_and_objs(dev);</span><br><span class="line">......</span><br><span class="line">				<span class="keyword">if</span> (!init_failed &amp;&amp; yaffs_init_blocks(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">				yaffs_init_tnodes_and_objs(dev);</span><br><span class="line">				<span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs_create_initial_dir(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//执行Block扫描过程</span></span><br><span class="line">				<span class="keyword">if</span> (!init_failed &amp;&amp; !yaffs2_scan_backwards(dev)) init_failed = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!yaffs1_scan(dev)) &#123;</span><br><span class="line">			init_failed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		yaffs_strip_deleted_objs(dev);</span><br><span class="line">		yaffs_fix_hanging_objs(dev);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;param.empty_lost_n_found)</span><br><span class="line">			yaffs_empty_l_n_f(dev);</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">	<span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文暂不讨论summary以及checkpoint等情况，那么整个block加载过程的核心代码即为：<strong>yaffs2_scan_backwards</strong>。详细如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs2_scan_backwards</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">	dev-&gt;seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;</span><br><span class="line"><span class="comment">//为block信息存储分配空间</span></span><br><span class="line">	block_index = kmalloc(n_blocks * <span class="keyword">sizeof</span>(struct yaffs_block_index), GFP_NOFS);</span><br><span class="line">	<span class="keyword">if</span> (!block_index) &#123;</span><br><span class="line">		block_index =  vmalloc(n_blocks * <span class="keyword">sizeof</span>(struct yaffs_block_index)); alt_block_index = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">	dev-&gt;blocks_in_checkpt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	chunk_data = yaffs_get_temp_buffer(dev);</span><br><span class="line"><span class="comment">//以下这段代码看着很长，但其实比较容易理解，详见注释</span></span><br><span class="line">	bi = dev-&gt;block_info;</span><br><span class="line">	<span class="keyword">for</span> (blk = dev-&gt;internal_start_block; blk &lt;= dev-&gt;internal_end_block; blk++) &#123;</span><br><span class="line"><span class="comment">//清除block的chunk使用标记</span></span><br><span class="line">		yaffs_clear_chunk_bits(dev, blk);</span><br><span class="line">		bi-&gt;pages_in_use = <span class="number">0</span>;</span><br><span class="line">		bi-&gt;soft_del_pages = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//得到block初始状态以及序列号，即执行yaffs_tags_marshall_query_block得到当前block里chunk是否有正在使用，如果有则需要扫描</span></span><br><span class="line">		yaffs_query_init_block_state(dev, blk, &amp;state, &amp;seq_number);</span><br><span class="line">		bi-&gt;block_state = state;</span><br><span class="line">		bi-&gt;seq_number = seq_number;</span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)</span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_CHECKPOINT;</span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;seq_number == YAFFS_SEQUENCE_BAD_BLOCK)</span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_DEAD;</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_CHECKPOINT) &#123;</span><br><span class="line">			dev-&gt;blocks_in_checkpt++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_DEAD) &#123;</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, <span class="string">"block %d is bad"</span>, blk);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, <span class="string">"Block empty "</span>);</span><br><span class="line">			dev-&gt;n_erased_blocks++;</span><br><span class="line">			dev-&gt;n_free_chunks += dev-&gt;param.chunks_per_block;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) &#123;</span><br><span class="line"><span class="comment">//如果block状态为needs_scan，则标记后续对block进行scan</span></span><br><span class="line">			<span class="keyword">if</span> (seq_number &gt;= YAFFS_LOWEST_SEQUENCE_NUMBER &amp;&amp; seq_number &lt; YAFFS_HIGHEST_SEQUENCE_NUMBER) &#123;</span><br><span class="line">				block_index[n_to_scan].seq = seq_number;</span><br><span class="line">				block_index[n_to_scan].block = blk;</span><br><span class="line">				n_to_scan++;</span><br><span class="line">				<span class="keyword">if</span> (seq_number &gt;= dev-&gt;seq_number)</span><br><span class="line">					dev-&gt;seq_number = seq_number;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">"Block scanning block %d has bad sequence number %d"</span>, blk, seq_number);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bi++;</span><br><span class="line">	&#125;</span><br><span class="line">...... <span class="comment">//对block进行排序，排序的依据是按照block的序列号。会这样做原因是yaffs在管理文件，采用就是逐步增加的序列号。同一个文件同一个chunk id，较大的序列号为最新。这也是函数scan_backwards的由来。</span></span><br><span class="line">	sort(block_index, n_to_scan, <span class="keyword">sizeof</span>(struct yaffs_block_index),</span><br><span class="line">		   yaffs2_ybicmp, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//真正开始进行扫描</span></span><br><span class="line">	start_iter = <span class="number">0</span>;</span><br><span class="line">	end_iter = n_to_scan - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (block_iter = end_iter;!alloc_failed &amp;&amp; block_iter &gt;= start_iter;block_iter--) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//对每个需要扫描的block进行扫描</span></span><br><span class="line">		blk = block_index[block_iter].block;</span><br><span class="line">		bi = yaffs_get_block_info(dev, blk);</span><br><span class="line">		deleted = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//summary读取，本文不做详述</span></span><br><span class="line">		summary_available = yaffs_summary_read(dev, dev-&gt;sum_tags, blk);</span><br><span class="line">		found_chunks = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (summary_available)</span><br><span class="line">			c = dev-&gt;chunks_per_summary - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			c = dev-&gt;param.chunks_per_block - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//对block中的每一个chunk进行扫描</span></span><br><span class="line">		<span class="keyword">for</span> (  !alloc_failed &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		     (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||</span><br><span class="line">		      bi-&gt;block_state == YAFFS_BLOCK_STATE_ALLOCATING);</span><br><span class="line">		      c--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (yaffs2_scan_chunk(dev, bi, blk, c, &amp;found_chunks, chunk_data, &amp;hard_list, summary_available) == YAFFS_FAIL) alloc_failed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) &#123;</span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;pages_in_use == <span class="number">0</span> &amp;&amp;  !bi-&gt;has_shrink_hdr &amp;&amp;</span><br><span class="line">		    bi-&gt;block_state == YAFFS_BLOCK_STATE_FULL) &#123;</span><br><span class="line">			yaffs_block_became_dirty(dev, blk);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	yaffs_skip_rest_of_block(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alt_block_index) vfree(block_index);</span><br><span class="line">	<span class="keyword">else</span> kfree(block_index);</span><br><span class="line">        <span class="comment">//处理文件Hard Link</span></span><br><span class="line">	yaffs_link_fixup(dev, &amp;hard_list);</span><br><span class="line">        <span class="comment">//释放分配的临时缓存</span></span><br><span class="line">	yaffs_release_temp_buffer(dev, chunk_data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alloc_failed)</span><br><span class="line">		<span class="keyword">return</span> YAFFS_FAIL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码注释可以看出，yaffs2_scan_backwards核心代码为yaffs2_scan_chunk,代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">yaffs2_scan_chunk</span><span class="params">(struct yaffs_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct yaffs_block_info *bi,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> blk, <span class="keyword">int</span> chunk_in_block,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> *found_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">		u8 *chunk_data,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct list_head *hard_list,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> summary_available)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//如果存在summary则读取summary</span></span><br><span class="line">	<span class="keyword">int</span> chunk = blk * dev-&gt;param.chunks_per_block + chunk_in_block</span><br><span class="line">	<span class="keyword">if</span> (summary_available) &#123;</span><br><span class="line">		result = yaffs_summary_fetch(dev, &amp;tags, chunk_in_block);</span><br><span class="line">		tags.seq_number = bi-&gt;seq_number;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//从chunk中读取对应tag信息</span></span><br><span class="line">	<span class="keyword">if</span> (!summary_available || tags.obj_id == <span class="number">0</span>) &#123;</span><br><span class="line">		result = yaffs_rd_chunk_tags_nand(dev, chunk, <span class="literal">NULL</span>, &amp;tags);</span><br><span class="line">		dev-&gt;tags_used++;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev-&gt;summary_used++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!tags.chunk_used) &#123;</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">if</span> (*found_chunks) &#123;</span><br><span class="line">			<span class="comment">/* This is a chunk that was skipped due</span></span><br><span class="line"><span class="comment">			 * to failing the erased check */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (chunk_in_block == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//如果为block第一个chunk且未使用，则整个block为空</span></span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_EMPTY;</span><br><span class="line">			dev-&gt;n_erased_blocks++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若扫到block末尾，则进行相应标记</span></span><br><span class="line">			<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||  bi-&gt;block_state == YAFFS_BLOCK_STATE_ALLOCATING) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dev-&gt;seq_number == bi-&gt;seq_number) &#123;</span><br><span class="line">					bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line">					dev-&gt;alloc_block = blk;</span><br><span class="line">					dev-&gt;alloc_page = chunk_in_block;</span><br><span class="line">					dev-&gt;alloc_block_finder = blk;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//从打印可以看出该block之前没有写完整，导致block内seq_number不相同</span></span><br><span class="line">					yaffs_trace(YAFFS_TRACE_SCAN,</span><br><span class="line">						<span class="string">"Partially written block %d detected. gc will fix this."</span>, blk);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dev-&gt;n_free_chunks++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.ecc_result ==</span><br><span class="line">		YAFFS_ECC_RESULT_UNFIXED) &#123;</span><br><span class="line"><span class="comment">//出现ECC校验失败</span></span><br><span class="line">                yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">" Unfixed ECC in chunk(%d:%d), chunk ignored"</span>,blk, chunk_in_block);</span><br><span class="line">		dev-&gt;n_free_chunks++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.obj_id &gt; YAFFS_MAX_OBJECT_ID ||</span><br><span class="line">		   tags.chunk_id &gt; YAFFS_MAX_CHUNK_ID ||</span><br><span class="line">		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||</span><br><span class="line">		   (tags.chunk_id &gt; <span class="number">0</span> &amp;&amp;  tags.n_bytes &gt; dev-&gt;data_bytes_per_chunk) || tags.seq_number != bi-&gt;seq_number) &#123;</span><br><span class="line">                <span class="comment">//对一些异常chunk做处理</span></span><br><span class="line">		yaffs_trace(YAFFS_TRACE_SCAN, <span class="string">"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored"</span>, blk, chunk_in_block, tags.obj_id, tags.chunk_id, tags.n_bytes);</span><br><span class="line">		dev-&gt;n_free_chunks++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tags.chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//所有的tag标记都正常，则开始进行后续处理</span></span><br><span class="line">		<span class="comment">/* chunk_id &gt; 0 so it is a data chunk... */</span></span><br><span class="line">		<span class="keyword">loff_t</span> endpos;</span><br><span class="line">		<span class="keyword">loff_t</span> chunk_base = (tags.chunk_id - <span class="number">1</span>) *</span><br><span class="line">					dev-&gt;data_bytes_per_chunk;</span><br><span class="line"></span><br><span class="line">		*found_chunks = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记block中的chunk使用状况</span></span><br><span class="line">		yaffs_set_chunk_bit(dev, blk, chunk_in_block);</span><br><span class="line">		bi-&gt;pages_in_use++;</span><br><span class="line">        <span class="comment">//找到文件句柄。若没有，表示第一次扫到该文件，创建之</span></span><br><span class="line">		in = yaffs_find_or_create_by_number(dev,tags.obj_id, YAFFS_OBJECT_TYPE_FILE);</span><br><span class="line">		<span class="keyword">if</span> (!in)  alloc_failed = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (in &amp;&amp;  in-&gt;variant_type == YAFFS_OBJECT_TYPE_FILE &amp;&amp;</span><br><span class="line">		    chunk_base &lt; in-&gt;variant.file_variant.shrink_size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!yaffs_put_chunk_in_file(in, tags.chunk_id, chunk, <span class="number">-1</span>)) alloc_failed = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//将该文件部分加入tnode tree</span></span><br><span class="line">			endpos = chunk_base + tags.n_bytes;</span><br><span class="line">			<span class="keyword">if</span> (!in-&gt;valid &amp;&amp; in-&gt;variant.file_variant.scanned_size &lt; endpos) &#123;</span><br><span class="line">				in-&gt;variant.file_variant.</span><br><span class="line">				    scanned_size = endpos;</span><br><span class="line">				in-&gt;variant.file_variant.</span><br><span class="line">				    file_size = endpos;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (in) &#123;</span><br><span class="line"><span class="comment">//该文件超出了文件shrink大小，表示这是一个被resize过的文件，则删除超出文件大小的部分</span></span><br><span class="line">			yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//存放文件头部（chunk id为0）的chunk进行处理</span></span><br><span class="line">		*found_chunks = <span class="number">1</span>;</span><br><span class="line">		yaffs_set_chunk_bit(dev, blk, chunk_in_block);</span><br><span class="line">		bi-&gt;pages_in_use++;</span><br><span class="line">		oh = <span class="literal">NULL</span>;</span><br><span class="line">		in = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (tags.extra_available) &#123;</span><br><span class="line">			in = yaffs_find_or_create_by_number(dev,</span><br><span class="line">					tags.obj_id,</span><br><span class="line">					tags.extra_obj_type);</span><br><span class="line">			<span class="keyword">if</span> (!in) alloc_failed = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!in || (!in-&gt;valid &amp;&amp; dev-&gt;param.disable_lazy_load) || tags.extra_shadows || (!in-&gt;valid &amp;&amp; (tags.obj_id == YAFFS_OBJECTID_ROOT || tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) &#123;</span><br><span class="line"><span class="comment">//从头部中读取文件信息</span></span><br><span class="line">			result = yaffs_rd_chunk_tags_nand(dev, chunk,  chunk_data,  <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//文件头部的信息存放在chunk的数据起始位置</span></span><br><span class="line">			oh = (struct yaffs_obj_hdr *)chunk_data;</span><br><span class="line"><span class="comment">//使用Inband tag的特殊处理</span></span><br><span class="line">			<span class="keyword">if</span> (dev-&gt;param.inband_tags) &#123;</span><br><span class="line">				oh-&gt;shadows_obj = oh-&gt;inband_shadowed_obj_id;</span><br><span class="line">				oh-&gt;is_shrink = oh-&gt;inband_is_shrink;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//创建文件obj</span></span><br><span class="line">			<span class="keyword">if</span> (!in) &#123;</span><br><span class="line">				in = yaffs_find_or_create_by_number(dev, tags.obj_id, oh-&gt;type);</span><br><span class="line">				<span class="keyword">if</span> (!in) alloc_failed = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">..........</span><br><span class="line">		<span class="keyword">if</span> (in-&gt;valid) &#123;</span><br><span class="line"><span class="comment">//找到过同一文件。删除该chunk之前进行必要清理工作</span></span><br><span class="line">			<span class="keyword">if</span> ((in-&gt;variant_type == YAFFS_OBJECT_TYPE_FILE) &amp;&amp; ((oh &amp;&amp; oh-&gt;type == YAFFS_OBJECT_TYPE_FILE) || (tags.extra_available &amp;&amp;  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE) )) &#123;</span><br><span class="line">				<span class="keyword">loff_t</span> this_size = (oh) ? yaffs_oh_to_size(oh) : tags.extra_file_size;</span><br><span class="line">				u32 parent_obj_id = (oh) ? oh-&gt;parent_obj_id : tags.extra_parent_id;</span><br><span class="line">				is_shrink = (oh) ? oh-&gt;is_shrink : tags.extra_is_shrink;</span><br><span class="line"><span class="comment">//文件的父id若为特殊标记，则文件大小为0</span></span><br><span class="line">				<span class="keyword">if</span> (parent_obj_id == AFFS_OBJECTID_DELETED ||parent_obj_id == YAFFS_OBJECTID_UNLINKED) &#123;</span><br><span class="line">					this_size = <span class="number">0</span>;</span><br><span class="line">					is_shrink = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (is_shrink &amp;&amp;  in-&gt;variant.file_variant.shrink_size &gt; this_size)</span><br><span class="line">					in-&gt;variant.file_variant.shrink_size = this_size;</span><br><span class="line">				<span class="keyword">if</span> (is_shrink) bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Use existing - destroy this one. */</span></span><br><span class="line">			yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!in-&gt;valid &amp;&amp; in-&gt;variant_type !=</span><br><span class="line">		    (oh ? oh-&gt;type : tags.extra_obj_type)) &#123;</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line">				<span class="string">"yaffs tragedy: Bad type, %d != %d, for object %d at chunk %d during scan"</span>,</span><br><span class="line">				oh ? oh-&gt;type : tags.extra_obj_type,</span><br><span class="line">				in-&gt;variant_type, tags.obj_id,</span><br><span class="line">				chunk);</span><br><span class="line">			in = yaffs_retype_obj(in, oh ? oh-&gt;type : tags.extra_obj_type);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//Root目录和lostfound目录处理</span></span><br><span class="line">		<span class="keyword">if</span> (!in-&gt;valid &amp;&amp;  (tags.obj_id == YAFFS_OBJECTID_ROOT || tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) &#123;</span><br><span class="line">			in-&gt;valid = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (oh) &#123;</span><br><span class="line">				in-&gt;yst_mode = oh-&gt;yst_mode;</span><br><span class="line">				yaffs_load_attribs(in, oh);</span><br><span class="line">				in-&gt;lazy_loaded = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				in-&gt;lazy_loaded = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			in-&gt;hdr_chunk = chunk;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!in-&gt;valid) &#123;</span><br><span class="line"><span class="comment">//第一次找到文件头部</span></span><br><span class="line">			in-&gt;valid = <span class="number">1</span>;</span><br><span class="line">			in-&gt;hdr_chunk = chunk;</span><br><span class="line">			<span class="keyword">if</span> (oh) &#123;</span><br><span class="line">				in-&gt;variant_type = oh-&gt;type;</span><br><span class="line">				in-&gt;yst_mode = oh-&gt;yst_mode;</span><br><span class="line">				yaffs_load_attribs(in, oh);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (oh-&gt;shadows_obj &gt; <span class="number">0</span>) yaffs_handle_shadowed_obj(dev,  oh-&gt;shadows_obj, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				yaffs_set_obj_name_from_oh(in, oh);</span><br><span class="line">				parent = yaffs_find_or_create_by_number(dev, oh-&gt;parent_obj_id, YAFFS_OBJECT_TYPE_DIRECTORY);</span><br><span class="line">				file_size = yaffs_oh_to_size(oh);</span><br><span class="line">				is_shrink = oh-&gt;is_shrink;</span><br><span class="line">				equiv_id = oh-&gt;equiv_id;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				in-&gt;variant_type = tags.extra_obj_type;</span><br><span class="line">				parent = yaffs_find_or_create_by_number(dev, tags.extra_parent_id, YAFFS_OBJECT_TYPE_DIRECTORY);</span><br><span class="line">				file_size = tags.extra_file_size;</span><br><span class="line">				is_shrink = tags.extra_is_shrink;</span><br><span class="line">				equiv_id = tags.extra_equiv_id;</span><br><span class="line">				in-&gt;lazy_loaded = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			in-&gt;dirty = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!parent)</span><br><span class="line">				alloc_failed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (parent &amp;&amp;</span><br><span class="line">			    parent-&gt;variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) &#123;</span><br><span class="line">				parent-&gt;variant_type =</span><br><span class="line">					YAFFS_OBJECT_TYPE_DIRECTORY;</span><br><span class="line">				INIT_LIST_HEAD(&amp;parent-&gt;variant.dir_variant.children);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!parent || parent-&gt;variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) &#123;</span><br><span class="line"><span class="comment">//文件若找不到父目录放到lost and found</span></span><br><span class="line">				yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line">					<span class="string">"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."</span></span><br><span class="line">					);</span><br><span class="line">				parent = dev-&gt;lost_n_found;</span><br><span class="line">			&#125;</span><br><span class="line">			yaffs_add_obj_to_dir(parent, in);</span><br><span class="line"></span><br><span class="line">			is_unlinked = (parent == dev-&gt;del_dir) || (parent == dev-&gt;unlinked_dir);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (is_shrink)</span><br><span class="line">				bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">switch</span> (in-&gt;variant_type) &#123;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_UNKNOWN:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_FILE:</span><br><span class="line">				file_var = &amp;in-&gt;variant.file_variant;</span><br><span class="line">				<span class="keyword">if</span> (file_var-&gt;scanned_size &lt; file_size) &#123;</span><br><span class="line">				<span class="comment">//文件扫到的大小小于文件chunk头部表示的大小</span></span><br><span class="line">					file_var-&gt;file_size = file_size;</span><br><span class="line">					file_var-&gt;scanned_size = file_size;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (file_var-&gt;shrink_size &gt; file_size)</span><br><span class="line">					file_var-&gt;shrink_size = file_size;  <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_HARDLINK:</span><br><span class="line">				hl_var = &amp;in-&gt;variant.hardlink_variant;</span><br><span class="line">				<span class="keyword">if</span> (!is_unlinked) &#123;</span><br><span class="line">					hl_var-&gt;equiv_id = equiv_id;</span><br><span class="line">					list_add(&amp;in-&gt;hard_links, hard_list); &#125; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_DIRECTORY:</span><br><span class="line">				<span class="comment">/* Do nothing */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_SPECIAL:</span><br><span class="line">				<span class="comment">/* Do nothing */</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> YAFFS_OBJECT_TYPE_SYMLINK:</span><br><span class="line">				sl_var = &amp;in-&gt;variant.symlink_variant;</span><br><span class="line">				<span class="keyword">if</span> (oh) &#123;</span><br><span class="line">					sl_var-&gt;alias =</span><br><span class="line">					    yaffs_clone_str(oh-&gt;alias);</span><br><span class="line">					<span class="keyword">if</span> (!sl_var-&gt;alias)</span><br><span class="line">						alloc_failed = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> alloc_failed ? YAFFS_FAIL : YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就完成了扫描过程。</p>
<h2 id="Block分配"><a href="#Block分配" class="headerlink" title="Block分配"></a>Block分配</h2><p>执行Block分配一般是由写操作触发的，最后的三个函数调用顺序为yaffs_write_new_chunk–&gt;yaffs_alloc_chunk–&gt;yaffs_find_alloc_block。代码分析如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_write_new_chunk</span><span class="params">(struct yaffs_dev *dev,<span class="keyword">const</span> u8 *data, struct yaffs_ext_tags *tags, <span class="keyword">int</span> use_reserver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......<span class="comment">//因为写信chunk，表示Flash上内容已经改变了，将Checkpoint的数据设置为无效</span></span><br><span class="line">	yaffs2_checkpt_invalidate(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">......<span class="comment">//分配chunk空间</span></span><br><span class="line">		chunk = yaffs_alloc_chunk(dev, use_reserver, &amp;bi);</span><br><span class="line">		<span class="keyword">if</span> (chunk &lt; <span class="number">0</span>) &#123;<span class="comment">/* no space */</span><span class="keyword">break</span>;&#125;</span><br><span class="line">		attempts++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;param.always_check_erased)</span><br><span class="line">			bi-&gt;skip_erased_check = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!bi-&gt;skip_erased_check) &#123;</span><br><span class="line"><span class="comment">//确认chunk是否已经擦除</span></span><br><span class="line">			erased_ok = yaffs_check_chunk_erased(dev, chunk);</span><br><span class="line">			<span class="keyword">if</span> (erased_ok != YAFFS_OK) &#123;</span><br><span class="line">				yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line">				  <span class="string">"**&gt;\&gt; yaffs chunk %d was not erased"</span>, chunk);</span><br><span class="line"><span class="comment">//如果chunk没有擦除，则删除该chunk，跳到下个可用block寻找chunk</span></span><br><span class="line">				yaffs_chunk_del(dev, chunk, <span class="number">1</span>, __LINE__);</span><br><span class="line">				yaffs_skip_rest_of_block(dev);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//写数据和tag到chunk内</span></span><br><span class="line">		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);</span><br><span class="line">		<span class="keyword">if</span> (!bi-&gt;skip_erased_check)</span><br><span class="line">			write_ok =  yaffs_verify_chunk_written(dev, chunk, data, tags);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (write_ok != YAFFS_OK) &#123;</span><br><span class="line"><span class="comment">//执行写错的回调</span></span><br><span class="line">			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bi-&gt;skip_erased_check = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//执行成功的回调</span></span><br><span class="line">		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (write_ok != YAFFS_OK &amp;&amp; (yaffs_wr_attempts == <span class="number">0</span> || attempts &lt;= yaffs_wr_attempts));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!write_ok) chunk = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (attempts &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_ERROR,<span class="string">"**&gt;&gt; yaffs write required %d attempts"</span>,attempts);</span><br><span class="line">		dev-&gt;n_retried_writes += (attempts - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_alloc_chunk</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> use_reserver, struct yaffs_block_info **block_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;alloc_block &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//若当前无可分配的块，则分配块</span></span><br><span class="line">		dev-&gt;alloc_block = yaffs_find_alloc_block(dev);</span><br><span class="line">		dev-&gt;alloc_page = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!use_reserver &amp;&amp; !yaffs_check_alloc_available(dev, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="comment">//不使用保留块也找不到可用块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks &amp;&amp; dev-&gt;alloc_page == <span class="number">0</span>)</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_ALLOCATE, <span class="string">"Allocating reserve"</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;alloc_block &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		bi = yaffs_get_block_info(dev, dev-&gt;alloc_block);</span><br><span class="line">		ret_val = (dev-&gt;alloc_block * dev-&gt;param.chunks_per_block) +dev-&gt;alloc_page;</span><br><span class="line">		bi-&gt;pages_in_use++;</span><br><span class="line">		yaffs_set_chunk_bit(dev, dev-&gt;alloc_block, dev-&gt;alloc_page);</span><br><span class="line">		dev-&gt;alloc_page++;</span><br><span class="line">		dev-&gt;n_free_chunks--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若块已满，则标记状态为已满</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;alloc_page &gt;= dev-&gt;param.chunks_per_block) &#123;</span><br><span class="line">			bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">			dev-&gt;alloc_block = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (block_ptr)</span><br><span class="line">			*block_ptr = bi;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret_val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	yaffs_trace(YAFFS_TRACE_ERROR,</span><br><span class="line">		<span class="string">"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_find_alloc_block</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span>;</span></span><br><span class="line"><span class="comment">//没有可使用的块则返回-1</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; <span class="number">1</span>) &#123;</span><br><span class="line">	        yaffs_trace(YAFFS_TRACE_ERROR,<span class="string">"yaffs tragedy: no more erased blocks"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//否则，遍历找到一个可使用的块</span></span><br><span class="line">	<span class="keyword">for</span> (i = dev-&gt;internal_start_block; i &lt;= dev-&gt;internal_end_block; i++) &#123;</span><br><span class="line">		dev-&gt;alloc_block_finder++;</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;alloc_block_finder &lt; (<span class="keyword">int</span>)dev-&gt;internal_start_block || dev-&gt;alloc_block_finder &gt; (<span class="keyword">int</span>)dev-&gt;internal_end_block) &#123;</span><br><span class="line">			dev-&gt;alloc_block_finder = dev-&gt;internal_start_block;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bi = yaffs_get_block_info(dev, dev-&gt;alloc_block_finder);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_EMPTY) &#123;</span><br><span class="line"><span class="comment">//找到块的条件是该块的状态为EMPTY，此时返回块的编号			</span></span><br><span class="line">bi-&gt;block_state = YAFFS_BLOCK_STATE_ALLOCATING;</span><br><span class="line">			dev-&gt;seq_number++;</span><br><span class="line">			bi-&gt;seq_number = dev-&gt;seq_number;</span><br><span class="line">			dev-&gt;n_erased_blocks--;</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_ALLOCATE,</span><br><span class="line">			  <span class="string">"Allocated block %d, seq  %d, %d left"</span> ,</span><br><span class="line">			   dev-&gt;alloc_block_finder, dev-&gt;seq_number,</span><br><span class="line">			   dev-&gt;n_erased_blocks);</span><br><span class="line">			<span class="keyword">return</span> dev-&gt;alloc_block_finder;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	yaffs_trace(YAFFS_TRACE_ALWAYS,<span class="string">"yaffs tragedy: no more erased blocks, but there should have been %d"</span>,dev-&gt;n_erased_blocks);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Block擦除"><a href="#Block擦除" class="headerlink" title="Block擦除"></a>Block擦除</h2><p>Block擦除的条件是：</p>
<ul>
<li>遇到坏块，且无法正确执行坏块标记</li>
<li>脏数据回收</li>
<li>上层下Format Flash指令</li>
</ul>
<p>其中脏数据回收是GC（Garbage Collection）机制在执行，后续章节会再对GC进行介绍。</p>
<p>擦除块执行的函数也很简单，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_erase_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	block_no -= dev-&gt;block_offset;</span><br><span class="line">	dev-&gt;n_erasures++;</span><br><span class="line">	result = dev-&gt;drv.drv_erase_fn(dev, block_no);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中drv_erase_fn回调函数在Linux的系统下最后MTD块系统的mtd_erase函数：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nandmtd_erase_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">mtd</span> = <span class="title">yaffs_dev_to_mtd</span>(<span class="title">dev</span>);</span></span><br><span class="line">	u32 addr = ((<span class="keyword">loff_t</span>) block_no) * dev-&gt;param.total_bytes_per_chunk *dev-&gt;param.chunks_per_block;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">erase_info</span> <span class="title">ei</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">........</span><br><span class="line">	retval = mtd_erase(mtd, &amp;ei);</span><br><span class="line">.......</span><br><span class="line">	<span class="keyword">if</span> (retval == <span class="number">0</span>)<span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">	<span class="keyword">return</span> YAFFS_FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，块初始化及管理大致过程分析结束，下一章节介绍Checkpoint机制</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>YAFFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Yaffs文件系统(3)-- 检查点(Checkpoint)机制</title>
    <url>/p/9d617ede.html</url>
    <content><![CDATA[<p>前文对Yaffs文件系统<a href="https://www.l2h.site/2019/04/30/yaffs-1/" target="_blank" rel="noopener">框架</a>及<a href="https://www.l2h.site/2019/05/14/yaffs-2/" target="_blank" rel="noopener">Block</a>管理，本文介绍Yaffs的检查点机制。什么是检查点机制？文件系统将目录结构存储在Nand Flash中一个特殊Block内，在Mount时快速加载，加速文件系统的加载。同时，机制也可以一定程度上避免因为突然掉电等因素造成的文件系统破坏。</p><p>本章先介绍文件的Tnode Tree，接着介绍Yaffs的checkpoint格式。</p><a id="more"></a>

<h2 id="Tnode-Tree"><a href="#Tnode-Tree" class="headerlink" title="Tnode Tree"></a>Tnode Tree</h2><p>Tnode Tree是Yaffs文件系统用来存储某个文件与其所在Nand Flash位置关系的一个树状结构。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tnode</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_tnode</span> *<span class="title">internal</span>[<span class="title">YAFFS_NTNODES_INTERNAL</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，tnode存储为简单的指针数组，内部存储为指向下一级tnodes的指针。其结构如下：</p>
<p><img src="http://pic.l2h.site/tnode.png" alt></p>
<p>Tnode树结构</p>
<p>可以看出，只有最后一级（即Level 0）存放的是该文件所在Nand Flash的位置。具体如何存储的此处不做过多说明，请大家自行分析，主要为一些位计算。</p>
<h2 id="Checkpoint存储格式"><a href="#Checkpoint存储格式" class="headerlink" title="Checkpoint存储格式"></a>Checkpoint存储格式</h2><p>Checkpoint的存储格式如下图：</p>
<p><img src="http://pic.l2h.site/checkpoint-2-1024x792.png" alt></p>
<p>在Checkpoint内部存储的内容依次是：</p>
<ul>
<li>1字节有效性标记</li>
<li>36字节的设备信息相关变量，储存第一章介绍的<a href="https://www.l2h.site/2019/04/30/yaffs-1/#i-4" target="_blank" rel="noopener">yaffs_dev结构体</a>必须的内容</li>
<li>该分区所有Nand块的信息，包括块内的chunk是否被使用</li>
<li>所有文件或目录的信息，与运行时RAM里存储的内容类似</li>
<li>1字节尾部有效性标记</li>
<li>检查点所有内容的校验和</li>
</ul>
<p>需要说明的是Yaffs的检查点信息，会使用专门的块来存储。其obj_id为特殊的0x21，且checkpoint不存在chunk id为0的Object（即 Header Object）。一个简单的checkpoint存储内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------------+</span><br><span class="line">|数 据                       |</span><br><span class="line">|                            |</span><br><span class="line">|                        数据|</span><br><span class="line">+----------------------------+</span><br><span class="line">|0x21 chunk_id(1) size ecc   |</span><br><span class="line">+----------------------------+</span><br><span class="line">|数据                        |</span><br><span class="line">|                            |</span><br><span class="line">|                        数据|</span><br><span class="line">+----------------------------+</span><br><span class="line">|0x21 chunk_id(2) size ecc   |</span><br><span class="line">+----------------------------+</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|  ........................  |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">|                            |</span><br><span class="line">+----------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="Checkpoint读写擦除"><a href="#Checkpoint读写擦除" class="headerlink" title="Checkpoint读写擦除"></a>Checkpoint读写擦除</h2><p>Checkpoint是按照前一节所介绍存储结构的顺序进行读写。</p>
<ul>
<li>读Checkpoint的函数入口是yaffs2_checkpt_restore()-&gt;yaffs2_rd_checkpt_data()，一般在Mount时进行</li>
<li>写Checkpoint的函数入口是yaffs_checkpoint_save()-&gt;yaffs2_wr_checkpt_data()</li>
<li>擦除Checkpoint的函数入口是yaffs2_checkpt_invalidate()-&gt;yaffs2_checkpt_invalidate_stream()-&gt; yaffs_checkpt_erase()</li>
</ul>
<p>代码如下（相对比较容易理解不做过多注释）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs2_checkpt_restore</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	retval = yaffs2_rd_checkpt_data(dev);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;is_checkpointed) &#123;</span><br><span class="line">		yaffs_verify_objects(dev);</span><br><span class="line">		yaffs_verify_blocks(dev);</span><br><span class="line">		yaffs_verify_free_chunks(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"restore exit: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs2_rd_checkpt_data</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ok = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;param.is_yaffs2) ok = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (ok &amp;&amp; dev-&gt;param.skip_checkpt_rd) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"skipping checkpoint read"</span>);</span><br><span class="line">		ok = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok)</span><br><span class="line">		ok = yaffs2_checkpt_open(dev, <span class="number">0</span>); <span class="comment">/* open for read */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint validity"</span>);</span><br><span class="line">		ok = yaffs2_rd_checkpt_validity_marker(dev, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint device"</span>);</span><br><span class="line">		ok = yaffs2_rd_checkpt_dev(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"read checkpoint objects"</span>);</span><br><span class="line">		ok = yaffs2_rd_checkpt_objs(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"read checkpoint validity"</span>);</span><br><span class="line">		ok = yaffs2_rd_checkpt_validity_marker(dev, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		ok = yaffs2_rd_checkpt_sum(dev);</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"read checkpoint checksum %d"</span>, ok);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!yaffs_checkpt_close(dev))ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok) dev-&gt;is_checkpointed = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> dev-&gt;is_checkpointed = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ok ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_checkpoint_save</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"save entry: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line">	yaffs_verify_objects(dev);</span><br><span class="line">	yaffs_verify_blocks(dev);</span><br><span class="line">	yaffs_verify_free_chunks(dev);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;is_checkpointed) &#123;</span><br><span class="line">		yaffs2_checkpt_invalidate(dev);</span><br><span class="line">		yaffs2_wr_checkpt_data(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT, <span class="string">"save exit: is_checkpointed %d"</span>, dev-&gt;is_checkpointed);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;is_checkpointed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs2_wr_checkpt_data</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!yaffs2_checkpt_required(dev)) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT,<span class="string">"skipping checkpoint write"</span>);ok = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok) ok = yaffs2_checkpt_open(dev, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint validity"</span>); ok = yaffs2_wr_checkpt_validity_marker(dev, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint device"</span>); ok = yaffs2_wr_checkpt_dev(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint objects"</span>); ok = yaffs2_wr_checkpt_objs(dev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">		yaffs_trace(YAFFS_TRACE_CHECKPOINT, <span class="string">"write checkpoint validity"</span>); ok = yaffs2_wr_checkpt_validity_marker(dev, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ok) ok = yaffs2_wr_checkpt_sum(dev);</span><br><span class="line">	<span class="keyword">if</span> (!yaffs_checkpt_close(dev)) ok = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ok) dev-&gt;is_checkpointed = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> dev-&gt;is_checkpointed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev-&gt;is_checkpointed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容即为Yaffs的Checkpoint机制，接下来将会介绍GC（Garbage Collection，垃圾回收）机制。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>YAFFS</tag>
      </tags>
  </entry>
  <entry>
    <title>YAFFS文件系统(4)– 垃圾回收(GC)机制</title>
    <url>/p/254f2d7d.html</url>
    <content><![CDATA[<p>垃圾回收(Garbage Collection。 注：其实“垃圾回收”比较像是直译，叫“块回收”似乎比较恰当 )机制的主要作用是为了回收空闲或接近空闲的Nand块（Block），供文件系统后续使用（例如，创建文件、扩展文件大小、修改文件内容）。第一章《<a href="https://www.l2h.site/2019/04/30/yaffs-1/" target="_blank" rel="noopener">概述</a>》启动代码分析 yaffs_bg_start函数，其作用就是启用Linux内核线程，专门用来做垃圾回收。因为是内核线程做垃圾回收，后台工作找到可以回收的Flash块就用内核空闲的时间做回收，因此较大程度提升了Yaffs的工作性能。</p><a id="more"></a>
<p>“垃圾回收”的核心思想为：</p>
<ul>
<li>先找到可以或者说值得回收的Block。注意：这里值得回收并非指的是Block内所有的Chunk（或者说Page）都无用了。Yaffs的回收器会根据一定的算法（本章之后小节会介绍）来找到一个可回收的Block。</li>
<li>对该Block内所有的Chunk进行遍历。若当前Chunk正在使用中，会将该Chunk复制一份到另外的Block内，并删除该Chunk。同时要更新文件Tnode、Block使用等内存中的信息。<ul>
<li>所以同一个文件存储到Flash上后，就算不被改写，存放位置也不一定是一成不变的。</li>
<li>另外，因此我们也会看到Flash上可能会存储同一个文件的同一个Chunk在不同的位置（当然也有可能是文件被改写造成的）。Yaffs用seq_number位来标记使用哪一个chunk作为当前文件真正要使用的chunk（seq_number大者为较新）。</li>
</ul>
</li>
<li>当Block内所有的Chunk都顺利删除后，则可以对Block进行擦除，供后续使用。</li>
</ul>
<p>Yaffs的垃圾回收有两种模式，取决于当前Nand Flash空间的使用状况。当Flash中仍有许多可用Block时，回收机制会相对缓和地回收（实际程序执行上，Yaffs后台程序会每次回收较少数量的chunk而不用回收完一个完整的Block），称为Passive（被动）模式，此时需要尽快释放出一个完整可用的block。否则称为Aggressive（主动）模式。两种模式的判断依据为，Flash所剩可用的Block数量是否小于预留Block数量加上Checkpoint所需Block数量。</p>
<p>以下是代码分析。首先看入口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_bg_thread_fn</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.......</span><br><span class="line">	<span class="keyword">while</span> (context-&gt;bg_running) &#123;</span><br><span class="line"><span class="comment">//此循环为后台垃圾回收线程主循环</span></span><br><span class="line">		yaffs_trace(YAFFS_TRACE_BACKGROUND, <span class="string">"yaffs_background"</span>);</span><br><span class="line">		<span class="keyword">if</span> (kthread_should_stop()) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//访问yaffs临界区数据做保护</span></span><br><span class="line">		yaffs_gross_lock(dev);</span><br><span class="line"></span><br><span class="line">		now = jiffies;</span><br><span class="line"><span class="comment">//若目前已经到脏目录更新时间，则更新脏目录信息。</span></span><br><span class="line"><span class="comment">//脏目录：目录内的文件被添加、修改或删除，则需要更新目录的访问时间等信息。Yaffs将此操作延后到垃圾回收时间，主要是性能考虑。例：若某段时间内该目录下有多个文件被修改，可以最后做一次更新而不用每次修改都更新该目录的访问时间</span></span><br><span class="line">		<span class="keyword">if</span> (time_after(now, next_dir_update) &amp;&amp; yaffs_bg_enable) &#123;</span><br><span class="line">			yaffs_update_dirty_dirs(dev);</span><br><span class="line">			next_dir_update = now + HZ;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//若目前已到垃圾回收时间，则开始垃圾回收，并计算下次垃圾回收时间</span></span><br><span class="line">		<span class="keyword">if</span> (time_after(now, next_gc) &amp;&amp; yaffs_bg_enable) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!dev-&gt;is_checkpointed) &#123;</span><br><span class="line">				urgency = yaffs_bg_gc_urgency(dev);</span><br><span class="line"><span class="comment">//执行垃圾回收</span></span><br><span class="line">				gc_result = yaffs_bg_gc(dev, urgency);</span><br><span class="line"><span class="comment">//根据紧急度来计算下次垃圾回收时间</span></span><br><span class="line">				<span class="keyword">if</span> (urgency &gt; <span class="number">1</span>)</span><br><span class="line">					next_gc = now + HZ / <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (urgency &gt; <span class="number">0</span>)</span><br><span class="line">					next_gc = now + HZ / <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next_gc = now + HZ * <span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span>	&#123;</span><br><span class="line">				next_gc = next_dir_update;</span><br><span class="line">                        &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		yaffs_gross_unlock(dev);</span><br><span class="line"><span class="comment">//计算下次唤醒该线程的时间</span></span><br><span class="line">		expires = next_dir_update;</span><br><span class="line">		<span class="keyword">if</span> (time_before(next_gc, expires))</span><br><span class="line">			expires = next_gc;</span><br><span class="line">		<span class="keyword">if</span> (time_before(expires, now))</span><br><span class="line">			expires = now + HZ;</span><br><span class="line"><span class="comment">//将垃圾回收线程（也就是正在执行的线程自己）让出调度，同时增加内核定时器到时唤醒此线程</span></span><br><span class="line">		Y_INIT_TIMER(&amp;timer.timer, yaffs_background_waker);</span><br><span class="line">		timer.timer.expires = expires + <span class="number">1</span>;</span><br><span class="line">		timer.task = current;</span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		add_timer(&amp;timer);</span><br><span class="line">		schedule();</span><br><span class="line">		del_timer_sync(&amp;timer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看Yaffs如何进行脏目录更新：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yaffs_update_dirty_dirs</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">........</span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;dev-&gt;dirty_dirs)) &#123;</span><br><span class="line">		link = dev-&gt;dirty_dirs.next;</span><br><span class="line">		list_del_init(link);</span><br><span class="line"></span><br><span class="line">		d_s = list_entry(link, struct yaffs_dir_var, dirty);</span><br><span class="line">		o_v = list_entry(d_s, <span class="keyword">union</span> yaffs_obj_var, dir_variant);</span><br><span class="line">		obj = list_entry(o_v, struct yaffs_obj, variant);</span><br><span class="line">		<span class="keyword">if</span> (obj-&gt;dirty)</span><br><span class="line"><span class="comment">//执行更新目录的操作</span></span><br><span class="line">			yaffs_update_oh(obj, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_update_oh</span><span class="params">(struct yaffs_obj \*in, <span class="keyword">const</span> YCHAR \*name, <span class="keyword">int</span> force,<span class="keyword">int</span> is_shrink, <span class="keyword">int</span> shadows, struct yaffs_xattr_mod *xmod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(old_name, _Y(<span class="string">"silly old name"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (in-&gt;fake &amp;&amp; in != dev-&gt;root_dir &amp;&amp; !force &amp;&amp; !xmod)</span><br><span class="line">		<span class="keyword">return</span> ret_val;</span><br><span class="line"><span class="comment">//垃圾回收代码，后续分析</span></span><br><span class="line">	yaffs_check_gc(dev, <span class="number">0</span>);</span><br><span class="line">	yaffs_check_obj_details_loaded(in);</span><br><span class="line">	<span class="built_in">buffer</span> = yaffs_get_temp_buffer(in-&gt;my_dev);</span><br><span class="line">	oh = (struct yaffs_obj_hdr *)<span class="built_in">buffer</span>;</span><br><span class="line">	prev_chunk_id = in-&gt;hdr_chunk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//从Flash读出文件或者目录的标签（主要是读出文件名）</span></span><br><span class="line">		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,<span class="built_in">buffer</span>, &amp;old_tags);</span><br><span class="line">		<span class="keyword">if</span> (result == YAFFS_OK) &#123;</span><br><span class="line"><span class="comment">//对新分配的目录对象赋值</span></span><br><span class="line">			yaffs_verify_oh(in, oh, &amp;old_tags, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">memcpy</span>(old_name, oh-&gt;name, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">			<span class="built_in">memset</span>(oh, <span class="number">0xff</span>, <span class="keyword">sizeof</span>(*oh));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="number">0xff</span>, dev-&gt;data_bytes_per_chunk);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oh-&gt;type = in-&gt;variant_type;</span><br><span class="line">	oh-&gt;yst_mode = in-&gt;yst_mode;</span><br><span class="line">	oh-&gt;shadows_obj = oh-&gt;inband_shadowed_obj_id = shadows;</span><br><span class="line"><span class="comment">//文件属性赋值</span></span><br><span class="line">	yaffs_load_attribs_oh(oh, in);</span><br><span class="line"><span class="comment">//父目录赋值</span></span><br><span class="line">	<span class="keyword">if</span> (in-&gt;parent)</span><br><span class="line">		oh-&gt;parent_obj_id = in-&gt;parent-&gt;obj_id;</span><br><span class="line">	<span class="keyword">else</span> oh-&gt;parent_obj_id = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//文件名赋值</span></span><br><span class="line">	<span class="keyword">if</span> (name &amp;&amp; *name) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(oh-&gt;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">		yaffs_load_oh_from_name(dev, oh-&gt;name, name);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(oh-&gt;name, old_name, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">memset</span>(oh-&gt;name, <span class="number">0</span>, <span class="keyword">sizeof</span>(oh-&gt;name));</span><br><span class="line">	&#125;</span><br><span class="line">	oh-&gt;is_shrink = is_shrink;</span><br><span class="line">	<span class="keyword">switch</span> (in-&gt;variant_type) &#123;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_UNKNOWN:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_FILE:</span><br><span class="line">		<span class="keyword">if</span> (oh-&gt;parent_obj_id != YAFFS_OBJECTID_DELETED &amp;&amp;</span><br><span class="line">		    oh-&gt;parent_obj_id != YAFFS_OBJECTID_UNLINKED)</span><br><span class="line">			file_size = in-&gt;variant.file_variant.stored_size;</span><br><span class="line">		yaffs_oh_size_load(dev, oh, file_size, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_HARDLINK:</span><br><span class="line">		oh-&gt;equiv_id = in-&gt;variant.hardlink_variant.equiv_id;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_SPECIAL:</span><br><span class="line">		/\* Do nothing */</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_DIRECTORY:</span><br><span class="line">		/\* Do nothing */</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> YAFFS_OBJECT_TYPE_SYMLINK:</span><br><span class="line">		alias = in-&gt;variant.symlink_variant.alias;</span><br><span class="line">		<span class="keyword">if</span> (!alias) alias = _Y(<span class="string">"no alias"</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(oh-&gt;alias, alias, YAFFS_MAX_ALIAS_LENGTH);</span><br><span class="line">		oh-&gt;alias[YAFFS_MAX_ALIAS_LENGTH] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//赋值过程</span></span><br><span class="line">	<span class="keyword">if</span> (xmod)</span><br><span class="line">		yaffs_apply_xattrib_mod(in, (<span class="keyword">char</span> *)<span class="built_in">buffer</span>, xmod);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;new_tags, <span class="number">0</span>, <span class="keyword">sizeof</span>(new_tags));</span><br><span class="line">	in-&gt;serial++;</span><br><span class="line">	new_tags.chunk_id = <span class="number">0</span>;</span><br><span class="line">	new_tags.obj_id = in-&gt;obj_id;</span><br><span class="line">	new_tags.serial_number = in-&gt;serial;</span><br><span class="line">	new_tags.extra_available = <span class="number">1</span>;</span><br><span class="line">	new_tags.extra_parent_id = oh-&gt;parent_obj_id;</span><br><span class="line">	new_tags.extra_file_size = file_size;</span><br><span class="line">	new_tags.extra_is_shrink = oh-&gt;is_shrink;</span><br><span class="line">	new_tags.extra_equiv_id = oh-&gt;equiv_id;</span><br><span class="line">	new_tags.extra_shadows = (oh-&gt;shadows_obj &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">	new_tags.extra_obj_type = in-&gt;variant_type;</span><br><span class="line">	yaffs_do_endian_oh(dev, oh);</span><br><span class="line"><span class="comment">//将新文件信息写回Nand Flash</span></span><br><span class="line">	yaffs_verify_oh(in, oh, &amp;new_tags, <span class="number">1</span>);</span><br><span class="line">	new_chunk_id =  yaffs_write_new_chunk(dev, <span class="built_in">buffer</span>, &amp;new_tags,(prev_chunk_id &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">buffer</span>) yaffs_release_temp_buffer(dev, <span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_chunk_id &lt; <span class="number">0</span>) <span class="keyword">return</span> new_chunk_id;</span><br><span class="line"></span><br><span class="line">	in-&gt;hdr_chunk = new_chunk_id;</span><br><span class="line"><span class="comment">//删除原有的文件chunk（因为我们已经有替代者了）。注意这里删除只是简单的对文件所在block的bitmap做一下标记</span></span><br><span class="line">	<span class="keyword">if</span> (prev_chunk_id &gt; <span class="number">0</span>) yaffs_chunk_del(dev, prev_chunk_id, <span class="number">1</span>, __LINE__);</span><br><span class="line">	<span class="keyword">if</span> (!yaffs_obj_cache_dirty(in))</span><br><span class="line">		in-&gt;dirty = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (is_shrink) &#123;</span><br><span class="line">		bi = yaffs_get_block_info(in-&gt;my_dev, new_chunk_id / in-&gt;my_dev-&gt;param.chunks_per_block);</span><br><span class="line">		bi-&gt;has_shrink_hdr = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> new_chunk_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">紧急程度计算方法见yaffs_bg_gc_urgency函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">yaffs_bg_gc_urgency</span><span class="params">(struct yaffs_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_linux_context</span> *<span class="title">context</span> = <span class="title">yaffs_dev_to_lc</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">unsigned</span> scattered = <span class="number">0</span>;	<span class="comment">/* Free chunks not in an erased block */</span></span><br><span class="line"><span class="comment">//scattered为计算除空闲block外，整个flash剩余的可用chunk数量</span></span><br><span class="line">	<span class="keyword">if</span> (erased_chunks &lt; dev-&gt;n_free_chunks) scattered = (dev-&gt;n_free_chunks - erased_chunks);</span><br><span class="line"><span class="comment">//若非后台运行，则直接返回urgency0</span></span><br><span class="line">	<span class="keyword">if</span> (!context-&gt;bg_running)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//若数量小于2个block，表示暂时不需要开辟新block来做chunk分配</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (scattered &lt; (dev-&gt;param.chunks_per_block * <span class="number">2</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//当可用非空block的空闲chunk已经不足2个block。则比较空闲block数量占所有空闲chunk比重。若占比较大，则回收紧急程度不高，否则紧急程度较高</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">4</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最核心的垃圾回收代码yaffs_bg_gc如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yaffs_bg_gc</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">unsigned</span> urgency)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="comment">//垃圾回收</span></span><br><span class="line">	yaffs_check_gc(dev, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> erased_chunks &gt; dev-&gt;n_free_chunks / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_check_gc</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> <span class="built_in">background</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;param.gc_control_fn &amp;&amp; (dev-&gt;param.gc_control_fn(dev) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> YAFFS_OK;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;gc_disable) <span class="keyword">return</span> YAFFS_OK;</span><br><span class="line"><span class="comment">//执行垃圾回收</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		max_tries++;</span><br><span class="line"><span class="comment">//计算checkpoint所需的Flash Block数量</span></span><br><span class="line">		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);</span><br><span class="line"><span class="comment">//计算最少需要的块数量</span></span><br><span class="line">		min_erased = dev-&gt;param.n_reserved_blocks + checkpt_block_adjust + <span class="number">1</span>;</span><br><span class="line">		erased_chunks = dev-&gt;n_erased_blocks * dev-&gt;param.chunks_per_block;</span><br><span class="line"><span class="comment">//若空闲Block数量小于最小需求，则需要进行主动回收</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; min_erased)</span><br><span class="line">			aggressive = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//若非后台回收，且空闲的block对应chunk数量大于总空闲chunk数量（含已分配Block中未使用的chunk）的四分之一则退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">background</span> &amp;&amp; erased_chunks &gt; (dev-&gt;n_free_chunks / <span class="number">4</span>)) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (dev-&gt;gc_skip &gt; <span class="number">20</span>) dev-&gt;gc_skip = <span class="number">20</span>;</span><br><span class="line">			<span class="keyword">if</span> (erased_chunks &lt; dev-&gt;n_free_chunks / <span class="number">2</span> || dev-&gt;gc_skip &lt; <span class="number">1</span> || <span class="built_in">background</span>) aggressive = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dev-&gt;gc_skip--;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev-&gt;gc_skip = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//若目前还未指定到要回收的Block且执行被动模式，则尝试找到一个seq最老的需要刷新的block。</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;gc_block &lt; <span class="number">1</span> &amp;&amp; !aggressive) &#123;</span><br><span class="line">			dev-&gt;gc_block = yaffs2_find_refresh_block(dev);</span><br><span class="line">			dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">			dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//若仍未找到可回收块。则查找最脏的块进行回收</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;gc_block &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			dev-&gt;gc_block = yaffs_find_gc_block(dev, aggressive, <span class="built_in">background</span>);</span><br><span class="line">			dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">			dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//进行回收</span></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;gc_block &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev-&gt;all_gcs++;</span><br><span class="line">			<span class="keyword">if</span> (!aggressive) dev-&gt;passive_gc_count++;</span><br><span class="line">			gc_ok = yaffs_gc_block(dev, dev-&gt;gc_block, aggressive);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks &amp;&amp; dev-&gt;gc_block &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_GC, <span class="string">"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d"</span>, dev-&gt;n_erased_blocks, max_tries, dev-&gt;gc_block);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((dev-&gt;n_erased_blocks &lt; (<span class="keyword">int</span>)dev-&gt;param.n_reserved_blocks) &amp;&amp;  (dev-&gt;gc_block &gt; <span class="number">0</span>) &amp;&amp; (max_tries &lt; <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> aggressive ? gc_ok : YAFFS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yaffs_gc_block代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">yaffs_gc_block</span><span class="params">(struct yaffs_dev *dev, <span class="keyword">int</span> block, <span class="keyword">int</span> whole_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.......</span><br><span class="line">	<span class="keyword">int</span> chunks_before = yaffs_get_erased_chunks(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">yaffs_block_info</span> *<span class="title">bi</span> = <span class="title">yaffs_get_block_info</span>(<span class="title">dev</span>, <span class="title">block</span>);</span></span><br><span class="line">	is_checkpt_block = (bi-&gt;block_state == YAFFS_BLOCK_STATE_CHECKPOINT);</span><br><span class="line"><span class="comment">//改变Block状态为正在回收</span></span><br><span class="line">	<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_FULL) bi-&gt;block_state = YAFFS_BLOCK_STATE_COLLECTING;</span><br><span class="line"></span><br><span class="line">	bi-&gt;has_shrink_hdr = <span class="number">0</span>;	</span><br><span class="line"><span class="comment">//因为正在做回收，暂时关闭回收</span></span><br><span class="line">	dev-&gt;gc_disable = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//回收summary chunk</span></span><br><span class="line">	yaffs_summary_gc(dev, block);</span><br><span class="line"><span class="comment">//若是checkpoint block或者block没有正在使用的chunk，直接回收</span></span><br><span class="line">	<span class="keyword">if</span> (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) &#123;</span><br><span class="line">		yaffs_block_became_dirty(dev, block);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//否则，复制block内的使用中chunk到其他block并回收block</span></span><br><span class="line">		u8 *<span class="built_in">buffer</span> = yaffs_get_temp_buffer(dev);</span><br><span class="line">		yaffs_verify_blk(dev, bi, block);</span><br><span class="line">		max_copies = (whole_block) ? dev-&gt;param.chunks_per_block : <span class="number">5</span>;</span><br><span class="line">		old_chunk = block * dev-&gt;param.chunks_per_block + dev-&gt;gc_chunk;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="comment">/* init already done */</span> ;</span><br><span class="line">		     ret_val == YAFFS_OK &amp;&amp;</span><br><span class="line">		     dev-&gt;gc_chunk &lt; dev-&gt;param.chunks_per_block &amp;&amp;</span><br><span class="line">		     (bi-&gt;block_state == YAFFS_BLOCK_STATE_COLLECTING) &amp;&amp;</span><br><span class="line">		     max_copies &gt; <span class="number">0</span>;  dev-&gt;gc_chunk++, old_chunk++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (yaffs_check_chunk_bit(dev, block, dev-&gt;gc_chunk)) &#123; </span><br><span class="line">				max_copies--;</span><br><span class="line"><span class="comment">//对每个chunk进行复制和回收</span></span><br><span class="line">				ret_val = yaffs_gc_process_chunk(dev, bi,</span><br><span class="line">							old_chunk,<span class="built_in">buffer</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		yaffs_release_temp_buffer(dev, <span class="built_in">buffer</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	yaffs_verify_collected_blk(dev, bi, block);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bi-&gt;block_state == YAFFS_BLOCK_STATE_COLLECTING) &#123;</span><br><span class="line">		bi-&gt;block_state = YAFFS_BLOCK_STATE_FULL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;n_clean_ups; i++) &#123;</span><br><span class="line"><span class="comment">//对所有的object，进行一次性统一删除</span></span><br><span class="line">			struct yaffs_obj *object = yaffs_find_by_number(dev, dev-&gt;gc_cleanup_list[i]);</span><br><span class="line">			<span class="keyword">if</span> (object) &#123;</span><br><span class="line">				yaffs_free_tnode(dev,  object-&gt;variant.file_variant.top);</span><br><span class="line">				object-&gt;variant.file_variant.top = <span class="literal">NULL</span>;</span><br><span class="line">				yaffs_generic_obj_del(object);</span><br><span class="line">				object-&gt;my_dev-&gt;n_deleted_files--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		chunks_after = yaffs_get_erased_chunks(dev);</span><br><span class="line">		<span class="keyword">if</span> (chunks_before &gt;= chunks_after)</span><br><span class="line">			yaffs_trace(YAFFS_TRACE_GC, <span class="string">"gc did not increase free chunks before %d after %d"</span>, chunks_before, chunks_after);</span><br><span class="line">		dev-&gt;gc_block = <span class="number">0</span>;</span><br><span class="line">		dev-&gt;gc_chunk = <span class="number">0</span>;</span><br><span class="line">		dev-&gt;n_clean_ups = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;gc_disable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，即为Yaffs垃圾回收机制的分析。至此，Yaffs文件系统代码分析结束。若有不恰当之处，也请大家多交流指出。</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>YAFFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Zoc for Mac注册码收集</title>
    <url>/p/cdb99e66.html</url>
    <content><![CDATA[<p>一直使用ZoC做阿里云ECS管理，方便好用。不过经常会License过期。<br>收集几个备用，之后过期可以来这里拿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Part A: 55834/01027/59600</span><br><span class="line">Part B: 43010</span><br><span class="line"></span><br><span class="line">Part A: 11370/01027/29134</span><br><span class="line">Part B: 51686</span><br><span class="line"></span><br><span class="line">Part A: 61298/01028/48550</span><br><span class="line">Part B: 00985</span><br><span class="line"></span><br><span class="line">Part A: 51698/01027/34713</span><br><span class="line">Part B: 00937</span><br><span class="line"></span><br><span class="line">Part A: 50866/01027/47775</span><br><span class="line">Part B: 57341</span><br><span class="line"></span><br><span class="line">Part A: 53866/01028/18861</span><br><span class="line">Part B: 45757</span><br><span class="line"></span><br><span class="line">Part A: 03754/01029/23239</span><br><span class="line">Part B: 50179</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>L&amp;amp;H Site</tag>
      </tags>
  </entry>
</search>
